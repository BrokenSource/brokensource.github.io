{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Landing Page","text":"Broken Source Software   I'm an Open-Source Developer dedicated on making Useful Niched Software My mission is simple: Give as much power to all my users as possible <p>\ud83d\ude80 Convenience: You're probably looking for the Installation Guide</p>"},{"location":"#suggestions","title":"\u2705 Suggestions","text":"<p>\u2b50\ufe0f Learn about my projects:</p> <ul> <li>DepthFlow: Image to \u2192 2.5D Parallax Effect Video</li> <li>ShaderFlow: Audio Reactive Shader Render engine</li> <li>Pianola: World's smoothest Piano Roll, spring physics</li> <li>SpectroNote: Unlock a Hidden Perfect Pitch in You</li> </ul> <p>\ud83d\udcac Join the Community servers on Discord and Telegram</p> <p>\u2764\ufe0f Join my Sponsors, so I can continue Open Source work</p> <p>\u2696\ufe0f Learn about my Copyleft Licensing and intentions</p>"},{"location":"about/contact/","title":"About/Contact","text":"<p>You can reach me through the following platforms:</p> <ul> <li> <p> Discord</p> <p>Quick questions, feedback and support</p> <ul> <li>Community help, showcase</li> </ul> <p> Join Server</p> </li> <li> <p> Telegram</p> <p>I'm more \"real time\" here than Discord</p> <ul> <li>Larger uploads can be useful</li> </ul> <p> Join Group</p> </li> <li> <p> GitHub</p> <p>Officialize your Requests or Issues</p> <ul> <li>One repository per project</li> </ul> <p> All Projects</p> </li> <li> <p> Email <sup>1</sup></p> <p>Get in touch directly and privately</p> <ul> <li>Business and Formal</li> </ul> <p> Send a Message</p> </li> </ul> <p>I live on UTC-04:00 Timezone (EDT), so I might be sleeping when you send me a message</p> <p>Feel free to talk in any of the Languages:</p> <ul> <li>\ud83c\udde7\ud83c\uddf7 Brazilian Portuguese, my native language</li> <li>\ud83c\uddfa\ud83c\uddf8 English: I should practice speaking \ud83d\ude05</li> </ul> <ol> <li> <p>Feel free to Direct Message me on Discord or Telegram for Formal enquiries as well\u00a0\u21a9</p> </li> </ol>"},{"location":"about/license/","title":"About/License","text":"<p>\ud83d\udea7 This page is under construction and not final \ud83d\udea7</p> <p>Let's keep it simple, short and fair</p> <p>Each project has its own License. More often than not, Code is AGPLv3 and Art<sup>1</sup> CC-BY-4.0</p> <p>You must always check the Repository's <code>License.md</code> file for legal information, or the contents of any Source Code file for copyright information and use</p> <ul> <li>This page's contents are a custom licensing model \u2705 fair encouragements</li> <li>I only ask to not abuse my years of work, \u2705 let's grow together</li> <li>For my integrity<sup>2</sup>, I may change this page at any time</li> </ul>"},{"location":"about/license/#use-cases","title":"Use cases","text":"<p>There are a few end goals on which the Projects can be used:</p>"},{"location":"about/license/#personal-use","title":"\ud83d\udd34 Personal use","text":"<p>There are no restrictions on private use of any Software (family, friends, you)</p> <ul> <li>Be creative and have fun. Study and modify as you like</li> <li>No strings attached! It's Free and Open Source Software</li> <li>(And link the Project if they're interested :)</li> </ul> <p>Note: Monetizing online content counts as Commercial Use</p>"},{"location":"about/license/#educational-use","title":"\ud83d\udfe1 Educational use","text":"<p>I am more than happy if you're using anything for institutional purposes</p> <ul> <li>You should not paywall this content, science must be free</li> <li>Feel absolutely free to automate, deploy for students</li> <li>I deeply hope it helps your community to learn :)</li> </ul> Note: Using Copyrighted Material you do not own might fall under Educational Use <p>Using Copyrighted Work as input assets is a great way to check the final quality of anything</p> <p>As you don't own the material's copyright, you can't sell it. Nevertheless, you're probably fine sharing it online, specially if it's for a small amount of people or.. allegedly for educational purposes</p> <ul> <li>Beware the material owners might takedown your work at any time</li> </ul>"},{"location":"about/license/#commercial-use","title":"\ud83d\udfe2 Commercial use","text":"<p>Here's the dilema: If I was against commercial use, I wouldn't use it myself as a user (1)</p> <ol> <li>Not only that, I depend on many Shoulders of Giants</li> </ol> <ul> <li>My mission is to empower you, and make awesome tools to the world</li> <li>I must be doing well to continue the work, we live in a society...</li> <li>It is my desire and goal for you to use the tools commercially</li> </ul> <p>Fairness makes the difference</p> <p>If you're profiting from my work, donate an amount that reflects how much essential it was to your success</p> <ul> <li>The bigger you are, the more you can feed my gratitude of empowering you \ud83d\ude2d</li> <li>Remember: I provide professional, high quality tools for free (1)</li> </ul> <ol> <li>You have locally run, free alternatives for:<ul> <li>Services like LeiaPix: $0.50 per video</li> <li>Services like Specterr: $75.00 per month</li> <li>Synthesia: One time $40.00 payment</li> </ul> </li> </ol> Click for (self judged) fair examples <p>\u2705 Warm feeling of giving something back:</p> <ul> <li>A Shader you coded for your video: Single time 10-20 bucks (ShaderFlow convenience framework)</li> <li>DepthFlow inserts in your content: Maybe $0.25 per insert? (The Product is better than competition)</li> <li>Piano visualizations you posted: Single time 5 or 10 bucks (Spring physics are worth it !)</li> </ul> <p>\u2705 Infinite revenue:</p> <ul> <li>Your music channel under ShaderFlow: Perhaps $50+ monthly (Depends on size and engagement)</li> <li>Automated accounts farming videos: Perhaps 20% of total (We're dead internet entrepreneurs, lol?)</li> <li>Live streaming procedural content: Perhaps 5% of total (Make yours stream catchier OwO)9</li> </ul>"},{"location":"about/license/#business-use","title":"\ud83d\udd35 Business use","text":"<p>Interested in powering your current or future business, need support in anything?</p> <ul> <li>\u2b50\ufe0f Join Forces: I miss the infra and marketing, you now have the product</li> <li>\ud83d\ude80 Get in touch with me, let's shred the competition together</li> </ul>"},{"location":"about/license/#user-content","title":"User Content","text":""},{"location":"about/license/#third-party","title":"Third Party","text":"<p>Projects may bundle assets files or download them at runtime.</p> <p>Most notably:</p> <ul> <li>Programs: Like FFmpeg, \u00a0FluidSynth, \u00a0RealESRGAN, \u00a0Waifu2x</li> <li>Models<sup>3</sup>: Such as DepthAnything, \u00a0Marigold, \u00a0ZoeDepth</li> <li>Soundfonts:</li> <li>Fonts: DejaVu Fonts</li> </ul> <p>Be careful with FFmpeg codecs when selling commercial work</p> <p>While FFmpeg is fully Open Source, certain data streams format are not, most notably H264</p> <ol> <li> <p>Usually hard work Shaders, like Pianola's, DepthFlow. Logos are trademarks\u00a0\u21a9</p> </li> <li> <p>If something goes wrong, I'll update the page to protect users. I also might improve the model, so it's more globally sustainable. Realistically speaking, I can't enforce any of this anyways\u00a0\u21a9</p> </li> <li> <p>Downloaded via PyTorch Hub, or HuggingFace's Transformers.\u00a0\u21a9</p> </li> </ol>"},{"location":"about/roadmap/","title":"About/Roadmap","text":"<p>Some opportunities and IRL obligations are being focused on</p> <p>I have a pretty decent vision for any two next weeks of development, and work based on priorities that would give the most value and quality of life to the Projects.</p> <ul> <li>Items may happen out of order, delayed, not at all, and retroactively apply</li> <li>Minor unlisted items may be worked on instead of listed ones</li> </ul>"},{"location":"about/roadmap/#stage-1-low-hanging-fruits","title":"Stage 1: Low Hanging Fruits","text":"<p>Quality of Life features for what works today</p> <ul> <li> Fastest Piano Roll code in Python in the world</li> <li> Code logistics for FFmpeg advanced and easy configuration</li> <li> Write CI workflows for releases, PyPI and GitHub Pages</li> <li> Improve the Website and Documentation</li> <li> Preset System for DepthFlow, CLI and API friendly</li> <li> Better ShaderFlow Shader Library include file</li> <li> Improve User Experience on Pianola</li> <li> Make DepthFlow's logic extensible and usable on ShaderFlow</li> </ul> <p>Eta: Q3 2024</p>"},{"location":"about/roadmap/#stage-2-more-features","title":"Stage 2: More Features","text":"<p>Get it Working, move fast and break things</p> <ul> <li> Internal rewrite and implementation of Imgui helpers for ShaderFlow</li> <li> (Re)writing all function docstrings for the Code Reference</li> <li> Rework ShaderFlow Shaders metaprogramming system</li> <li> Real Time playing on Pianola with MIDI Keyboards</li> <li> More \"fully featured\" Scenes than tech demos</li> <li> More Scientific Audio DSP of value magnitudes</li> <li> Configurable Hotkeys for ShaderFlow</li> </ul> <p>Eta: Q4 2024</p>"},{"location":"about/roadmap/#stage-3-get-it-right","title":"Stage 3: Get it Right","text":"Code Logistics Improvement and Stability <ul> <li> General code stability improvements</li> <li> Split projects into their own packages<sup>1</sup></li> <li> Write Test units for the code</li> <li> Simplify stuff, automate code</li> </ul> <p>Eta: Q1 2025++</p>"},{"location":"about/roadmap/#eventually-out-of-my-scope","title":"Eventually: Out of my Scope","text":"<p>What the future holds</p> <ul> <li> Logos for the projects</li> </ul> <p>Eta: 202X</p> <ol> <li> <p>Let Hatchling build system improve until then\u00a0\u21a9</p> </li> </ol>"},{"location":"about/sponsors/","title":"About/Sponsors","text":"<p>My deepest grattitude for all the amazing people who have made this possible</p> <ul> <li>It really does mean a lot to me being able to do what I love</li> </ul>"},{"location":"about/sponsors/#where-to-sponsor-me","title":"\u2705 Where to Sponsor me","text":"<ul> <li> <p> GitHub Sponsors</p> <p>Lowest fees, preferred method</p> <p> Support me \ud83d\ude80</p> </li> <li> <p> Patreon</p> <p>Discord tiers, occasional posts</p> <p> Support me \ud83d\udc8e</p> </li> </ul>"},{"location":"broken/reference/types/","title":"Types","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/types/#Types","title":"<code>Types</code>","text":""},{"location":"broken/reference/types/#Types.Unchanged","title":"<code>Types.Unchanged: TypeAlias = None</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.URL","title":"<code>Types.URL: TypeAlias = str</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Option","title":"<code>Types.Option = Union</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Range","title":"<code>Types.Range: TypeAlias = range</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Channels","title":"<code>Types.Channels: TypeAlias = int</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Seconds","title":"<code>Types.Seconds: TypeAlias = float</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Minutes","title":"<code>Types.Minutes: TypeAlias = float</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Hours","title":"<code>Types.Hours: TypeAlias = float</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Hertz","title":"<code>Types.Hertz: TypeAlias = float</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Samples","title":"<code>Types.Samples: TypeAlias = int</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Bytes","title":"<code>Types.Bytes: TypeAlias = int</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Degrees","title":"<code>Types.Degrees: TypeAlias = float</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Radians","title":"<code>Types.Radians: TypeAlias = float</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.BPM","title":"<code>Types.BPM: TypeAlias = float</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.Pixel","title":"<code>Types.Pixel: TypeAlias = int</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.TAU","title":"<code>Types.TAU = 2 * PI</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.SQRT2","title":"<code>Types.SQRT2 = 2 ** 0.5</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.SQRT3","title":"<code>Types.SQRT3 = 3 ** 0.5</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.SQRT_PI","title":"<code>Types.SQRT_PI = PI ** 0.5</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/types/#Types.FileExtensions","title":"<code>Types.FileExtensions</code>","text":"Source code in <code>Broken/Types.py</code> Python<pre><code>class FileExtensions:\n    Audio = {\".wav\", \".ogg\", \".flac\", \".mp3\"}\n    Image = {\".png\", \".jpg\", \".jpeg\", \".gif\", \".bmp\", \".tiff\", \".webp\"}\n    Video = {\".mp4\", \".mkv\", \".webm\", \".avi\", \".mov\", \".wmv\", \".flv\"}\n    Font  = {\".ttf\", \".otf\", \".woff\", \".woff2\"}\n    Midi  = {\".mid\", \".midi\"}\n    Soundfont = {\".sf2\", \".sf3\"}\n</code></pre>"},{"location":"broken/reference/types/#Types.FileExtensions.Audio","title":"<code>Audio = {'.wav', '.ogg', '.flac', '.mp3'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/types/#Types.FileExtensions.Image","title":"<code>Image = {'.png', '.jpg', '.jpeg', '.gif', '.bmp', '.tiff', '.webp'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/types/#Types.FileExtensions.Video","title":"<code>Video = {'.mp4', '.mkv', '.webm', '.avi', '.mov', '.wmv', '.flv'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/types/#Types.FileExtensions.Font","title":"<code>Font = {'.ttf', '.otf', '.woff', '.woff2'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/types/#Types.FileExtensions.Midi","title":"<code>Midi = {'.mid', '.midi'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/types/#Types.FileExtensions.Soundfont","title":"<code>Soundfont = {'.sf2', '.sf3'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/version/","title":"Version","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/version/#Version","title":"<code>Version</code>","text":""},{"location":"broken/reference/version/#Version.__version__","title":"<code>Version.__version__ = '0.5.0.dev0'</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/core/brokenenum/","title":"BrokenEnum","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum","title":"<code>Core.BrokenEnum</code>","text":""},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum","title":"<code>Core.BrokenEnum.BrokenEnum</code>","text":"Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>class BrokenEnum(enum.Enum):\n\n    # # Initialization\n\n    @classmethod\n    @functools.lru_cache()\n    def from_name(cls, name: str, *, lowercase: bool=True) -&gt; Optional[enum.Enum]:\n        \"\"\"\n        Get enum members from their name\n\n        Example:\n            ```python\n            class Fruits(BrokenEnum):\n                Apple  = \"Ma\u00e7\u00e3\"\n                Banana = \"Banana\"\n                Orange = \"Laranja\"\n\n            Fruits.from_name(\"Apple\") # Fruits.Apple\n            Fruits.from_name(\"apple\") # Fruits.Apple\n            ```\n\n        Args:\n            name: Name of the member to get\n            lowercase: Whether to lowercase the name and key before matching\n\n        Returns:\n            The enum member with the given name if found, None otherwise\n        \"\"\"\n        if not isinstance(name, str):\n            raise TypeError(f\"Expected str, got {type(name).__name__} on BrokenEnum.from_name()\")\n\n        # Optionally lowercase name for matching\n        name = name.lower() if lowercase else name\n\n        # Search for the member by key\n        for key, value in cls._member_map_.items():\n            if (key.lower() if lowercase else key) == name:\n                return value\n\n    @classmethod\n    @functools.lru_cache()\n    def from_value(cls, value: Any) -&gt; Optional[enum.Enum]:\n        \"\"\"\n        Get enum members from their value (name=value)\n\n        Example:\n            ```python\n            class Fruits(BrokenEnum):\n                Apple  = \"Ma\u00e7\u00e3\"\n                Banana = \"Banana\"\n                Orange = \"Laranja\"\n\n            Fruits.from_value(\"Ma\u00e7\u00e3\")   # Fruits.Apple\n            Fruits.from_value(\"Banana\") # Fruits.Banana\n            ```\n\n        Args:\n            value: Value of the member to get\n\n        Returns:\n            The enum member with the given value if found, None otherwise\n        \"\"\"\n        # Scroll through all members, match by value\n        for option in cls:\n            if value == option.value:\n                return option\n\n    # # Utilities properties\n\n    # Values\n\n    @classmethod\n    def members(cls) -&gt; Tuple[enum.Enum]:\n        \"\"\"\n        Get all members of the enum\n\n        Example:\n            ```python\n            class Fruits(BrokenEnum):\n                Apple  = \"Ma\u00e7\u00e3\"\n                Banana = \"Banana\"\n                Orange = \"Laranja\"\n\n            # (Fruits.Apple, Fruits.Banana, Fruits.Orange)\n            Fruits.members()\n            ```\n        \"\"\"\n        return tuple(cls)\n\n    @classmethod\n    def options(cls) -&gt; Tuple[enum.Enum]:\n        \"\"\"\n        Get all members of the enum\n\n        Example:\n            ```python\n            class Fruits(BrokenEnum):\n                Apple  = \"Ma\u00e7\u00e3\"\n                Banana = \"Banana\"\n                Orange = \"Laranja\"\n\n            # (Fruits.Apple, Fruits.Banana, Fruits.Orange)\n            Fruits.options()\n            ```\n        \"\"\"\n        return cls.members()\n\n    @classmethod\n    def values(cls) -&gt; Tuple[Any]:\n        \"\"\"\n        Get all values of the enum (name=value)\n\n        Example:\n            ```python\n            class Fruits(BrokenEnum):\n                Apple  = \"Ma\u00e7\u00e3\"\n                Banana = \"Banana\"\n                Orange = \"Laranja\"\n\n            # (\"Ma\u00e7\u00e3\", \"Banana\", \"Laranja\")\n            Fruits.values()\n            ```\n        \"\"\"\n        return tuple(member.value for member in cls)\n\n    # Key/names properties\n\n    @classmethod\n    def keys(cls) -&gt; Tuple[str]:\n        \"\"\"\n        Get all 'keys' of the enum (key=value)\n\n        Example:\n            ```python\n            class Fruits(BrokenEnum):\n                Apple  = \"Ma\u00e7\u00e3\"\n                Banana = \"Banana\"\n                Orange = \"Laranja\"\n\n            # (\"Apple\", \"Banana\", \"Orange\")\n            Fruits.keys()\n            ```\n        \"\"\"\n        return tuple(member.name for member in cls)\n\n    # Items and dict-like\n\n    @classmethod\n    def items(cls) -&gt; Tuple[Tuple[str, Any]]:\n        \"\"\"\n        Get the tuple of (name, value) of all members of the enum\n\n        Example:\n            ```python\n            class Fruits(BrokenEnum):\n                Apple  = \"Ma\u00e7\u00e3\"\n                Banana = \"Banana\"\n                Orange = \"Laranja\"\n\n            # ((\"Apple\", \"Ma\u00e7\u00e3\"), (\"Banana\", \"Banana\"), (\"Orange\", \"Laranja\"))\n            Fruits.items()\n            ```\n        \"\"\"\n        return tuple((member.name, member.value) for member in cls)\n\n    @classmethod\n    def as_dict(cls) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get the dictionary of key: value of all members of the enum\n\n        Example:\n            ```python\n            class Fruits(BrokenEnum):\n                Apple  = \"Ma\u00e7\u00e3\"\n                Banana = \"Banana\"\n                Orange = \"Laranja\"\n\n            # {\"Apple\": \"Ma\u00e7\u00e3\", \"Banana\": \"Banana\", \"Orange\": \"Laranja\"}\n            Fruits.as_dict()\n            ```\n        \"\"\"\n        return dict(cls.items())\n\n    def __getitem__(self, index: int) -&gt; enum.Enum:\n        return self.members[index]\n\n    @classmethod\n    def first(cls) -&gt; enum.Enum:\n        return cls.members()[0]\n\n    # # Smart methods\n\n    @classmethod\n    @functools.lru_cache()\n    def get(cls, value: Union[str, enum.Enum, Any], *, lowercase: bool=True) -&gt; Optional[Self]:\n        \"\"\"\n        Get enum members from their value, name or themselves\n\n        Example:\n            ```python\n            # Inherit from this package\n            class Multivalue(BrokenEnum):\n                Color  = \"blue\"\n                Hat    = False\n                Age    = 9000\n                Height = 1.41\n                Emoji  = \"\ud83d\udd31\"\n\n            # Use the .get method\n            Multivalue.get(\"blue\")   # Multivalue.Color\n            Multivalue.get(False)    # Multivalue.Hat\n            Multivalue.get(\"Height\") # Multivalue.Height\n            Multivalue.get(\"height\") # Multivalue.Height\n\n            # Use from a member itself\n            Multivalue.get(Multivalue.Color) # Multivalue.Color\n            ```\n\n        Args:\n            value: Value to get the enum member from, can be the member's name or value\n\n        Returns:\n            The enum member with the given value if found, None otherwise\n        \"\"\"\n\n        # Value is already a member of the enum\n        if isinstance(value, cls):\n            return value\n\n        # Value is a string\n        elif isinstance(value, str):\n            return cls.from_name(value, lowercase=lowercase) or cls.from_value(value)\n\n        # Search by value\n        return cls.from_value(value)\n\n    @functools.lru_cache()\n    def next(self, value: Union[str, enum.Enum]=None, offset: int=1) -&gt; Self:\n        \"\"\"\n        Get the next enum member (in position) from their value, name or themselves\n\n        Example:\n            ```python\n            # Inherit from this package\n            class Platform(BrokenEnum):\n                Linux   = \"linux\"\n                Windows = \"windows\"\n                MacOS   = \"macos\"\n\n            # Cycle through options\n            Platform.next(\"linux\")   # Platform.Windows\n            Platform.next(\"windows\") # Platform.MacOS\n            Platform.next(\"macos\")   # Platform.Linux\n            (...)\n            ```\n\n        Args:\n            value: Value to get the next enum member from, can be the Option's name or value\n\n        Returns:\n            The next enum member (in position) from the given value\n        \"\"\"\n        cls   = type(self)\n        value = cls.get(value or self)\n        return cls.options()[(cls.options().index(value) + offset) % len(cls)]\n\n    def __next__(self) -&gt; Self:\n        return self.next()\n\n    @functools.lru_cache()\n    def previous(self, value: Union[str, enum.Enum]=None, offset: int=1) -&gt; Self:\n        \"\"\"\n        Get the previous enum member (in position) from their value, name or themselves\n\n        Example:\n            ```python\n            # Inherit from this package\n            class Platform(BrokenEnum):\n                Linux   = \"linux\"\n                Windows = \"windows\"\n                MacOS   = \"macos\"\n\n            # Cycle through options\n            Platform.previous(\"linux\")   # Platform.MacOS\n            Platform.previous(\"windows\") # Platform.Linux\n            Platform.previous(\"macos\")   # Platform.Windows\n            (...)\n            ```\n\n        Args:\n            value: Value to get the previous enum member from, can be the Option's name or value\n\n        Returns:\n            The previous enum member (in position) from the given value\n        \"\"\"\n        cls   = type(self)\n        value = cls.get(value or self)\n        return cls.options()[(cls.options().index(value) - offset) % len(cls)]\n\n    # # Advanced functions\n\n    @classmethod\n    def extend(cls, name: str, value: Any) -&gt; Self:\n        \"\"\"\n        Dynamically extend the enum with a new member (name=value)\n\n        Example:\n            ```python\n            # Inherit from this package\n            class Platform(BrokenEnum):\n                ...\n\n            # Extend the enum\n            Platform.extend(\"Android\", \"android\")\n\n            # Use the new member\n            platform = Platform.Android\n            ```\n\n        Args:\n            name:  Name of the new member\n            value: Value of the new member\n\n        Returns:\n            Fluent interface, the class that was extended\n        \"\"\"\n        raise NotImplementedError(\"This method is not implemented yet\")\n\n    def field(self, **kwargs: Dict[str, Any]) -&gt; attrs.Attribute:\n        \"\"\"\n        Make a attrs.field() with this member as default and enum class's get method as converter\n\n        Example:\n            ```python\n            class Platform(BrokenEnum):\n                Linux   = \"linux\"\n                Windows = \"windows\"\n                MacOS   = \"macos\"\n\n            @define\n            class Computer:\n                os: Platform = Platform.Linux.field()\n\n            # Any setattr will be redirected to the enum's get method\n            computer = Computer()\n            computer.os = \"linux\" # Ok\n            computer.os = \"dne\"   # Not ok\n            ```\n\n        Args:\n            kwargs: Keyword arguments to pass to the field, may override default and converter\n        \"\"\"\n        return attrs.field(default=self, converter=self.__class__.get, **kwargs)\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.from_name","title":"<code>from_name(name: str, *, lowercase: bool = True) -&gt; Optional[enum.Enum]</code>  <code>cached</code> <code>classmethod</code>","text":"<p>Get enum members from their name</p> Example Python<pre><code>class Fruits(BrokenEnum):\n    Apple  = \"Ma\u00e7\u00e3\"\n    Banana = \"Banana\"\n    Orange = \"Laranja\"\n\nFruits.from_name(\"Apple\") # Fruits.Apple\nFruits.from_name(\"apple\") # Fruits.Apple\n</code></pre> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the member to get</p> </li> <li> <code>lowercase</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to lowercase the name and key before matching</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[enum.Enum]</code>         \u2013          <p>The enum member with the given name if found, None otherwise</p> </li> </ul> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\n@functools.lru_cache()\ndef from_name(cls, name: str, *, lowercase: bool=True) -&gt; Optional[enum.Enum]:\n    \"\"\"\n    Get enum members from their name\n\n    Example:\n        ```python\n        class Fruits(BrokenEnum):\n            Apple  = \"Ma\u00e7\u00e3\"\n            Banana = \"Banana\"\n            Orange = \"Laranja\"\n\n        Fruits.from_name(\"Apple\") # Fruits.Apple\n        Fruits.from_name(\"apple\") # Fruits.Apple\n        ```\n\n    Args:\n        name: Name of the member to get\n        lowercase: Whether to lowercase the name and key before matching\n\n    Returns:\n        The enum member with the given name if found, None otherwise\n    \"\"\"\n    if not isinstance(name, str):\n        raise TypeError(f\"Expected str, got {type(name).__name__} on BrokenEnum.from_name()\")\n\n    # Optionally lowercase name for matching\n    name = name.lower() if lowercase else name\n\n    # Search for the member by key\n    for key, value in cls._member_map_.items():\n        if (key.lower() if lowercase else key) == name:\n            return value\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.from_value","title":"<code>from_value(value: Any) -&gt; Optional[enum.Enum]</code>  <code>cached</code> <code>classmethod</code>","text":"<p>Get enum members from their value (name=value)</p> Example Python<pre><code>class Fruits(BrokenEnum):\n    Apple  = \"Ma\u00e7\u00e3\"\n    Banana = \"Banana\"\n    Orange = \"Laranja\"\n\nFruits.from_value(\"Ma\u00e7\u00e3\")   # Fruits.Apple\nFruits.from_value(\"Banana\") # Fruits.Banana\n</code></pre> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>Any</code>)         \u2013          <p>Value of the member to get</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[enum.Enum]</code>         \u2013          <p>The enum member with the given value if found, None otherwise</p> </li> </ul> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\n@functools.lru_cache()\ndef from_value(cls, value: Any) -&gt; Optional[enum.Enum]:\n    \"\"\"\n    Get enum members from their value (name=value)\n\n    Example:\n        ```python\n        class Fruits(BrokenEnum):\n            Apple  = \"Ma\u00e7\u00e3\"\n            Banana = \"Banana\"\n            Orange = \"Laranja\"\n\n        Fruits.from_value(\"Ma\u00e7\u00e3\")   # Fruits.Apple\n        Fruits.from_value(\"Banana\") # Fruits.Banana\n        ```\n\n    Args:\n        value: Value of the member to get\n\n    Returns:\n        The enum member with the given value if found, None otherwise\n    \"\"\"\n    # Scroll through all members, match by value\n    for option in cls:\n        if value == option.value:\n            return option\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.members","title":"<code>members() -&gt; Tuple[enum.Enum]</code>  <code>classmethod</code>","text":"<p>Get all members of the enum</p> Example Python<pre><code>class Fruits(BrokenEnum):\n    Apple  = \"Ma\u00e7\u00e3\"\n    Banana = \"Banana\"\n    Orange = \"Laranja\"\n\n# (Fruits.Apple, Fruits.Banana, Fruits.Orange)\nFruits.members()\n</code></pre> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\ndef members(cls) -&gt; Tuple[enum.Enum]:\n    \"\"\"\n    Get all members of the enum\n\n    Example:\n        ```python\n        class Fruits(BrokenEnum):\n            Apple  = \"Ma\u00e7\u00e3\"\n            Banana = \"Banana\"\n            Orange = \"Laranja\"\n\n        # (Fruits.Apple, Fruits.Banana, Fruits.Orange)\n        Fruits.members()\n        ```\n    \"\"\"\n    return tuple(cls)\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.options","title":"<code>options() -&gt; Tuple[enum.Enum]</code>  <code>classmethod</code>","text":"<p>Get all members of the enum</p> Example Python<pre><code>class Fruits(BrokenEnum):\n    Apple  = \"Ma\u00e7\u00e3\"\n    Banana = \"Banana\"\n    Orange = \"Laranja\"\n\n# (Fruits.Apple, Fruits.Banana, Fruits.Orange)\nFruits.options()\n</code></pre> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\ndef options(cls) -&gt; Tuple[enum.Enum]:\n    \"\"\"\n    Get all members of the enum\n\n    Example:\n        ```python\n        class Fruits(BrokenEnum):\n            Apple  = \"Ma\u00e7\u00e3\"\n            Banana = \"Banana\"\n            Orange = \"Laranja\"\n\n        # (Fruits.Apple, Fruits.Banana, Fruits.Orange)\n        Fruits.options()\n        ```\n    \"\"\"\n    return cls.members()\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.values","title":"<code>values() -&gt; Tuple[Any]</code>  <code>classmethod</code>","text":"<p>Get all values of the enum (name=value)</p> Example Python<pre><code>class Fruits(BrokenEnum):\n    Apple  = \"Ma\u00e7\u00e3\"\n    Banana = \"Banana\"\n    Orange = \"Laranja\"\n\n# (\"Ma\u00e7\u00e3\", \"Banana\", \"Laranja\")\nFruits.values()\n</code></pre> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\ndef values(cls) -&gt; Tuple[Any]:\n    \"\"\"\n    Get all values of the enum (name=value)\n\n    Example:\n        ```python\n        class Fruits(BrokenEnum):\n            Apple  = \"Ma\u00e7\u00e3\"\n            Banana = \"Banana\"\n            Orange = \"Laranja\"\n\n        # (\"Ma\u00e7\u00e3\", \"Banana\", \"Laranja\")\n        Fruits.values()\n        ```\n    \"\"\"\n    return tuple(member.value for member in cls)\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.keys","title":"<code>keys() -&gt; Tuple[str]</code>  <code>classmethod</code>","text":"<p>Get all 'keys' of the enum (key=value)</p> Example Python<pre><code>class Fruits(BrokenEnum):\n    Apple  = \"Ma\u00e7\u00e3\"\n    Banana = \"Banana\"\n    Orange = \"Laranja\"\n\n# (\"Apple\", \"Banana\", \"Orange\")\nFruits.keys()\n</code></pre> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\ndef keys(cls) -&gt; Tuple[str]:\n    \"\"\"\n    Get all 'keys' of the enum (key=value)\n\n    Example:\n        ```python\n        class Fruits(BrokenEnum):\n            Apple  = \"Ma\u00e7\u00e3\"\n            Banana = \"Banana\"\n            Orange = \"Laranja\"\n\n        # (\"Apple\", \"Banana\", \"Orange\")\n        Fruits.keys()\n        ```\n    \"\"\"\n    return tuple(member.name for member in cls)\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.items","title":"<code>items() -&gt; Tuple[Tuple[str, Any]]</code>  <code>classmethod</code>","text":"<p>Get the tuple of (name, value) of all members of the enum</p> Example Python<pre><code>class Fruits(BrokenEnum):\n    Apple  = \"Ma\u00e7\u00e3\"\n    Banana = \"Banana\"\n    Orange = \"Laranja\"\n\n# ((\"Apple\", \"Ma\u00e7\u00e3\"), (\"Banana\", \"Banana\"), (\"Orange\", \"Laranja\"))\nFruits.items()\n</code></pre> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\ndef items(cls) -&gt; Tuple[Tuple[str, Any]]:\n    \"\"\"\n    Get the tuple of (name, value) of all members of the enum\n\n    Example:\n        ```python\n        class Fruits(BrokenEnum):\n            Apple  = \"Ma\u00e7\u00e3\"\n            Banana = \"Banana\"\n            Orange = \"Laranja\"\n\n        # ((\"Apple\", \"Ma\u00e7\u00e3\"), (\"Banana\", \"Banana\"), (\"Orange\", \"Laranja\"))\n        Fruits.items()\n        ```\n    \"\"\"\n    return tuple((member.name, member.value) for member in cls)\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.as_dict","title":"<code>as_dict() -&gt; Dict[str, Any]</code>  <code>classmethod</code>","text":"<p>Get the dictionary of key: value of all members of the enum</p> Example Python<pre><code>class Fruits(BrokenEnum):\n    Apple  = \"Ma\u00e7\u00e3\"\n    Banana = \"Banana\"\n    Orange = \"Laranja\"\n\n# {\"Apple\": \"Ma\u00e7\u00e3\", \"Banana\": \"Banana\", \"Orange\": \"Laranja\"}\nFruits.as_dict()\n</code></pre> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\ndef as_dict(cls) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the dictionary of key: value of all members of the enum\n\n    Example:\n        ```python\n        class Fruits(BrokenEnum):\n            Apple  = \"Ma\u00e7\u00e3\"\n            Banana = \"Banana\"\n            Orange = \"Laranja\"\n\n        # {\"Apple\": \"Ma\u00e7\u00e3\", \"Banana\": \"Banana\", \"Orange\": \"Laranja\"}\n        Fruits.as_dict()\n        ```\n    \"\"\"\n    return dict(cls.items())\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.__getitem__","title":"<code>__getitem__(index: int) -&gt; enum.Enum</code>","text":"Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>def __getitem__(self, index: int) -&gt; enum.Enum:\n    return self.members[index]\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.first","title":"<code>first() -&gt; enum.Enum</code>  <code>classmethod</code>","text":"Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\ndef first(cls) -&gt; enum.Enum:\n    return cls.members()[0]\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.get","title":"<code>get(value: Union[str, enum.Enum, Any], *, lowercase: bool = True) -&gt; Optional[Self]</code>  <code>cached</code> <code>classmethod</code>","text":"<p>Get enum members from their value, name or themselves</p> Example Python<pre><code># Inherit from this package\nclass Multivalue(BrokenEnum):\n    Color  = \"blue\"\n    Hat    = False\n    Age    = 9000\n    Height = 1.41\n    Emoji  = \"\ud83d\udd31\"\n\n# Use the .get method\nMultivalue.get(\"blue\")   # Multivalue.Color\nMultivalue.get(False)    # Multivalue.Hat\nMultivalue.get(\"Height\") # Multivalue.Height\nMultivalue.get(\"height\") # Multivalue.Height\n\n# Use from a member itself\nMultivalue.get(Multivalue.Color) # Multivalue.Color\n</code></pre> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>Union[str, enum.Enum, Any]</code>)         \u2013          <p>Value to get the enum member from, can be the member's name or value</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Self]</code>         \u2013          <p>The enum member with the given value if found, None otherwise</p> </li> </ul> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\n@functools.lru_cache()\ndef get(cls, value: Union[str, enum.Enum, Any], *, lowercase: bool=True) -&gt; Optional[Self]:\n    \"\"\"\n    Get enum members from their value, name or themselves\n\n    Example:\n        ```python\n        # Inherit from this package\n        class Multivalue(BrokenEnum):\n            Color  = \"blue\"\n            Hat    = False\n            Age    = 9000\n            Height = 1.41\n            Emoji  = \"\ud83d\udd31\"\n\n        # Use the .get method\n        Multivalue.get(\"blue\")   # Multivalue.Color\n        Multivalue.get(False)    # Multivalue.Hat\n        Multivalue.get(\"Height\") # Multivalue.Height\n        Multivalue.get(\"height\") # Multivalue.Height\n\n        # Use from a member itself\n        Multivalue.get(Multivalue.Color) # Multivalue.Color\n        ```\n\n    Args:\n        value: Value to get the enum member from, can be the member's name or value\n\n    Returns:\n        The enum member with the given value if found, None otherwise\n    \"\"\"\n\n    # Value is already a member of the enum\n    if isinstance(value, cls):\n        return value\n\n    # Value is a string\n    elif isinstance(value, str):\n        return cls.from_name(value, lowercase=lowercase) or cls.from_value(value)\n\n    # Search by value\n    return cls.from_value(value)\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.next","title":"<code>next(value: Union[str, enum.Enum] = None, offset: int = 1) -&gt; Self</code>  <code>cached</code>","text":"<p>Get the next enum member (in position) from their value, name or themselves</p> Example Python<pre><code># Inherit from this package\nclass Platform(BrokenEnum):\n    Linux   = \"linux\"\n    Windows = \"windows\"\n    MacOS   = \"macos\"\n\n# Cycle through options\nPlatform.next(\"linux\")   # Platform.Windows\nPlatform.next(\"windows\") # Platform.MacOS\nPlatform.next(\"macos\")   # Platform.Linux\n(...)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>Union[str, enum.Enum]</code>, default:                 <code>None</code> )         \u2013          <p>Value to get the next enum member from, can be the Option's name or value</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>The next enum member (in position) from the given value</p> </li> </ul> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@functools.lru_cache()\ndef next(self, value: Union[str, enum.Enum]=None, offset: int=1) -&gt; Self:\n    \"\"\"\n    Get the next enum member (in position) from their value, name or themselves\n\n    Example:\n        ```python\n        # Inherit from this package\n        class Platform(BrokenEnum):\n            Linux   = \"linux\"\n            Windows = \"windows\"\n            MacOS   = \"macos\"\n\n        # Cycle through options\n        Platform.next(\"linux\")   # Platform.Windows\n        Platform.next(\"windows\") # Platform.MacOS\n        Platform.next(\"macos\")   # Platform.Linux\n        (...)\n        ```\n\n    Args:\n        value: Value to get the next enum member from, can be the Option's name or value\n\n    Returns:\n        The next enum member (in position) from the given value\n    \"\"\"\n    cls   = type(self)\n    value = cls.get(value or self)\n    return cls.options()[(cls.options().index(value) + offset) % len(cls)]\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.__next__","title":"<code>__next__() -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>def __next__(self) -&gt; Self:\n    return self.next()\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.previous","title":"<code>previous(value: Union[str, enum.Enum] = None, offset: int = 1) -&gt; Self</code>  <code>cached</code>","text":"<p>Get the previous enum member (in position) from their value, name or themselves</p> Example Python<pre><code># Inherit from this package\nclass Platform(BrokenEnum):\n    Linux   = \"linux\"\n    Windows = \"windows\"\n    MacOS   = \"macos\"\n\n# Cycle through options\nPlatform.previous(\"linux\")   # Platform.MacOS\nPlatform.previous(\"windows\") # Platform.Linux\nPlatform.previous(\"macos\")   # Platform.Windows\n(...)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>value</code>             (<code>Union[str, enum.Enum]</code>, default:                 <code>None</code> )         \u2013          <p>Value to get the previous enum member from, can be the Option's name or value</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>The previous enum member (in position) from the given value</p> </li> </ul> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@functools.lru_cache()\ndef previous(self, value: Union[str, enum.Enum]=None, offset: int=1) -&gt; Self:\n    \"\"\"\n    Get the previous enum member (in position) from their value, name or themselves\n\n    Example:\n        ```python\n        # Inherit from this package\n        class Platform(BrokenEnum):\n            Linux   = \"linux\"\n            Windows = \"windows\"\n            MacOS   = \"macos\"\n\n        # Cycle through options\n        Platform.previous(\"linux\")   # Platform.MacOS\n        Platform.previous(\"windows\") # Platform.Linux\n        Platform.previous(\"macos\")   # Platform.Windows\n        (...)\n        ```\n\n    Args:\n        value: Value to get the previous enum member from, can be the Option's name or value\n\n    Returns:\n        The previous enum member (in position) from the given value\n    \"\"\"\n    cls   = type(self)\n    value = cls.get(value or self)\n    return cls.options()[(cls.options().index(value) - offset) % len(cls)]\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.extend","title":"<code>extend(name: str, value: Any) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Dynamically extend the enum with a new member (name=value)</p> Example Python<pre><code># Inherit from this package\nclass Platform(BrokenEnum):\n    ...\n\n# Extend the enum\nPlatform.extend(\"Android\", \"android\")\n\n# Use the new member\nplatform = Platform.Android\n</code></pre> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>)         \u2013          <p>Name of the new member</p> </li> <li> <code>value</code>             (<code>Any</code>)         \u2013          <p>Value of the new member</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Fluent interface, the class that was extended</p> </li> </ul> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>@classmethod\ndef extend(cls, name: str, value: Any) -&gt; Self:\n    \"\"\"\n    Dynamically extend the enum with a new member (name=value)\n\n    Example:\n        ```python\n        # Inherit from this package\n        class Platform(BrokenEnum):\n            ...\n\n        # Extend the enum\n        Platform.extend(\"Android\", \"android\")\n\n        # Use the new member\n        platform = Platform.Android\n        ```\n\n    Args:\n        name:  Name of the new member\n        value: Value of the new member\n\n    Returns:\n        Fluent interface, the class that was extended\n    \"\"\"\n    raise NotImplementedError(\"This method is not implemented yet\")\n</code></pre>"},{"location":"broken/reference/core/brokenenum/#Core.BrokenEnum.BrokenEnum.field","title":"<code>field(**kwargs: Dict[str, Any]) -&gt; attrs.Attribute</code>","text":"<p>Make a attrs.field() with this member as default and enum class's get method as converter</p> Example Python<pre><code>class Platform(BrokenEnum):\n    Linux   = \"linux\"\n    Windows = \"windows\"\n    MacOS   = \"macos\"\n\n@define\nclass Computer:\n    os: Platform = Platform.Linux.field()\n\n# Any setattr will be redirected to the enum's get method\ncomputer = Computer()\ncomputer.os = \"linux\" # Ok\ncomputer.os = \"dne\"   # Not ok\n</code></pre> <p>Parameters:</p> <ul> <li> <code>kwargs</code>             (<code>Dict[str, Any]</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword arguments to pass to the field, may override default and converter</p> </li> </ul> Source code in <code>Broken/Core/BrokenEnum.py</code> Python<pre><code>def field(self, **kwargs: Dict[str, Any]) -&gt; attrs.Attribute:\n    \"\"\"\n    Make a attrs.field() with this member as default and enum class's get method as converter\n\n    Example:\n        ```python\n        class Platform(BrokenEnum):\n            Linux   = \"linux\"\n            Windows = \"windows\"\n            MacOS   = \"macos\"\n\n        @define\n        class Computer:\n            os: Platform = Platform.Linux.field()\n\n        # Any setattr will be redirected to the enum's get method\n        computer = Computer()\n        computer.os = \"linux\" # Ok\n        computer.os = \"dne\"   # Not ok\n        ```\n\n    Args:\n        kwargs: Keyword arguments to pass to the field, may override default and converter\n    \"\"\"\n    return attrs.field(default=self, converter=self.__class__.get, **kwargs)\n</code></pre>"},{"location":"broken/reference/core/brokenlogging/","title":"BrokenLogging","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging","title":"<code>Core.BrokenLogging</code>","text":""},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging.console","title":"<code>Core.BrokenLogging.console = rich.get_console()</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging.BrokenLogging","title":"<code>Core.BrokenLogging.BrokenLogging</code>","text":"Source code in <code>Broken/Core/BrokenLogging.py</code> Python<pre><code>class BrokenLogging:\n    LOG_START = time.perf_counter()\n\n    def __new__(cls) -&gt; Self:\n        if not hasattr(cls, \"_singleton\"):\n            cls._singleton = super().__new__(cls)\n        return cls._singleton\n\n    @staticmethod\n    def project() -&gt; str:\n        return os.getenv(\"BROKEN_APP_NAME\", \"Broken\")\n\n    @staticmethod\n    def set_project(name: str, *, force: bool=False) -&gt; None:\n        if (BrokenLogging.project() == \"Broken\") or force:\n            os.environ[\"BROKEN_APP_NAME\"] = name\n\n    def broken_format(self, data) -&gt; str:\n        when = (time.perf_counter() - BrokenLogging.LOG_START)\n        data[\"when\"] = f\"{int(when//60)}'{when%60:06.3f}\"\n        return (\n            f\"\\r\u2502[dodger_blue3]{self.project()}[/dodger_blue3]\u251c\"\n            \"\u2524[green]{when}[/green]\u251c\"\n            \"\u2524[{level.icon}]{level:7}[/{level.icon}]\"\n            \"\u2502 \u25b8 {message}\"\n        ).format(**data)\n\n    def __init__(self) -&gt; None:\n        log.remove()\n        log.add(\n            rich.print,\n            format=self.broken_format,\n            level=os.getenv(\"LOGLEVEL\", \"INFO\").upper(),\n            colorize=False,\n            backtrace=True,\n            diagnose=True,\n            catch=True,\n        )\n        self.level(\"TRACE\", None, \"dark_turquoise\")\n        self.level(\"DEBUG\", None, \"turquoise4\")\n        self.level(\"INFO\", None, \"bright_white\")\n        self.level(\"NOTE\", 25, \"bright_blue\")\n        self.level(\"TIP\", 25, \"dark_cyan\")\n        self.level(\"SUCCESS\", None, \"green\")\n        self.level(\"MINOR\", 25, \"grey42\")\n        self.level(\"SKIP\", 25, \"grey42\")\n        self.level(\"FIXME\", 25, \"cyan\")\n        self.level(\"TODO\", 25, \"dark_blue\")\n        self.level(\"WARNING\", None, \"yellow\")\n        self.level(\"ERROR\", None, \"red\")\n        self.level(\"CRITICAL\", None, \"red\")\n\n    def level(self, level: str, loglevel: int=0, color: str=None) -&gt; None:\n        \"\"\"Create or update a loglevel `.{name.lower()}` on the logger, optional 'echo' argument\"\"\"\n        def wraps_log(*args, echo=True) -&gt; str:\n            message = \" \".join(map(str, args))\n            if not echo:\n                return message\n            for line in message.splitlines():\n                log.log(level, line)\n            return message\n\n        # Assign log function to logger. Workaround to set icon=color\n        log.level(level, loglevel, icon=color)\n        setattr(log, level.lower(), wraps_log)\n</code></pre>"},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging.BrokenLogging.LOG_START","title":"<code>LOG_START = time.perf_counter()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging.BrokenLogging.__new__","title":"<code>__new__() -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenLogging.py</code> Python<pre><code>def __new__(cls) -&gt; Self:\n    if not hasattr(cls, \"_singleton\"):\n        cls._singleton = super().__new__(cls)\n    return cls._singleton\n</code></pre>"},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging.BrokenLogging.project","title":"<code>project() -&gt; str</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/BrokenLogging.py</code> Python<pre><code>@staticmethod\ndef project() -&gt; str:\n    return os.getenv(\"BROKEN_APP_NAME\", \"Broken\")\n</code></pre>"},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging.BrokenLogging.set_project","title":"<code>set_project(name: str, *, force: bool = False) -&gt; None</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/BrokenLogging.py</code> Python<pre><code>@staticmethod\ndef set_project(name: str, *, force: bool=False) -&gt; None:\n    if (BrokenLogging.project() == \"Broken\") or force:\n        os.environ[\"BROKEN_APP_NAME\"] = name\n</code></pre>"},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging.BrokenLogging.broken_format","title":"<code>broken_format(data) -&gt; str</code>","text":"Source code in <code>Broken/Core/BrokenLogging.py</code> Python<pre><code>def broken_format(self, data) -&gt; str:\n    when = (time.perf_counter() - BrokenLogging.LOG_START)\n    data[\"when\"] = f\"{int(when//60)}'{when%60:06.3f}\"\n    return (\n        f\"\\r\u2502[dodger_blue3]{self.project()}[/dodger_blue3]\u251c\"\n        \"\u2524[green]{when}[/green]\u251c\"\n        \"\u2524[{level.icon}]{level:7}[/{level.icon}]\"\n        \"\u2502 \u25b8 {message}\"\n    ).format(**data)\n</code></pre>"},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging.BrokenLogging.__init__","title":"<code>__init__() -&gt; None</code>","text":"Source code in <code>Broken/Core/BrokenLogging.py</code> Python<pre><code>def __init__(self) -&gt; None:\n    log.remove()\n    log.add(\n        rich.print,\n        format=self.broken_format,\n        level=os.getenv(\"LOGLEVEL\", \"INFO\").upper(),\n        colorize=False,\n        backtrace=True,\n        diagnose=True,\n        catch=True,\n    )\n    self.level(\"TRACE\", None, \"dark_turquoise\")\n    self.level(\"DEBUG\", None, \"turquoise4\")\n    self.level(\"INFO\", None, \"bright_white\")\n    self.level(\"NOTE\", 25, \"bright_blue\")\n    self.level(\"TIP\", 25, \"dark_cyan\")\n    self.level(\"SUCCESS\", None, \"green\")\n    self.level(\"MINOR\", 25, \"grey42\")\n    self.level(\"SKIP\", 25, \"grey42\")\n    self.level(\"FIXME\", 25, \"cyan\")\n    self.level(\"TODO\", 25, \"dark_blue\")\n    self.level(\"WARNING\", None, \"yellow\")\n    self.level(\"ERROR\", None, \"red\")\n    self.level(\"CRITICAL\", None, \"red\")\n</code></pre>"},{"location":"broken/reference/core/brokenlogging/#Core.BrokenLogging.BrokenLogging.level","title":"<code>level(level: str, loglevel: int = 0, color: str = None) -&gt; None</code>","text":"<p>Create or update a loglevel <code>.{name.lower()}</code> on the logger, optional 'echo' argument</p> Source code in <code>Broken/Core/BrokenLogging.py</code> Python<pre><code>def level(self, level: str, loglevel: int=0, color: str=None) -&gt; None:\n    \"\"\"Create or update a loglevel `.{name.lower()}` on the logger, optional 'echo' argument\"\"\"\n    def wraps_log(*args, echo=True) -&gt; str:\n        message = \" \".join(map(str, args))\n        if not echo:\n            return message\n        for line in message.splitlines():\n            log.log(level, line)\n        return message\n\n    # Assign log function to logger. Workaround to set icon=color\n    log.level(level, loglevel, icon=color)\n    setattr(log, level.lower(), wraps_log)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/","title":"BrokenPath","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath","title":"<code>Core.BrokenPath</code>","text":""},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.ShutilFormat","title":"<code>Core.BrokenPath.ShutilFormat</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>class ShutilFormat(BrokenEnum):\n    Zip   = \"zip\"\n    Tar   = \"tar\"\n    TarGz = \"tar.gz\"\n    TarBz = \"tar.bz2\"\n    TarXz = \"tar.xz\"\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.ShutilFormat.Zip","title":"<code>Zip = 'zip'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.ShutilFormat.Tar","title":"<code>Tar = 'tar'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.ShutilFormat.TarGz","title":"<code>TarGz = 'tar.gz'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.ShutilFormat.TarBz","title":"<code>TarBz = 'tar.bz2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.ShutilFormat.TarXz","title":"<code>TarXz = 'tar.xz'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath","title":"<code>Core.BrokenPath.BrokenPath</code>","text":"<p>Extended pathlib.Path with utilities, absolute paths always, accepts None</p> <ul> <li> <p>Clever mechanism: Functions aren't staticmethods but still can be called from the outside,     they just imply self eg. Both BrokenPath(\"/tmp\").valid() or BrokenPath.valid(\"/tmp\") works</p> </li> <li> <p>Convenience: Can use BrokenPath(None), BrokenPath(\"/ok\", None, \"file.mp4\") -&gt; \"/ok/file.mp4\"</p> </li> </ul> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>class BrokenPath(pathlib.Path):\n    \"\"\"\n    Extended pathlib.Path with utilities, absolute paths always, accepts None\n\n    - Clever mechanism: Functions aren't staticmethods but still can be called from the outside,\n        they just imply self eg. Both BrokenPath(\"/tmp\").valid() or BrokenPath.valid(\"/tmp\") works\n\n    - Convenience: Can use BrokenPath(None), BrokenPath(\"/ok\", None, \"file.mp4\") -&gt; \"/ok/file.mp4\"\n    \"\"\"\n    _flavour = type(pathlib.Path())._flavour\n\n    def __new__(cls, *args, valid: bool=False, **kwargs):\n\n        # Return None if all args are falsy\n        if not (args := list(filter(None, args))):\n            return None\n\n        # Use absolute expanded user always. Note that we do not want\n        # to .resolve() as having symlink paths _can_ be wanted\n        instance = super().__new__(cls, *args, **kwargs)\n        instance._raw_paths = list(map(str, args)) # Py312 fix\n        instance = instance.expanduser().absolute()\n        if (valid and not instance.exists()):\n            return None\n        return instance\n\n    def pathlib(self) -&gt; pathlib.Path:\n        \"\"\"Some packages test `type(var) == pathlib.Path` instead of `isinstance(var, pathlib.Path)`\"\"\"\n        return pathlib.Path(self)\n\n    def str(self) -&gt; str:\n        return str(self)\n\n    def valid(path: Optional[BrokenPath]) -&gt; Optional[BrokenPath]:\n        \"\"\"Returns the BrokenPath if it exists, else None\"\"\"\n        return BrokenPath(path, valid=True)\n\n    def copy(src: Path, dst: Path, *, echo=True) -&gt; Path:\n        src, dst = BrokenPath(src), BrokenPath(dst)\n        BrokenPath.mkdirs(dst.parent, echo=False)\n        if src.is_dir():\n            log.info(f\"Copying Directory ({src})\\n \u2192 ({dst})\", echo=echo)\n            shutil.copytree(src, dst)\n        else:\n            log.info(f\"Copying File ({src})\\n \u2192 ({dst})\", echo=echo)\n            shutil.copy2(src, dst)\n        return dst\n\n    def move(src: Path, dst: Path, *, echo=True) -&gt; Path:\n        src, dst = BrokenPath(src), BrokenPath(dst)\n        log.info(f\"Moving ({src})\\n \u2192 ({dst})\", echo=echo)\n        shutil.move(src, dst)\n        return dst\n\n    def remove(path: Path, *, confirm=False, echo=True) -&gt; Path:\n\n        # Already removed or doesn't exist\n        if not (path := BrokenPath(path).valid()):\n            return path\n\n        log.info(f\"Removing Path ({path})\", echo=echo)\n\n        # Safety: Must not be common\n        if path in (Path.cwd(), Path.home()):\n            log.error(f\"Avoided catastrophic failure by not removing ({path})\")\n            exit(1)\n\n        # Symlinks are safe to remove\n        if path.is_symlink():\n            path.unlink()\n            return path\n\n        # Confirm removal: directory contains data\n        if confirm and (not click.confirm(f\"\u2022 Confirm removing path ({path})\")):\n            return path\n\n        # Remove the path\n        if path.is_dir():\n            shutil.rmtree(path, ignore_errors=True)\n        else:\n            path.unlink()\n\n        return path\n\n    def mkdirs(path: Path, parent: bool=False, *, echo=True) -&gt; Path:\n        \"\"\"Creates a directory and its parents, fail safe\u2122\"\"\"\n        path = BrokenPath(path)\n        path = path.parent if parent else path\n        if path.exists():\n            log.success(f\"Directory ({path}) already exists\", echo=echo)\n            return path\n        log.info(f\"Creating directory {path}\", echo=echo)\n        path.mkdir(parents=True, exist_ok=True)\n        return path\n\n    def resetdir(path: Path, *, echo=True) -&gt; Path:\n        \"\"\"Delete and re-create a directory\"\"\"\n        return BrokenPath.mkdirs(BrokenPath.remove(path, echo=echo), echo=echo)\n\n    @contextlib.contextmanager\n    def pushd(path: Path, *, echo: bool=True) -&gt; Generator[Path, None, None]:\n        \"\"\"Change directory, then change back when done\"\"\"\n        path = BrokenPath(path)\n        cwd = os.getcwd()\n        log.info(f\"Pushd ({path})\", echo=echo)\n        os.chdir(path)\n        yield path\n        log.info(f\"Popd  ({path})\", echo=echo)\n        os.chdir(cwd)\n\n    def symlink(virtual: Path, real: Path, *, echo: bool=True) -&gt; Path:\n        \"\"\"\n        Symlink [virtual] -&gt; [real], `virtual` being the symlink file and `real` the target\n\n        Args:\n            virtual (Path): Symlink path (file)\n            real (Path): Target path (real path)\n\n        Returns:\n            None if it fails, else `virtual` Path\n        \"\"\"\n        log.info(f\"Symlinking ({virtual})\\n \u2192 ({real})\", echo=echo)\n\n        # Return if already symlinked\n        if (BrokenPath(virtual) == BrokenPath(real)):\n            return virtual\n\n        # Make Virtual's parent directory\n        BrokenPath.mkdirs(virtual.parent, echo=False)\n\n        # Remove old symlink if it points to a non existing directory\n        if virtual.is_symlink() and (not virtual.resolve().exists()):\n            virtual.unlink()\n\n        # Virtual doesn't exist, ok to create\n        elif not virtual.exists():\n            pass\n\n        # File exists and is a symlink - safe to remove\n        elif virtual.is_symlink():\n            virtual.unlink()\n\n        # Virtual is a directory and not empty\n        elif virtual.is_dir() and (not os.listdir(virtual)):\n            BrokenPath.remove(virtual, echo=False)\n\n        else:\n            if click.confirm('\\n'.join((\n                f\"Path ({virtual}) exists, but Broken wants to create a symlink to ({real})\",\n                \"\u2022 Confirm removing the 'virtual' path and continuing? (It might contain data or be a important symlink)\"\n            ))):\n                BrokenPath.remove(virtual, echo=False)\n            else:\n                return\n\n        try:\n            virtual.symlink_to(real)\n        except Exception as error:\n            if BrokenPlatform.OnWindows:\n                log.minor(\"Failed to create Symlink. Consider enabling 'Developer Mode' on Windows (https://rye.astral.sh/guide/faq/#windows-developer-mode)\")\n            else:\n                raise error\n\n        return virtual\n\n    def make_executable(path: Path, *, echo=False) -&gt; Path:\n        \"\"\"Make a file executable\"\"\"\n        if BrokenPlatform.OnUnix:\n            shell(\"chmod\", \"+x\", path, echo=echo)\n        elif BrokenPlatform.OnWindows:\n            shell(\"attrib\", \"+x\", path, echo=echo)\n        return path\n\n    def zip(path: Path, output: Path=None, *, format: ShutilFormat=ShutilFormat.Zip, echo: bool=True) -&gt; Path:\n        format = ShutilFormat.get(format)\n        output = BrokenPath(output or path).with_suffix(f\".{format}\")\n        path   = BrokenPath(path)\n        log.info(f\"Zipping ({path})\\n \u2192 ({output})\", echo=echo)\n        BrokenPath.remove(output, echo=echo)\n        shutil.make_archive(output.with_suffix(\"\"), format, path)\n        return output\n\n    def merge_zips(*zips: List[Path], output: Path, echo: bool=True) -&gt; Path:\n        \"\"\"Merge multiple ZIP files into a single one\"\"\"\n        import zipfile\n        with zipfile.ZipFile(output, \"w\") as archive:\n            for path in flatten(zips):\n                with zipfile.ZipFile(path, \"r\") as other:\n                    for file in other.filelist:\n                        archive.writestr(file, other.read(file))\n        return output\n\n    def stem(path: Path) -&gt; str:\n        \"\"\"\n        Get the \"true stem\" of a path, as pathlib's only gets the last dot one\n        \u2022 \"/path/with/many.ext.ens.ions\" -&gt; \"many\" instead of \"many.ext.ens\"\n        \"\"\"\n        stem = Path(Path(path).stem)\n        while (stem := Path(stem).with_suffix(\"\")).suffix:\n            continue\n        return str(stem)\n\n    def sha256sum(data: Union[Path, str, bytes]) -&gt; Optional[str]:\n        \"\"\"Get the sha256sum of a file, directory or bytes\"\"\"\n\n        # Nibble the bytes !\n        if isinstance(data, bytes):\n            return hashlib.sha256(data).hexdigest()\n\n        # String or Path is a valid path\n        elif (path := BrokenPath(data).valid()):\n            with BrokenSpinner(log.info(f\"Calculating sha256sum of ({path})\")):\n                if path.is_file():\n                    return hashlib.sha256(path.read_bytes()).hexdigest()\n\n                # Iterate on all files for low memory footprint\n                feed = hashlib.sha256()\n                for file in path.rglob(\"*\"):\n                    if not file.is_file():\n                        continue\n                    with open(file, \"rb\") as file:\n                        while (chunk := file.read(8192)):\n                            feed.update(chunk)\n                return feed.hexdigest()\n\n        elif isinstance(data, str):\n            return hashlib.sha256(data.encode(\"utf-8\")).hexdigest()\n\n        return\n\n    def extract(\n        path: Path,\n        output: Path=None,\n        *,\n        overwrite: bool=False,\n        echo: bool=True\n    ) -&gt; Path:\n        path, output = BrokenPath(path), BrokenPath(output)\n\n        # Extract to the same directory by default\n        if (output is None):\n            output = path.parent\n\n        # Add stem to the output as some archives might be flat\n        output /= BrokenPath.stem(path)\n\n        # Re-extract on order\n        if overwrite:\n            BrokenPath.remove(output)\n\n        # A file to skip if it exists, created after successful extraction\n        if (extract_flag := (output/\"BrokenPath.extract.ok\")).exists():\n            log.minor(f\"Already extracted ({output})\", echo=echo)\n        else:\n            # Show progress as this might take a while on slower IOs\n            log.info(f\"Extracting ({path})\\n \u2192 ({output})\", echo=echo)\n            with BrokenSpinner(\"Extracting archive..\"):\n                shutil.unpack_archive(path, output)\n            extract_flag.touch()\n\n        return output\n\n    def url_filename(url: str) -&gt; Path:\n        return Path(url.split(\"#\")[0].split(\"?\")[0].split(\"/\")[-1])\n\n    def download(\n        url: str,\n        output: Path=None,\n        *,\n        size_check: bool=True,\n        chunk: int=1024,\n        echo: bool=True\n    ) -&gt; Optional[Path]:\n        \"\"\"\n        Note: If the output is a directory, the url's file name will be appended to it\n        Note: The output will default to Broken Project's Download directory\n        \"\"\"\n\n        # Link must be valid\n        if not validators.url(url):\n            import click\n            if not click.confirm(log.error(f\"The following string doesn't look like a valid download URL on validator's eyes\\n\u2022 ({url})\\nContinue normally?\")):\n                return None\n\n        # Default to Broken's Download directory\n        if (output is None):\n            output = Broken.BROKEN.DIRECTORIES.DOWNLOADS\n\n        # Append url's file name to the output path\n        if (output := BrokenPath(output)).is_dir():\n            output /= BrokenPath.url_filename(url)\n\n        log.info(f\"Downloading\\n\u2022 URL:  ({url})\\n\u2022 Path: ({output})\", echo=echo)\n\n        # Without size check, the existence of the file is enough\n        if (not size_check) and output.exists():\n            log.minor(\"\u2022 File exists and Size check was skipped\", echo=echo)\n            return None\n\n        try:\n            import requests\n            response = requests.get(url, stream=True, headers={\"Accept-Encoding\": None})\n        except requests.exceptions.RequestException as error:\n            log.error(f\"\u2022 Failed to download: {error}\", echo=echo)\n            # Note: Return output as it might be downloaded but we're without internet\n            return output\n\n        # Note: The length header is not always present, if that, just check for existence\n        if not (expected_size := int(response.headers.get('content-length', 0))):\n            log.minor(\"The Download doesn't advertise a size, just checking for existence\", echo=echo)\n            if output.exists():\n                return output\n\n        # The file might already be (partially) downloaded\n        if (expected_size and size_check) and output.exists():\n            if (output.stat().st_size == expected_size):\n                return output\n            if (len(output.read_bytes()) == expected_size):\n                return output\n            log.warning(\"\u2022 Wrong Download size\", echo=echo)\n\n        log.info(\"Downloading\", echo=echo)\n\n        # It is binary prefix, right? kibi, mebi, gibi, etc. as we're dealing with raw bytes\n        with open(output, \"wb\") as file, tqdm.tqdm(\n            desc=f\"Downloading ({output.name})\",\n            total=expected_size, unit=\"iB\", unit_scale=True, unit_divisor=1024,\n            mininterval=1/30, maxinterval=0.5, leave=False\n        ) as progress:\n            for data in response.iter_content(chunk_size=chunk):\n                progress.update(file.write(data))\n\n        # Url was invalid or something\n        if (response.status_code != 200):\n            log.error(f\"Failed to Download File at ({url}):\", echo=echo)\n            log.error(f\"\u2022 HTTP Error: {response.status_code}\", echo=echo)\n            return\n\n        # Wrong downloaded and expected size\n        elif (expected_size and size_check) and (output.stat().st_size != expected_size):\n            log.error(f\"File ({output}) was not downloaded correctly ({output.stat().st_size} != {expected_size})\", echo=echo)\n            return\n\n        log.success(f\"Downloaded file ({output}) from ({url})\", echo=echo)\n        return output\n\n    def get_external(url: str, *, subdir: str=\"\", echo: bool=True) -&gt; Path:\n        file = BrokenPath.url_filename(denum(url))\n        ARCHIVE = any((str(file).endswith(ext) for ext in ShutilFormat.values()))\n\n        # File is some known type, move to their own external directory\n        if bool(subdir):\n            directory = Broken.BROKEN.DIRECTORIES.EXTERNALS/subdir\n        elif ARCHIVE:\n            directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_ARCHIVES\n        elif (file.suffix in FileExtensions.Audio):\n            directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_AUDIO\n        elif (file.suffix in FileExtensions.Image):\n            directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_IMAGES\n        elif (file.suffix in FileExtensions.Font):\n            directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_FONTS\n        elif (file.suffix in FileExtensions.Soundfont):\n            directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_SOUNDFONTS\n        elif (file.suffix in FileExtensions.Midi):\n            directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_MIDIS\n        else:\n            directory = Broken.BROKEN.DIRECTORIES.EXTERNALS\n\n        # Download to target directory, avoiding a move/copy, be known on future calls\n        if not ARCHIVE:\n            directory = (directory/subdir/file.name)\n\n        # Finally download the file\n        file = BrokenPath.download(denum(url), directory, echo=echo)\n\n        # Maybe extract the downloaded file\n        if ARCHIVE:\n            file = BrokenPath.extract(file, echo=echo)\n\n        return BrokenPath.add_to_path(path=file, recurse=True, echo=echo)\n\n    def which(name: str) -&gt; Optional[Path]:\n        BrokenPath.update_externals_path()\n        return BrokenPath(shutil.which(name))\n\n    def update_externals_path(path: Path=None, *, echo: bool=True) -&gt; Optional[Path]:\n        path = (path or Broken.BROKEN.DIRECTORIES.EXTERNALS)\n        return BrokenPath.add_to_path(path, recurse=True, echo=echo)\n\n    def on_path(path: Path) -&gt; bool:\n        \"\"\"Check if a path is on PATH, works with symlinks\"\"\"\n        return (Path(path) in map(Path, os.getenv(\"PATH\", \"\").split(os.pathsep)))\n\n    def add_to_path(\n        path: Path,\n        *,\n        recurse: bool=False,\n        persistent: bool=False,\n        preferential: bool=True,\n        echo: bool=True\n    ) -&gt; Path:\n        \"\"\"\n        Add a path, recursively or not, to System's Path or this Python process's Path\n\n        Args:\n            recurse: Also add all subdirectories of the given path\n            persistent: Use 'userpath' package to add to the Shell's or Registry PATH\n            preferential: Prepends the path for less priority on system binaries\n\n        Returns:\n            The Path argument itself\n        \"\"\"\n        original = path = BrokenPath(path)\n\n        if (path.is_file()):\n            path = path.parent\n            recurse = False\n\n        # Can't recurse on non existing directories\n        if (not path.exists()) and recurse:\n            log.warning(f\"Not adding to PATH as directory doesn't exist ({path})\", echo=echo)\n            return path\n\n        log.debug(f\"Adding to Path (Recursively: {recurse}, Persistent: {persistent}): ({path})\", echo=echo)\n\n        for other in list(path.rglob(\"*\") if recurse else []) + [path]:\n\n            # Skip conditions\n            if other.is_file():\n                continue\n            if BrokenPath.on_path(other):\n                continue\n\n            # Actual logic\n            if persistent:\n                import userpath\n                userpath.append(str(other))\n            else:\n                if preferential:\n                    log.debug(f\"\u2022 Prepending: ({other})\", echo=echo)\n                    os.environ[\"PATH\"] = (str(other) + os.pathsep + os.environ[\"PATH\"])\n                    sys.path.insert(0, str(other))\n                else:\n                    log.debug(f\"\u2022 Appending: ({other})\", echo=echo)\n                    os.environ[\"PATH\"] = (os.environ[\"PATH\"] + os.pathsep + str(other))\n                    sys.path.append(str(other))\n\n        return original\n\n    # # Specific / \"Utils\"\n\n    def open_in_file_explorer(path: Path):\n        \"\"\"Opens a path in the file explorer\"\"\"\n        path = BrokenPath(path)\n        if BrokenPlatform.OnWindows:\n            os.startfile(str(path))\n        elif BrokenPlatform.OnLinux:\n            shell(\"xdg-open\", path)\n        elif BrokenPlatform.OnMacOS:\n            shell(\"open\", path)\n\n    # Fixme: Untested functions, needs better name; are these useful?\n\n    def non_empty_file(path: Path) -&gt; bool:\n        return path.exists() and path.is_file() and path.stat().st_size &gt; 0\n\n    def empty_file(path: Path, create: bool=True) -&gt; bool:\n        if create and not path.exists():\n            path.parent.mkdirs(parents=True, exist_ok=True)\n            path.touch()\n        return path.exists() and path.is_file() and len(path.read_text()) == 0\n\n    @contextlib.contextmanager\n    def PATH(*,\n        directories: List[Path],\n        recursive: bool=True,\n        prepend: bool=True,\n        clean: bool=False,\n        restore: bool=True,\n    ):\n        \"\"\"\n        Temporarily limits the PATH to given directories\n        - directories: List of directories to add to PATH\n        - recursive: Whether to add subdirectories of given directories to PATH\n        - prepend: Prioritize binaries found in input directories\n        - restricted: Do not include current PATH in the new PATH\n        \"\"\"\n\n        # Make Path objects\n        directories = apply(Path, flatten(directories))\n\n        # Get current PATH\n        old = os.environ[\"PATH\"]\n\n        # List of all directories in PATH\n        PATH = [] if clean else os.environ[\"PATH\"].split(os.pathsep)\n\n        # Add directories to PATH\n        for directory in directories:\n            PATH.append(directory)\n\n            # Do not recurse if so\n            if not recursive:\n                continue\n\n            # WARN: This could be slow on too many directories (wrong input?)\n            # Find all subdirectories of a path\n            for path in directory.rglob(\"*\"):\n                if path.is_dir():\n                    if prepend:\n                        PATH.insert(0, path)\n                    else:\n                        PATH.append(path)\n\n        # Set new PATH\n        os.environ[\"PATH\"] = os.pathsep.join(map(str, PATH))\n\n        yield os.environ[\"PATH\"]\n\n        # Restore PATH\n        os.environ[\"PATH\"] = old\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.__new__","title":"<code>__new__(*args, valid: bool = False, **kwargs)</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def __new__(cls, *args, valid: bool=False, **kwargs):\n\n    # Return None if all args are falsy\n    if not (args := list(filter(None, args))):\n        return None\n\n    # Use absolute expanded user always. Note that we do not want\n    # to .resolve() as having symlink paths _can_ be wanted\n    instance = super().__new__(cls, *args, **kwargs)\n    instance._raw_paths = list(map(str, args)) # Py312 fix\n    instance = instance.expanduser().absolute()\n    if (valid and not instance.exists()):\n        return None\n    return instance\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.pathlib","title":"<code>pathlib() -&gt; pathlib.Path</code>","text":"<p>Some packages test <code>type(var) == pathlib.Path</code> instead of <code>isinstance(var, pathlib.Path)</code></p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def pathlib(self) -&gt; pathlib.Path:\n    \"\"\"Some packages test `type(var) == pathlib.Path` instead of `isinstance(var, pathlib.Path)`\"\"\"\n    return pathlib.Path(self)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.str","title":"<code>str() -&gt; str</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def str(self) -&gt; str:\n    return str(self)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.valid","title":"<code>valid(path: Optional[BrokenPath]) -&gt; Optional[BrokenPath]</code>","text":"<p>Returns the BrokenPath if it exists, else None</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def valid(path: Optional[BrokenPath]) -&gt; Optional[BrokenPath]:\n    \"\"\"Returns the BrokenPath if it exists, else None\"\"\"\n    return BrokenPath(path, valid=True)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.copy","title":"<code>copy(src: Path, dst: Path, *, echo=True) -&gt; Path</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def copy(src: Path, dst: Path, *, echo=True) -&gt; Path:\n    src, dst = BrokenPath(src), BrokenPath(dst)\n    BrokenPath.mkdirs(dst.parent, echo=False)\n    if src.is_dir():\n        log.info(f\"Copying Directory ({src})\\n \u2192 ({dst})\", echo=echo)\n        shutil.copytree(src, dst)\n    else:\n        log.info(f\"Copying File ({src})\\n \u2192 ({dst})\", echo=echo)\n        shutil.copy2(src, dst)\n    return dst\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.move","title":"<code>move(src: Path, dst: Path, *, echo=True) -&gt; Path</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def move(src: Path, dst: Path, *, echo=True) -&gt; Path:\n    src, dst = BrokenPath(src), BrokenPath(dst)\n    log.info(f\"Moving ({src})\\n \u2192 ({dst})\", echo=echo)\n    shutil.move(src, dst)\n    return dst\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.remove","title":"<code>remove(path: Path, *, confirm=False, echo=True) -&gt; Path</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def remove(path: Path, *, confirm=False, echo=True) -&gt; Path:\n\n    # Already removed or doesn't exist\n    if not (path := BrokenPath(path).valid()):\n        return path\n\n    log.info(f\"Removing Path ({path})\", echo=echo)\n\n    # Safety: Must not be common\n    if path in (Path.cwd(), Path.home()):\n        log.error(f\"Avoided catastrophic failure by not removing ({path})\")\n        exit(1)\n\n    # Symlinks are safe to remove\n    if path.is_symlink():\n        path.unlink()\n        return path\n\n    # Confirm removal: directory contains data\n    if confirm and (not click.confirm(f\"\u2022 Confirm removing path ({path})\")):\n        return path\n\n    # Remove the path\n    if path.is_dir():\n        shutil.rmtree(path, ignore_errors=True)\n    else:\n        path.unlink()\n\n    return path\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.mkdirs","title":"<code>mkdirs(path: Path, parent: bool = False, *, echo=True) -&gt; Path</code>","text":"<p>Creates a directory and its parents, fail safe\u2122</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def mkdirs(path: Path, parent: bool=False, *, echo=True) -&gt; Path:\n    \"\"\"Creates a directory and its parents, fail safe\u2122\"\"\"\n    path = BrokenPath(path)\n    path = path.parent if parent else path\n    if path.exists():\n        log.success(f\"Directory ({path}) already exists\", echo=echo)\n        return path\n    log.info(f\"Creating directory {path}\", echo=echo)\n    path.mkdir(parents=True, exist_ok=True)\n    return path\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.resetdir","title":"<code>resetdir(path: Path, *, echo=True) -&gt; Path</code>","text":"<p>Delete and re-create a directory</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def resetdir(path: Path, *, echo=True) -&gt; Path:\n    \"\"\"Delete and re-create a directory\"\"\"\n    return BrokenPath.mkdirs(BrokenPath.remove(path, echo=echo), echo=echo)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.pushd","title":"<code>pushd(path: Path, *, echo: bool = True) -&gt; Generator[Path, None, None]</code>","text":"<p>Change directory, then change back when done</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>@contextlib.contextmanager\ndef pushd(path: Path, *, echo: bool=True) -&gt; Generator[Path, None, None]:\n    \"\"\"Change directory, then change back when done\"\"\"\n    path = BrokenPath(path)\n    cwd = os.getcwd()\n    log.info(f\"Pushd ({path})\", echo=echo)\n    os.chdir(path)\n    yield path\n    log.info(f\"Popd  ({path})\", echo=echo)\n    os.chdir(cwd)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.symlink","title":"<code>symlink(virtual: Path, real: Path, *, echo: bool = True) -&gt; Path</code>","text":"<p>Symlink [virtual] -&gt; [real], <code>virtual</code> being the symlink file and <code>real</code> the target</p> <p>Parameters:</p> <ul> <li> <code>virtual</code>             (<code>Path</code>)         \u2013          <p>Symlink path (file)</p> </li> <li> <code>real</code>             (<code>Path</code>)         \u2013          <p>Target path (real path)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>None if it fails, else <code>virtual</code> Path</p> </li> </ul> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def symlink(virtual: Path, real: Path, *, echo: bool=True) -&gt; Path:\n    \"\"\"\n    Symlink [virtual] -&gt; [real], `virtual` being the symlink file and `real` the target\n\n    Args:\n        virtual (Path): Symlink path (file)\n        real (Path): Target path (real path)\n\n    Returns:\n        None if it fails, else `virtual` Path\n    \"\"\"\n    log.info(f\"Symlinking ({virtual})\\n \u2192 ({real})\", echo=echo)\n\n    # Return if already symlinked\n    if (BrokenPath(virtual) == BrokenPath(real)):\n        return virtual\n\n    # Make Virtual's parent directory\n    BrokenPath.mkdirs(virtual.parent, echo=False)\n\n    # Remove old symlink if it points to a non existing directory\n    if virtual.is_symlink() and (not virtual.resolve().exists()):\n        virtual.unlink()\n\n    # Virtual doesn't exist, ok to create\n    elif not virtual.exists():\n        pass\n\n    # File exists and is a symlink - safe to remove\n    elif virtual.is_symlink():\n        virtual.unlink()\n\n    # Virtual is a directory and not empty\n    elif virtual.is_dir() and (not os.listdir(virtual)):\n        BrokenPath.remove(virtual, echo=False)\n\n    else:\n        if click.confirm('\\n'.join((\n            f\"Path ({virtual}) exists, but Broken wants to create a symlink to ({real})\",\n            \"\u2022 Confirm removing the 'virtual' path and continuing? (It might contain data or be a important symlink)\"\n        ))):\n            BrokenPath.remove(virtual, echo=False)\n        else:\n            return\n\n    try:\n        virtual.symlink_to(real)\n    except Exception as error:\n        if BrokenPlatform.OnWindows:\n            log.minor(\"Failed to create Symlink. Consider enabling 'Developer Mode' on Windows (https://rye.astral.sh/guide/faq/#windows-developer-mode)\")\n        else:\n            raise error\n\n    return virtual\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.make_executable","title":"<code>make_executable(path: Path, *, echo=False) -&gt; Path</code>","text":"<p>Make a file executable</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def make_executable(path: Path, *, echo=False) -&gt; Path:\n    \"\"\"Make a file executable\"\"\"\n    if BrokenPlatform.OnUnix:\n        shell(\"chmod\", \"+x\", path, echo=echo)\n    elif BrokenPlatform.OnWindows:\n        shell(\"attrib\", \"+x\", path, echo=echo)\n    return path\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.zip","title":"<code>zip(path: Path, output: Path = None, *, format: ShutilFormat = ShutilFormat.Zip, echo: bool = True) -&gt; Path</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def zip(path: Path, output: Path=None, *, format: ShutilFormat=ShutilFormat.Zip, echo: bool=True) -&gt; Path:\n    format = ShutilFormat.get(format)\n    output = BrokenPath(output or path).with_suffix(f\".{format}\")\n    path   = BrokenPath(path)\n    log.info(f\"Zipping ({path})\\n \u2192 ({output})\", echo=echo)\n    BrokenPath.remove(output, echo=echo)\n    shutil.make_archive(output.with_suffix(\"\"), format, path)\n    return output\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.merge_zips","title":"<code>merge_zips(*zips: List[Path], output: Path, echo: bool = True) -&gt; Path</code>","text":"<p>Merge multiple ZIP files into a single one</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def merge_zips(*zips: List[Path], output: Path, echo: bool=True) -&gt; Path:\n    \"\"\"Merge multiple ZIP files into a single one\"\"\"\n    import zipfile\n    with zipfile.ZipFile(output, \"w\") as archive:\n        for path in flatten(zips):\n            with zipfile.ZipFile(path, \"r\") as other:\n                for file in other.filelist:\n                    archive.writestr(file, other.read(file))\n    return output\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.stem","title":"<code>stem(path: Path) -&gt; str</code>","text":"<p>Get the \"true stem\" of a path, as pathlib's only gets the last dot one \u2022 \"/path/with/many.ext.ens.ions\" -&gt; \"many\" instead of \"many.ext.ens\"</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def stem(path: Path) -&gt; str:\n    \"\"\"\n    Get the \"true stem\" of a path, as pathlib's only gets the last dot one\n    \u2022 \"/path/with/many.ext.ens.ions\" -&gt; \"many\" instead of \"many.ext.ens\"\n    \"\"\"\n    stem = Path(Path(path).stem)\n    while (stem := Path(stem).with_suffix(\"\")).suffix:\n        continue\n    return str(stem)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.sha256sum","title":"<code>sha256sum(data: Union[Path, str, bytes]) -&gt; Optional[str]</code>","text":"<p>Get the sha256sum of a file, directory or bytes</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def sha256sum(data: Union[Path, str, bytes]) -&gt; Optional[str]:\n    \"\"\"Get the sha256sum of a file, directory or bytes\"\"\"\n\n    # Nibble the bytes !\n    if isinstance(data, bytes):\n        return hashlib.sha256(data).hexdigest()\n\n    # String or Path is a valid path\n    elif (path := BrokenPath(data).valid()):\n        with BrokenSpinner(log.info(f\"Calculating sha256sum of ({path})\")):\n            if path.is_file():\n                return hashlib.sha256(path.read_bytes()).hexdigest()\n\n            # Iterate on all files for low memory footprint\n            feed = hashlib.sha256()\n            for file in path.rglob(\"*\"):\n                if not file.is_file():\n                    continue\n                with open(file, \"rb\") as file:\n                    while (chunk := file.read(8192)):\n                        feed.update(chunk)\n            return feed.hexdigest()\n\n    elif isinstance(data, str):\n        return hashlib.sha256(data.encode(\"utf-8\")).hexdigest()\n\n    return\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.extract","title":"<code>extract(path: Path, output: Path = None, *, overwrite: bool = False, echo: bool = True) -&gt; Path</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def extract(\n    path: Path,\n    output: Path=None,\n    *,\n    overwrite: bool=False,\n    echo: bool=True\n) -&gt; Path:\n    path, output = BrokenPath(path), BrokenPath(output)\n\n    # Extract to the same directory by default\n    if (output is None):\n        output = path.parent\n\n    # Add stem to the output as some archives might be flat\n    output /= BrokenPath.stem(path)\n\n    # Re-extract on order\n    if overwrite:\n        BrokenPath.remove(output)\n\n    # A file to skip if it exists, created after successful extraction\n    if (extract_flag := (output/\"BrokenPath.extract.ok\")).exists():\n        log.minor(f\"Already extracted ({output})\", echo=echo)\n    else:\n        # Show progress as this might take a while on slower IOs\n        log.info(f\"Extracting ({path})\\n \u2192 ({output})\", echo=echo)\n        with BrokenSpinner(\"Extracting archive..\"):\n            shutil.unpack_archive(path, output)\n        extract_flag.touch()\n\n    return output\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.url_filename","title":"<code>url_filename(url: str) -&gt; Path</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def url_filename(url: str) -&gt; Path:\n    return Path(url.split(\"#\")[0].split(\"?\")[0].split(\"/\")[-1])\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.download","title":"<code>download(url: str, output: Path = None, *, size_check: bool = True, chunk: int = 1024, echo: bool = True) -&gt; Optional[Path]</code>","text":"<p>Note: If the output is a directory, the url's file name will be appended to it Note: The output will default to Broken Project's Download directory</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def download(\n    url: str,\n    output: Path=None,\n    *,\n    size_check: bool=True,\n    chunk: int=1024,\n    echo: bool=True\n) -&gt; Optional[Path]:\n    \"\"\"\n    Note: If the output is a directory, the url's file name will be appended to it\n    Note: The output will default to Broken Project's Download directory\n    \"\"\"\n\n    # Link must be valid\n    if not validators.url(url):\n        import click\n        if not click.confirm(log.error(f\"The following string doesn't look like a valid download URL on validator's eyes\\n\u2022 ({url})\\nContinue normally?\")):\n            return None\n\n    # Default to Broken's Download directory\n    if (output is None):\n        output = Broken.BROKEN.DIRECTORIES.DOWNLOADS\n\n    # Append url's file name to the output path\n    if (output := BrokenPath(output)).is_dir():\n        output /= BrokenPath.url_filename(url)\n\n    log.info(f\"Downloading\\n\u2022 URL:  ({url})\\n\u2022 Path: ({output})\", echo=echo)\n\n    # Without size check, the existence of the file is enough\n    if (not size_check) and output.exists():\n        log.minor(\"\u2022 File exists and Size check was skipped\", echo=echo)\n        return None\n\n    try:\n        import requests\n        response = requests.get(url, stream=True, headers={\"Accept-Encoding\": None})\n    except requests.exceptions.RequestException as error:\n        log.error(f\"\u2022 Failed to download: {error}\", echo=echo)\n        # Note: Return output as it might be downloaded but we're without internet\n        return output\n\n    # Note: The length header is not always present, if that, just check for existence\n    if not (expected_size := int(response.headers.get('content-length', 0))):\n        log.minor(\"The Download doesn't advertise a size, just checking for existence\", echo=echo)\n        if output.exists():\n            return output\n\n    # The file might already be (partially) downloaded\n    if (expected_size and size_check) and output.exists():\n        if (output.stat().st_size == expected_size):\n            return output\n        if (len(output.read_bytes()) == expected_size):\n            return output\n        log.warning(\"\u2022 Wrong Download size\", echo=echo)\n\n    log.info(\"Downloading\", echo=echo)\n\n    # It is binary prefix, right? kibi, mebi, gibi, etc. as we're dealing with raw bytes\n    with open(output, \"wb\") as file, tqdm.tqdm(\n        desc=f\"Downloading ({output.name})\",\n        total=expected_size, unit=\"iB\", unit_scale=True, unit_divisor=1024,\n        mininterval=1/30, maxinterval=0.5, leave=False\n    ) as progress:\n        for data in response.iter_content(chunk_size=chunk):\n            progress.update(file.write(data))\n\n    # Url was invalid or something\n    if (response.status_code != 200):\n        log.error(f\"Failed to Download File at ({url}):\", echo=echo)\n        log.error(f\"\u2022 HTTP Error: {response.status_code}\", echo=echo)\n        return\n\n    # Wrong downloaded and expected size\n    elif (expected_size and size_check) and (output.stat().st_size != expected_size):\n        log.error(f\"File ({output}) was not downloaded correctly ({output.stat().st_size} != {expected_size})\", echo=echo)\n        return\n\n    log.success(f\"Downloaded file ({output}) from ({url})\", echo=echo)\n    return output\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.get_external","title":"<code>get_external(url: str, *, subdir: str = '', echo: bool = True) -&gt; Path</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def get_external(url: str, *, subdir: str=\"\", echo: bool=True) -&gt; Path:\n    file = BrokenPath.url_filename(denum(url))\n    ARCHIVE = any((str(file).endswith(ext) for ext in ShutilFormat.values()))\n\n    # File is some known type, move to their own external directory\n    if bool(subdir):\n        directory = Broken.BROKEN.DIRECTORIES.EXTERNALS/subdir\n    elif ARCHIVE:\n        directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_ARCHIVES\n    elif (file.suffix in FileExtensions.Audio):\n        directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_AUDIO\n    elif (file.suffix in FileExtensions.Image):\n        directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_IMAGES\n    elif (file.suffix in FileExtensions.Font):\n        directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_FONTS\n    elif (file.suffix in FileExtensions.Soundfont):\n        directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_SOUNDFONTS\n    elif (file.suffix in FileExtensions.Midi):\n        directory = Broken.BROKEN.DIRECTORIES.EXTERNAL_MIDIS\n    else:\n        directory = Broken.BROKEN.DIRECTORIES.EXTERNALS\n\n    # Download to target directory, avoiding a move/copy, be known on future calls\n    if not ARCHIVE:\n        directory = (directory/subdir/file.name)\n\n    # Finally download the file\n    file = BrokenPath.download(denum(url), directory, echo=echo)\n\n    # Maybe extract the downloaded file\n    if ARCHIVE:\n        file = BrokenPath.extract(file, echo=echo)\n\n    return BrokenPath.add_to_path(path=file, recurse=True, echo=echo)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.which","title":"<code>which(name: str) -&gt; Optional[Path]</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def which(name: str) -&gt; Optional[Path]:\n    BrokenPath.update_externals_path()\n    return BrokenPath(shutil.which(name))\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.update_externals_path","title":"<code>update_externals_path(path: Path = None, *, echo: bool = True) -&gt; Optional[Path]</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def update_externals_path(path: Path=None, *, echo: bool=True) -&gt; Optional[Path]:\n    path = (path or Broken.BROKEN.DIRECTORIES.EXTERNALS)\n    return BrokenPath.add_to_path(path, recurse=True, echo=echo)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.on_path","title":"<code>on_path(path: Path) -&gt; bool</code>","text":"<p>Check if a path is on PATH, works with symlinks</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def on_path(path: Path) -&gt; bool:\n    \"\"\"Check if a path is on PATH, works with symlinks\"\"\"\n    return (Path(path) in map(Path, os.getenv(\"PATH\", \"\").split(os.pathsep)))\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.add_to_path","title":"<code>add_to_path(path: Path, *, recurse: bool = False, persistent: bool = False, preferential: bool = True, echo: bool = True) -&gt; Path</code>","text":"<p>Add a path, recursively or not, to System's Path or this Python process's Path</p> <p>Parameters:</p> <ul> <li> <code>recurse</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Also add all subdirectories of the given path</p> </li> <li> <code>persistent</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Use 'userpath' package to add to the Shell's or Registry PATH</p> </li> <li> <code>preferential</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Prepends the path for less priority on system binaries</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>The Path argument itself</p> </li> </ul> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def add_to_path(\n    path: Path,\n    *,\n    recurse: bool=False,\n    persistent: bool=False,\n    preferential: bool=True,\n    echo: bool=True\n) -&gt; Path:\n    \"\"\"\n    Add a path, recursively or not, to System's Path or this Python process's Path\n\n    Args:\n        recurse: Also add all subdirectories of the given path\n        persistent: Use 'userpath' package to add to the Shell's or Registry PATH\n        preferential: Prepends the path for less priority on system binaries\n\n    Returns:\n        The Path argument itself\n    \"\"\"\n    original = path = BrokenPath(path)\n\n    if (path.is_file()):\n        path = path.parent\n        recurse = False\n\n    # Can't recurse on non existing directories\n    if (not path.exists()) and recurse:\n        log.warning(f\"Not adding to PATH as directory doesn't exist ({path})\", echo=echo)\n        return path\n\n    log.debug(f\"Adding to Path (Recursively: {recurse}, Persistent: {persistent}): ({path})\", echo=echo)\n\n    for other in list(path.rglob(\"*\") if recurse else []) + [path]:\n\n        # Skip conditions\n        if other.is_file():\n            continue\n        if BrokenPath.on_path(other):\n            continue\n\n        # Actual logic\n        if persistent:\n            import userpath\n            userpath.append(str(other))\n        else:\n            if preferential:\n                log.debug(f\"\u2022 Prepending: ({other})\", echo=echo)\n                os.environ[\"PATH\"] = (str(other) + os.pathsep + os.environ[\"PATH\"])\n                sys.path.insert(0, str(other))\n            else:\n                log.debug(f\"\u2022 Appending: ({other})\", echo=echo)\n                os.environ[\"PATH\"] = (os.environ[\"PATH\"] + os.pathsep + str(other))\n                sys.path.append(str(other))\n\n    return original\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.open_in_file_explorer","title":"<code>open_in_file_explorer(path: Path)</code>","text":"<p>Opens a path in the file explorer</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def open_in_file_explorer(path: Path):\n    \"\"\"Opens a path in the file explorer\"\"\"\n    path = BrokenPath(path)\n    if BrokenPlatform.OnWindows:\n        os.startfile(str(path))\n    elif BrokenPlatform.OnLinux:\n        shell(\"xdg-open\", path)\n    elif BrokenPlatform.OnMacOS:\n        shell(\"open\", path)\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.non_empty_file","title":"<code>non_empty_file(path: Path) -&gt; bool</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def non_empty_file(path: Path) -&gt; bool:\n    return path.exists() and path.is_file() and path.stat().st_size &gt; 0\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.empty_file","title":"<code>empty_file(path: Path, create: bool = True) -&gt; bool</code>","text":"Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>def empty_file(path: Path, create: bool=True) -&gt; bool:\n    if create and not path.exists():\n        path.parent.mkdirs(parents=True, exist_ok=True)\n        path.touch()\n    return path.exists() and path.is_file() and len(path.read_text()) == 0\n</code></pre>"},{"location":"broken/reference/core/brokenpath/#Core.BrokenPath.BrokenPath.PATH","title":"<code>PATH(*, directories: List[Path], recursive: bool = True, prepend: bool = True, clean: bool = False, restore: bool = True)</code>","text":"<p>Temporarily limits the PATH to given directories - directories: List of directories to add to PATH - recursive: Whether to add subdirectories of given directories to PATH - prepend: Prioritize binaries found in input directories - restricted: Do not include current PATH in the new PATH</p> Source code in <code>Broken/Core/BrokenPath.py</code> Python<pre><code>@contextlib.contextmanager\ndef PATH(*,\n    directories: List[Path],\n    recursive: bool=True,\n    prepend: bool=True,\n    clean: bool=False,\n    restore: bool=True,\n):\n    \"\"\"\n    Temporarily limits the PATH to given directories\n    - directories: List of directories to add to PATH\n    - recursive: Whether to add subdirectories of given directories to PATH\n    - prepend: Prioritize binaries found in input directories\n    - restricted: Do not include current PATH in the new PATH\n    \"\"\"\n\n    # Make Path objects\n    directories = apply(Path, flatten(directories))\n\n    # Get current PATH\n    old = os.environ[\"PATH\"]\n\n    # List of all directories in PATH\n    PATH = [] if clean else os.environ[\"PATH\"].split(os.pathsep)\n\n    # Add directories to PATH\n    for directory in directories:\n        PATH.append(directory)\n\n        # Do not recurse if so\n        if not recursive:\n            continue\n\n        # WARN: This could be slow on too many directories (wrong input?)\n        # Find all subdirectories of a path\n        for path in directory.rglob(\"*\"):\n            if path.is_dir():\n                if prepend:\n                    PATH.insert(0, path)\n                else:\n                    PATH.append(path)\n\n    # Set new PATH\n    os.environ[\"PATH\"] = os.pathsep.join(map(str, PATH))\n\n    yield os.environ[\"PATH\"]\n\n    # Restore PATH\n    os.environ[\"PATH\"] = old\n</code></pre>"},{"location":"broken/reference/core/brokenplatform/","title":"BrokenPlatform","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform","title":"<code>Core.BrokenPlatform</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform","title":"<code>Core.BrokenPlatform.BrokenPlatform</code>","text":"<p>Host Platform information, Cross Compilation targets and some utilities</p> Source code in <code>Broken/Core/BrokenPlatform.py</code> Python<pre><code>class BrokenPlatform:\n    \"\"\"\n    Host Platform information, Cross Compilation targets and some utilities\n    \"\"\"\n\n    # Name of the current platform - (linux, windows, macos, bsd)\n    Name:         str  = platform.system().lower().replace(\"darwin\", \"macos\")\n\n    # Booleans if the current platform is the following\n    OnLinux:      bool = (Name == \"linux\")\n    OnWindows:    bool = (Name == \"windows\")\n    OnMacOS:      bool = (Name == \"macos\")\n    OnBSD:        bool = (Name == \"bsd\")\n\n    # Platform release binaries extension and CPU architecture\n    Extension:    str  = (\".exe\" if OnWindows else \".bin\")\n    Architecture: str  = (platform.machine().lower().replace(\"x86_64\", \"amd64\"))\n\n    # Family of platforms\n    OnUnix:       bool = (OnLinux or OnMacOS or OnBSD)\n\n    # Distro IDs: https://distro.readthedocs.io/en/latest/\n    LinuxDistro:  str  = distro.id()\n\n    # # Booleans if the current platform is the following\n\n    # Ubuntu-like\n    OnUbuntu:     bool = (LinuxDistro == \"ubuntu\")\n    OnDebian:     bool = (LinuxDistro == \"debian\")\n    OnMint:       bool = (LinuxDistro == \"linuxmint\")\n    OnRaspberry:  bool = (LinuxDistro == \"raspbian\")\n    OnUbuntuLike: bool = (OnUbuntu or OnDebian or OnMint or OnRaspberry)\n\n    # Arch-like\n    OnArch:       bool = (LinuxDistro == \"arch\")\n    OnManjaro:    bool = (LinuxDistro == \"manjaro\")\n    OnArchLike:   bool = (OnArch or OnManjaro)\n\n    # RedHat-like\n    OnFedora:     bool = (LinuxDistro == \"fedora\")\n    OnCentOS:     bool = (LinuxDistro == \"centos\")\n    OnRedHat:     bool = (LinuxDistro == \"rhel\")\n    OnRedHatLike: bool = (OnFedora or OnCentOS or OnRedHat)\n\n    # Others\n    OnGentoo:     bool = (LinuxDistro == \"gentoo\")\n\n    # BSD-like\n    OnOpenBSD:    bool = (LinuxDistro == \"openbsd\")\n    OnNetBSD:     bool = (LinuxDistro == \"netbsd\")\n    OnBSDLike:    bool = (OnOpenBSD or OnNetBSD)\n\n    class Targets(BrokenEnum):\n        \"\"\"List of common platforms targets for releases\"\"\"\n        LinuxAMD64:   str = \"linux-amd64\"\n        LinuxARM:     str = \"linux-arm64\"\n        WindowsAMD64: str = \"windows-amd64\"\n        WindowsARM:   str = \"windows-arm64\"\n        MacosAMD64:   str = \"macos-amd64\"\n        MacosARM:     str = \"macos-arm64\"\n\n        @property\n        def rust(self) -&gt; str:\n            windows_compiler = (\"msvc\" if BrokenPlatform.OnWindows else \"gnu\")\n            return {\n                self.LinuxAMD64:   \"x86_64-unknown-linux-gnu\",\n                self.LinuxARM:     \"aarch64-unknown-linux-gnu\",\n                self.WindowsAMD64: \"x86_64-pc-windows-\" + windows_compiler,\n                self.WindowsARM:   \"aarch64-pc-windows-\" + windows_compiler,\n                self.MacosAMD64:   \"x86_64-apple-darwin\",\n                self.MacosARM:     \"aarch64-apple-darwin\",\n            }[self]\n\n        @property\n        def extension(self) -&gt; str:\n            \"\"\"Same as BrokenPlatform.Extension\"\"\"\n            if (\"windows\" in self.value):\n                return \".exe\"\n            if (\"macos\" in self.value):\n                return \".app\"\n            return \".bin\"\n\n        @property\n        def name(self) -&gt; str:\n            \"\"\"Same as BrokenPlatform.Name\"\"\"\n            return self.value.split(\"-\")[0]\n\n        @property\n        def architecture(self) -&gt; str:\n            \"\"\"Same as BrokenPlatform.Architecture\"\"\"\n            return self.value.split(\"-\")[1]\n\n    CurrentTarget: str = f\"{Name}-{Architecture}\"\n\n    @staticmethod\n    def log_system_info():\n        log.info(f\"\u2022 System Info: {platform.system()} {platform.release()}, Python {platform.python_version()} {platform.machine()}\")\n\n    @staticmethod\n    def clear_terminal():\n        os.system(\"cls\" if BrokenPlatform.OnWindows else \"clear\")\n\n    # Literally, why Windows/Python have different directory names for scripts? ...\n    # https://github.com/pypa/virtualenv/commit/993ba1316a83b760370f5a3872b3f5ef4dd904c1\n    PyScripts         = (\"Scripts\" if OnWindows else \"bin\")\n    PyScriptExtension = (\".cmd\" if OnWindows else \"\")\n</code></pre>"},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Name","title":"<code>Name: str = platform.system().lower().replace('darwin', 'macos')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnLinux","title":"<code>OnLinux: bool = Name == 'linux'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnWindows","title":"<code>OnWindows: bool = Name == 'windows'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnMacOS","title":"<code>OnMacOS: bool = Name == 'macos'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnBSD","title":"<code>OnBSD: bool = Name == 'bsd'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Extension","title":"<code>Extension: str = '.exe' if OnWindows else '.bin'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Architecture","title":"<code>Architecture: str = platform.machine().lower().replace('x86_64', 'amd64')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnUnix","title":"<code>OnUnix: bool = OnLinux or OnMacOS or OnBSD</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.LinuxDistro","title":"<code>LinuxDistro: str = distro.id()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnUbuntu","title":"<code>OnUbuntu: bool = LinuxDistro == 'ubuntu'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnDebian","title":"<code>OnDebian: bool = LinuxDistro == 'debian'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnMint","title":"<code>OnMint: bool = LinuxDistro == 'linuxmint'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnRaspberry","title":"<code>OnRaspberry: bool = LinuxDistro == 'raspbian'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnUbuntuLike","title":"<code>OnUbuntuLike: bool = OnUbuntu or OnDebian or OnMint or OnRaspberry</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnArch","title":"<code>OnArch: bool = LinuxDistro == 'arch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnManjaro","title":"<code>OnManjaro: bool = LinuxDistro == 'manjaro'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnArchLike","title":"<code>OnArchLike: bool = OnArch or OnManjaro</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnFedora","title":"<code>OnFedora: bool = LinuxDistro == 'fedora'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnCentOS","title":"<code>OnCentOS: bool = LinuxDistro == 'centos'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnRedHat","title":"<code>OnRedHat: bool = LinuxDistro == 'rhel'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnRedHatLike","title":"<code>OnRedHatLike: bool = OnFedora or OnCentOS or OnRedHat</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnGentoo","title":"<code>OnGentoo: bool = LinuxDistro == 'gentoo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnOpenBSD","title":"<code>OnOpenBSD: bool = LinuxDistro == 'openbsd'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnNetBSD","title":"<code>OnNetBSD: bool = LinuxDistro == 'netbsd'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.OnBSDLike","title":"<code>OnBSDLike: bool = OnOpenBSD or OnNetBSD</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets","title":"<code>Targets</code>","text":"<p>List of common platforms targets for releases</p> Source code in <code>Broken/Core/BrokenPlatform.py</code> Python<pre><code>class Targets(BrokenEnum):\n    \"\"\"List of common platforms targets for releases\"\"\"\n    LinuxAMD64:   str = \"linux-amd64\"\n    LinuxARM:     str = \"linux-arm64\"\n    WindowsAMD64: str = \"windows-amd64\"\n    WindowsARM:   str = \"windows-arm64\"\n    MacosAMD64:   str = \"macos-amd64\"\n    MacosARM:     str = \"macos-arm64\"\n\n    @property\n    def rust(self) -&gt; str:\n        windows_compiler = (\"msvc\" if BrokenPlatform.OnWindows else \"gnu\")\n        return {\n            self.LinuxAMD64:   \"x86_64-unknown-linux-gnu\",\n            self.LinuxARM:     \"aarch64-unknown-linux-gnu\",\n            self.WindowsAMD64: \"x86_64-pc-windows-\" + windows_compiler,\n            self.WindowsARM:   \"aarch64-pc-windows-\" + windows_compiler,\n            self.MacosAMD64:   \"x86_64-apple-darwin\",\n            self.MacosARM:     \"aarch64-apple-darwin\",\n        }[self]\n\n    @property\n    def extension(self) -&gt; str:\n        \"\"\"Same as BrokenPlatform.Extension\"\"\"\n        if (\"windows\" in self.value):\n            return \".exe\"\n        if (\"macos\" in self.value):\n            return \".app\"\n        return \".bin\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Same as BrokenPlatform.Name\"\"\"\n        return self.value.split(\"-\")[0]\n\n    @property\n    def architecture(self) -&gt; str:\n        \"\"\"Same as BrokenPlatform.Architecture\"\"\"\n        return self.value.split(\"-\")[1]\n</code></pre>"},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.LinuxAMD64","title":"<code>LinuxAMD64: str = 'linux-amd64'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.LinuxARM","title":"<code>LinuxARM: str = 'linux-arm64'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.WindowsAMD64","title":"<code>WindowsAMD64: str = 'windows-amd64'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.WindowsARM","title":"<code>WindowsARM: str = 'windows-arm64'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.MacosAMD64","title":"<code>MacosAMD64: str = 'macos-amd64'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.MacosARM","title":"<code>MacosARM: str = 'macos-arm64'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.rust","title":"<code>rust: str</code>  <code>property</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.extension","title":"<code>extension: str</code>  <code>property</code>","text":"<p>Same as BrokenPlatform.Extension</p>"},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Same as BrokenPlatform.Name</p>"},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.Targets.architecture","title":"<code>architecture: str</code>  <code>property</code>","text":"<p>Same as BrokenPlatform.Architecture</p>"},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.CurrentTarget","title":"<code>CurrentTarget: str = f'{Name}-{Architecture}'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.log_system_info","title":"<code>log_system_info()</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/BrokenPlatform.py</code> Python<pre><code>@staticmethod\ndef log_system_info():\n    log.info(f\"\u2022 System Info: {platform.system()} {platform.release()}, Python {platform.python_version()} {platform.machine()}\")\n</code></pre>"},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.clear_terminal","title":"<code>clear_terminal()</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/BrokenPlatform.py</code> Python<pre><code>@staticmethod\ndef clear_terminal():\n    os.system(\"cls\" if BrokenPlatform.OnWindows else \"clear\")\n</code></pre>"},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.PyScripts","title":"<code>PyScripts = 'Scripts' if OnWindows else 'bin'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenplatform/#Core.BrokenPlatform.BrokenPlatform.PyScriptExtension","title":"<code>PyScriptExtension = '.cmd' if OnWindows else ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenprofiler/","title":"BrokenProfiler","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler","title":"<code>Core.BrokenProfiler</code>","text":""},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfilerEnum","title":"<code>Core.BrokenProfiler.BrokenProfilerEnum</code>","text":"<p>List of profilers</p> Source code in <code>Broken/Core/BrokenProfiler.py</code> Python<pre><code>class BrokenProfilerEnum(BrokenEnum):\n    \"\"\"List of profilers\"\"\"\n    cprofile      = \"cprofile\"\n</code></pre>"},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfilerEnum.cprofile","title":"<code>cprofile = 'cprofile'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfiler","title":"<code>Core.BrokenProfiler.BrokenProfiler</code>","text":"Source code in <code>Broken/Core/BrokenProfiler.py</code> Python<pre><code>@define\nclass BrokenProfiler:\n    name: str = \"NONE\"\n    profiler: BrokenProfilerEnum = BrokenProfilerEnum.cprofile\n\n    def __attrs_post_init__(self):\n        profiler = os.getenv(f\"{self.name}_PROFILER\", self.profiler)\n        self.profiler = BrokenProfilerEnum.get(profiler)\n\n    @property\n    def enabled(self) -&gt; bool:\n        return os.getenv(f\"{self.name}_PROFILE\", \"0\") == \"1\"\n\n    @property\n    def output(self) -&gt; Path:\n        return Path(tempfile.gettempdir())/f\"{self.name}.prof\"\n\n    __profiler__: Any = None\n\n    def __enter__(self) -&gt; Self:\n        if not self.enabled:\n            pass\n        elif (self.profiler == BrokenProfilerEnum.cprofile):\n            log.trace(\"Profiling with cProfile\")\n            import cProfile\n            self.__profiler__ = cProfile.Profile()\n            self.__profiler__.enable()\n        return self\n\n    def __exit__(self, *args) -&gt; None:\n        if not self.enabled:\n            return\n\n        if (self.profiler == BrokenProfilerEnum.cprofile):\n            log.trace(\"Finishing cProfile\")\n            output = self.output.with_suffix(\".prof\")\n            self.__profiler__.disable()\n            self.__profiler__.dump_stats(output)\n            shell(\"snakeviz\", output)\n            return\n</code></pre>"},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfiler.name","title":"<code>name: str = 'NONE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfiler.profiler","title":"<code>profiler: BrokenProfilerEnum = BrokenProfilerEnum.cprofile</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfiler.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"Source code in <code>Broken/Core/BrokenProfiler.py</code> Python<pre><code>def __attrs_post_init__(self):\n    profiler = os.getenv(f\"{self.name}_PROFILER\", self.profiler)\n    self.profiler = BrokenProfilerEnum.get(profiler)\n</code></pre>"},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfiler.enabled","title":"<code>enabled: bool</code>  <code>property</code>","text":""},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfiler.output","title":"<code>output: Path</code>  <code>property</code>","text":""},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfiler.__profiler__","title":"<code>__profiler__: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfiler.__enter__","title":"<code>__enter__() -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenProfiler.py</code> Python<pre><code>def __enter__(self) -&gt; Self:\n    if not self.enabled:\n        pass\n    elif (self.profiler == BrokenProfilerEnum.cprofile):\n        log.trace(\"Profiling with cProfile\")\n        import cProfile\n        self.__profiler__ = cProfile.Profile()\n        self.__profiler__.enable()\n    return self\n</code></pre>"},{"location":"broken/reference/core/brokenprofiler/#Core.BrokenProfiler.BrokenProfiler.__exit__","title":"<code>__exit__(*args) -&gt; None</code>","text":"Source code in <code>Broken/Core/BrokenProfiler.py</code> Python<pre><code>def __exit__(self, *args) -&gt; None:\n    if not self.enabled:\n        return\n\n    if (self.profiler == BrokenProfilerEnum.cprofile):\n        log.trace(\"Finishing cProfile\")\n        output = self.output.with_suffix(\".prof\")\n        self.__profiler__.disable()\n        self.__profiler__.dump_stats(output)\n        shell(\"snakeviz\", output)\n        return\n</code></pre>"},{"location":"broken/reference/core/brokenproject/","title":"BrokenProject","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject","title":"<code>Core.BrokenProject</code>","text":""},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.mkdir","title":"<code>Core.BrokenProject.mkdir(path: Path, resolve: bool = True) -&gt; Path</code>","text":"<p>Make a directory and return it</p> Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>def mkdir(path: Path, resolve: bool=True) -&gt; Path:\n    \"\"\"Make a directory and return it\"\"\"\n    path = Path(path).resolve() if resolve else Path(path)\n    if not path.exists():\n        log.info(f\"Creating directory: {path}\")\n        path.mkdir(parents=True, exist_ok=True)\n    return path\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject","title":"<code>Core.BrokenProject.BrokenProject</code>","text":"Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>@define(slots=False)\nclass BrokenProject:\n    # Note: Send the importer's __init__.py's __file__ variable\n    PACKAGE: str\n\n    # App information\n    APP_NAME:   str = field(default=\"Broken\")\n    APP_AUTHOR: str = field(default=\"BrokenSource\")\n\n    # Standard Broken objects for a project\n    DIRECTORIES: _BrokenProjectDirectories = None\n    RESOURCES:   _BrokenProjectResources   = None\n    VERSION:     str                       = None\n\n    def __attrs_post_init__(self):\n        self.DIRECTORIES = _BrokenProjectDirectories(BROKEN_PROJECT=self)\n        self.RESOURCES   = _BrokenProjectResources  (BROKEN_PROJECT=self)\n        self.PACKAGE     = Path(self.PACKAGE)\n        self.VERSION     = Broken.VERSION\n        BrokenLogging.set_project(self.APP_NAME)\n\n        # Replace Broken.PROJECT once with the first project\n        # initialized that is not the main project itself\n        if (project := getattr(Broken, \"PROJECT\", None)):\n            if (project is Broken.BROKEN):\n                self.pyapp_new_binary_restore_hook()\n                Broken.PROJECT = self\n\n        # Print version information and exit on \"--version/-V\"\n        if (self.APP_NAME != \"Broken\"):\n            if (len(sys.argv) &gt; 1) and (sys.argv[1] in (\"--version\", \"-V\")) and (not sys.argv[2:]):\n                print(f\"{self.APP_NAME} {self.VERSION} {BrokenPlatform.CurrentTarget}\")\n                exit(0)\n\n        # Convenience: Symlink Workspace to projects data directory\n        if Broken.DEVELOPMENT:\n            BrokenPath.symlink(\n                virtual=self.DIRECTORIES.REPOSITORY/\"Workspace\",\n                real=self.DIRECTORIES.WORKSPACE,\n                echo=False\n            )\n\n        # Load .env files from the project\n        for env in self.DIRECTORIES.REPOSITORY.glob(\"*.env\"):\n            dotenv.load_dotenv(env)\n\n    def chdir(self) -&gt; Self:\n        \"\"\"Change directory to the project's root\"\"\"\n        return os.chdir(self.PACKAGE.parent.parent) or self\n\n    def welcome(self):\n        \"\"\"Pretty Welcome Message!\"\"\"\n        import pyfiglet\n\n        # Build message\n        ascii = pyfiglet.figlet_format(self.APP_NAME)\n        ascii = '\\n'.join((x for x in ascii.split('\\n') if x.strip()))\n\n        # Print panel center-justified lines\n        rprint(Panel(\n            Align.center(ascii + \"\\n\"),\n            subtitle=' '.join((\n                f\"Made with \u2764\ufe0f by {self.APP_AUTHOR},\",\n                f\"Python {sys.version.split()[0]}\"\n            )),\n        ))\n\n    def pyapp_new_binary_restore_hook(self) -&gt; None:\n        \"\"\"One might send rolling releases or development betas of the same major version; whenever\n        the current PyApp binary changes hash, we reinstall the virtual environment\"\"\"\n        if not (pyapp_binary := os.getenv(\"PYAPP\", False)):\n            return\n\n        import hashlib\n        venv_path = Path(os.environ[\"VIRTUAL_ENV\"])\n        hash_file = venv_path.parent/f\"{self.APP_NAME.lower()}-{self.VERSION}.sha256\"\n        this_hash = hashlib.sha256(open(pyapp_binary, \"rb\").read()).hexdigest()\n        old_hash  = (hash_file.read_text() if hash_file.exists() else None)\n        hash_file.write_text(this_hash)\n\n        # \"If either hash differs and not on the first run\"\n        if (old_hash is not None) and (old_hash != this_hash):\n            print(\"-\"*shutil.get_terminal_size().columns)\n            log.info(f\"Detected different binary hash for this release version {self.VERSION} of the Project {self.APP_NAME}\")\n            log.info(f\"\u2022 Path: ({venv_path})\")\n            log.info(\"\u2022 Reinstalling the Virtual Environment alongside dependencies\")\n\n            # Fixme (#ntfs): \ud83e\udd13 https://superuser.com/questions/488127\"\n            # Fixme (#ntfs): \ud83d\udcaa https://unix.stackexchange.com/questions/49299\n            if BrokenPlatform.OnWindows:\n                previous = venv_path.with_name(\"0.0.0\")\n                BrokenPath.remove(previous)\n                venv_path.rename(previous)\n                input(\"\\nPlease, reopen this Executable due technical reasons of Windows NTFS. Press Enter to exit.\\n\")\n                exit(0)\n            else:\n                shell(pyapp_binary, os.environ[\"PYAPP_COMMAND_NAME\"], \"restore\", stdout=subprocess.DEVNULL)\n                print(\"-\"*shutil.get_terminal_size().columns)\n                sys.exit(shell(pyapp_binary, sys.argv[1:]).returncode)\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.PACKAGE","title":"<code>PACKAGE: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.APP_NAME","title":"<code>APP_NAME: str = field(default='Broken')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.APP_AUTHOR","title":"<code>APP_AUTHOR: str = field(default='BrokenSource')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.DIRECTORIES","title":"<code>DIRECTORIES: _BrokenProjectDirectories = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.RESOURCES","title":"<code>RESOURCES: _BrokenProjectResources = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.VERSION","title":"<code>VERSION: str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>def __attrs_post_init__(self):\n    self.DIRECTORIES = _BrokenProjectDirectories(BROKEN_PROJECT=self)\n    self.RESOURCES   = _BrokenProjectResources  (BROKEN_PROJECT=self)\n    self.PACKAGE     = Path(self.PACKAGE)\n    self.VERSION     = Broken.VERSION\n    BrokenLogging.set_project(self.APP_NAME)\n\n    # Replace Broken.PROJECT once with the first project\n    # initialized that is not the main project itself\n    if (project := getattr(Broken, \"PROJECT\", None)):\n        if (project is Broken.BROKEN):\n            self.pyapp_new_binary_restore_hook()\n            Broken.PROJECT = self\n\n    # Print version information and exit on \"--version/-V\"\n    if (self.APP_NAME != \"Broken\"):\n        if (len(sys.argv) &gt; 1) and (sys.argv[1] in (\"--version\", \"-V\")) and (not sys.argv[2:]):\n            print(f\"{self.APP_NAME} {self.VERSION} {BrokenPlatform.CurrentTarget}\")\n            exit(0)\n\n    # Convenience: Symlink Workspace to projects data directory\n    if Broken.DEVELOPMENT:\n        BrokenPath.symlink(\n            virtual=self.DIRECTORIES.REPOSITORY/\"Workspace\",\n            real=self.DIRECTORIES.WORKSPACE,\n            echo=False\n        )\n\n    # Load .env files from the project\n    for env in self.DIRECTORIES.REPOSITORY.glob(\"*.env\"):\n        dotenv.load_dotenv(env)\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.chdir","title":"<code>chdir() -&gt; Self</code>","text":"<p>Change directory to the project's root</p> Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>def chdir(self) -&gt; Self:\n    \"\"\"Change directory to the project's root\"\"\"\n    return os.chdir(self.PACKAGE.parent.parent) or self\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.welcome","title":"<code>welcome()</code>","text":"<p>Pretty Welcome Message!</p> Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>def welcome(self):\n    \"\"\"Pretty Welcome Message!\"\"\"\n    import pyfiglet\n\n    # Build message\n    ascii = pyfiglet.figlet_format(self.APP_NAME)\n    ascii = '\\n'.join((x for x in ascii.split('\\n') if x.strip()))\n\n    # Print panel center-justified lines\n    rprint(Panel(\n        Align.center(ascii + \"\\n\"),\n        subtitle=' '.join((\n            f\"Made with \u2764\ufe0f by {self.APP_AUTHOR},\",\n            f\"Python {sys.version.split()[0]}\"\n        )),\n    ))\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenProject.pyapp_new_binary_restore_hook","title":"<code>pyapp_new_binary_restore_hook() -&gt; None</code>","text":"<p>One might send rolling releases or development betas of the same major version; whenever the current PyApp binary changes hash, we reinstall the virtual environment</p> Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>def pyapp_new_binary_restore_hook(self) -&gt; None:\n    \"\"\"One might send rolling releases or development betas of the same major version; whenever\n    the current PyApp binary changes hash, we reinstall the virtual environment\"\"\"\n    if not (pyapp_binary := os.getenv(\"PYAPP\", False)):\n        return\n\n    import hashlib\n    venv_path = Path(os.environ[\"VIRTUAL_ENV\"])\n    hash_file = venv_path.parent/f\"{self.APP_NAME.lower()}-{self.VERSION}.sha256\"\n    this_hash = hashlib.sha256(open(pyapp_binary, \"rb\").read()).hexdigest()\n    old_hash  = (hash_file.read_text() if hash_file.exists() else None)\n    hash_file.write_text(this_hash)\n\n    # \"If either hash differs and not on the first run\"\n    if (old_hash is not None) and (old_hash != this_hash):\n        print(\"-\"*shutil.get_terminal_size().columns)\n        log.info(f\"Detected different binary hash for this release version {self.VERSION} of the Project {self.APP_NAME}\")\n        log.info(f\"\u2022 Path: ({venv_path})\")\n        log.info(\"\u2022 Reinstalling the Virtual Environment alongside dependencies\")\n\n        # Fixme (#ntfs): \ud83e\udd13 https://superuser.com/questions/488127\"\n        # Fixme (#ntfs): \ud83d\udcaa https://unix.stackexchange.com/questions/49299\n        if BrokenPlatform.OnWindows:\n            previous = venv_path.with_name(\"0.0.0\")\n            BrokenPath.remove(previous)\n            venv_path.rename(previous)\n            input(\"\\nPlease, reopen this Executable due technical reasons of Windows NTFS. Press Enter to exit.\\n\")\n            exit(0)\n        else:\n            shell(pyapp_binary, os.environ[\"PYAPP_COMMAND_NAME\"], \"restore\", stdout=subprocess.DEVNULL)\n            print(\"-\"*shutil.get_terminal_size().columns)\n            sys.exit(shell(pyapp_binary, sys.argv[1:]).returncode)\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenApp","title":"<code>Core.BrokenProject.BrokenApp</code>","text":"Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>@define\nclass BrokenApp(ABC, BrokenAttrs):\n    PROJECT: BrokenProject\n    typer: BrokenTyper = Factory(BrokenTyper)\n\n    def __post__(self):\n\n        # Windows users have a tendency to not run stuff on a terminal...\n        self.typer.repl = (Broken.RELEASE and BrokenPlatform.OnWindows)\n\n        with BrokenProfiler(self.PROJECT.APP_NAME):\n            self.main()\n\n    @abstractmethod\n    def main(self) -&gt; None:\n        pass\n\n    def find_projects(self, tag: str=\"Project\") -&gt; None:\n        \"\"\"Find Python files in common directories (direct call, cwd) that any class inherits from\n        something that contains the substring of `tag` and add as a command to this Typer app\"\"\"\n        files = deque()\n\n        # Note: Safe get argv[1], pop if valid, else a dne path\n        if (direct := Path(dict(enumerate(sys.argv)).get(1, \"\\0\"))).exists():\n            direct = Path(sys.argv.pop(1))\n\n        # Scan files\n        if (direct.suffix == \".py\"):\n            files.append(direct)\n        elif direct.is_dir():\n            files.extend(direct.glob(\"*.py\"))\n        else:\n            files.extend(self.PROJECT.DIRECTORIES.PROJECTS.rglob(\"*.py\"))\n            files.extend(self.PROJECT.RESOURCES.SCENES.rglob(\"*.py\"))\n            files.extend(Path.cwd().glob(\"*.py\"))\n\n        # Add commands of all files, exit if none was sucessfully added\n        if (sum(map(lambda file: self.add_project(file, tag), files)) == 0):\n            log.warning(f\"No {self.PROJECT.APP_NAME} Projects found, searched in:\")\n            log.warning('\\n'.join(map(lambda file: f\"\u2022 {file}\", files)))\n            exit(1)\n\n    def regex(self, tag: str) -&gt; re.Pattern:\n        \"\"\"Generates the self.regex for matching any valid Python class that contains \"tag\" on the\n        inheritance, and its optional docstring on the next line\"\"\"\n        return re.compile(\n            r\"^class\\s+(\\w+)\\s*\\(.*?(?:\" + tag + r\").*\\):\\s*(?:\\\"\\\"\\\"((?:\\n|.)*?)\\\"\\\"\\\")?\",\n            re.MULTILINE\n        )\n\n    def add_project(self, python: Path, tag: str=\"Project\") -&gt; bool:\n        if not python.exists():\n            return False\n\n        def run(file, name, code):\n            def run(ctx: Context):\n                # Note: Point of trust transfer to the file the user is running\n                exec(compile(code, file, \"exec\"), (namespace := {}))\n                namespace[name]().cli(*ctx.args)\n            return run\n\n        # Match all scenes and their optional docstrings\n        for match in self.regex(tag).finditer(code := python.read_text(encoding=\"utf-8\")):\n            class_name, docstring = match.groups()\n            self.typer.command(\n                target=run(python, class_name, code),\n                name=class_name.lower(),\n                help=(docstring or \"No description provided\"),\n                panel=f\"\ud83d\udce6 Projects at [bold]({python})[/bold]\",\n                add_help_option=False,\n                context=True,\n            )\n\n        return bool(self.typer.commands)\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenApp.PROJECT","title":"<code>PROJECT: BrokenProject</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenApp.typer","title":"<code>typer: BrokenTyper = Factory(BrokenTyper)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenApp.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>def __post__(self):\n\n    # Windows users have a tendency to not run stuff on a terminal...\n    self.typer.repl = (Broken.RELEASE and BrokenPlatform.OnWindows)\n\n    with BrokenProfiler(self.PROJECT.APP_NAME):\n        self.main()\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenApp.main","title":"<code>main() -&gt; None</code>  <code>abstractmethod</code>","text":"Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>@abstractmethod\ndef main(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenApp.find_projects","title":"<code>find_projects(tag: str = 'Project') -&gt; None</code>","text":"<p>Find Python files in common directories (direct call, cwd) that any class inherits from something that contains the substring of <code>tag</code> and add as a command to this Typer app</p> Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>def find_projects(self, tag: str=\"Project\") -&gt; None:\n    \"\"\"Find Python files in common directories (direct call, cwd) that any class inherits from\n    something that contains the substring of `tag` and add as a command to this Typer app\"\"\"\n    files = deque()\n\n    # Note: Safe get argv[1], pop if valid, else a dne path\n    if (direct := Path(dict(enumerate(sys.argv)).get(1, \"\\0\"))).exists():\n        direct = Path(sys.argv.pop(1))\n\n    # Scan files\n    if (direct.suffix == \".py\"):\n        files.append(direct)\n    elif direct.is_dir():\n        files.extend(direct.glob(\"*.py\"))\n    else:\n        files.extend(self.PROJECT.DIRECTORIES.PROJECTS.rglob(\"*.py\"))\n        files.extend(self.PROJECT.RESOURCES.SCENES.rglob(\"*.py\"))\n        files.extend(Path.cwd().glob(\"*.py\"))\n\n    # Add commands of all files, exit if none was sucessfully added\n    if (sum(map(lambda file: self.add_project(file, tag), files)) == 0):\n        log.warning(f\"No {self.PROJECT.APP_NAME} Projects found, searched in:\")\n        log.warning('\\n'.join(map(lambda file: f\"\u2022 {file}\", files)))\n        exit(1)\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenApp.regex","title":"<code>regex(tag: str) -&gt; re.Pattern</code>","text":"<p>Generates the self.regex for matching any valid Python class that contains \"tag\" on the inheritance, and its optional docstring on the next line</p> Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>def regex(self, tag: str) -&gt; re.Pattern:\n    \"\"\"Generates the self.regex for matching any valid Python class that contains \"tag\" on the\n    inheritance, and its optional docstring on the next line\"\"\"\n    return re.compile(\n        r\"^class\\s+(\\w+)\\s*\\(.*?(?:\" + tag + r\").*\\):\\s*(?:\\\"\\\"\\\"((?:\\n|.)*?)\\\"\\\"\\\")?\",\n        re.MULTILINE\n    )\n</code></pre>"},{"location":"broken/reference/core/brokenproject/#Core.BrokenProject.BrokenApp.add_project","title":"<code>add_project(python: Path, tag: str = 'Project') -&gt; bool</code>","text":"Source code in <code>Broken/Core/BrokenProject.py</code> Python<pre><code>def add_project(self, python: Path, tag: str=\"Project\") -&gt; bool:\n    if not python.exists():\n        return False\n\n    def run(file, name, code):\n        def run(ctx: Context):\n            # Note: Point of trust transfer to the file the user is running\n            exec(compile(code, file, \"exec\"), (namespace := {}))\n            namespace[name]().cli(*ctx.args)\n        return run\n\n    # Match all scenes and their optional docstrings\n    for match in self.regex(tag).finditer(code := python.read_text(encoding=\"utf-8\")):\n        class_name, docstring = match.groups()\n        self.typer.command(\n            target=run(python, class_name, code),\n            name=class_name.lower(),\n            help=(docstring or \"No description provided\"),\n            panel=f\"\ud83d\udce6 Projects at [bold]({python})[/bold]\",\n            add_help_option=False,\n            context=True,\n        )\n\n    return bool(self.typer.commands)\n</code></pre>"},{"location":"broken/reference/core/brokenresolution/","title":"BrokenResolution","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenresolution/#Core.BrokenResolution","title":"<code>Core.BrokenResolution</code>","text":""},{"location":"broken/reference/core/brokenresolution/#Core.BrokenResolution.BrokenResolution","title":"<code>Core.BrokenResolution.BrokenResolution</code>","text":"Source code in <code>Broken/Core/BrokenResolution.py</code> Python<pre><code>class BrokenResolution:\n\n    @staticmethod\n    def round_component(value: Number, *, scale: Number=1) -&gt; int:\n        return max(1, 2*round(scale*value/2))\n\n    @staticmethod\n    def round_resolution(width: Number, height: Number, *, scale: Number=1) -&gt; Tuple[int, int]:\n        return (BrokenResolution.round_component(width*scale), BrokenResolution.round_component(height*scale))\n\n    @staticmethod\n    def fit(\n        old: Tuple[int, int]=None,\n        new: Tuple[int, int]=None,\n        max: Tuple[int, int]=None,\n        scale: float=1.0,\n        ar: float=None,\n    ) -&gt; Tuple[int, int]:\n        \"\"\"Fit, Scale and optionally force Aspect Ratio on a base to a (un)limited target resolution\n\n        This method solves the following problem:\n            \"A window is at some initial size (ow, oh) and a resize was asked to (nw, nh); what\n            final resolution the window should be, optionally enforcing an aspect ratio (ar),\n            and limited by the monitor resolution (mw, mh)?\"\n\n        To which, the behavior is as follows in the two branches:\n            No aspect ratio (ar=None) is send:\n                - Returns the original resolution overrided by any new (nw, nh)\n\n            Aspect ratio (ar!=None) is send:\n                - If any of the new (nw, nh) is missing, find the other based on the aspect ratio\n                - Else, prioritize width changes, and downscale/upscale accordingly;\n                - Post-limits resolution to (mw, mh) by multiplying both components to max fit it\n\n        Notes\n        -----\n            - The resolution is rounded to the nearest multiple of 2, so FFmpeg is happy\n\n        Parameters\n        ----------\n        old\n            Old resolution\n        new\n            New resolution\n        max\n            Maximum resolution\n        scale\n            Scale factor\n        ar\n            Force aspect ratio, if any\n\n        Returns\n        -------\n        (int, int)\n            The new best-fit width and height\n        \"\"\"\n\n        # Unpack\n        old_width, old_height = (old or (None, None))\n        new_width, new_height = (new or (None, None))\n        max_width, max_height = (max or (None, None))\n\n        log.debug(f\"Fit resolution: ({old_width}, {old_height}) -&gt; ({new_width}, {new_height})^({max_width}, {max_height}), AR {ar}\")\n\n        # Force or keep either component\n        (width, height) = ((new_width or old_width), (new_height or old_height))\n\n        if not all((width, height)):\n            raise ValueError(\"Can't build a resolution with missing component(s): ({width}, {height})\")\n\n        if (ar is None):\n            pass\n\n        else:\n            # Build from width (W) or from height (H)\n            from_width  = (width, width/ar)\n            from_height = (height*ar, height)\n\n            # Pick the non missing component's\n            if (new_height is None):\n                (width, height) = from_width\n            elif (new_width is None):\n                (width, height) = from_height\n\n            # Based on upscale or downscale\n            elif (new_width != old_width):\n                (width, height) = from_width\n            elif (new_height != old_height):\n                (width, height) = from_height\n\n        # Limit the resolution to (mw, mh) bounding box and keep aspect ratio\n        # - The idea is to find the maximum reduce factor for either component so it normalizes\n        #   to the respective (mw, mh), and apply it to both components to scale down\n        if (ar is not None):\n            reduce = __builtins__[\"max\"](\n                width/(min(width, max_width or math.inf) or 1),\n                height/(min(height, max_height or math.inf) or 1)\n            ) or 1\n\n            width, height = (width/reduce, height/reduce)\n\n        else:\n            # Limit each component independently\n            width  = min(width,  max_width or math.inf)\n            height = min(height, max_height or math.inf)\n\n        return BrokenResolution.round_resolution(width=width, height=height, scale=scale)\n</code></pre>"},{"location":"broken/reference/core/brokenresolution/#Core.BrokenResolution.BrokenResolution.round_component","title":"<code>round_component(value: Number, *, scale: Number = 1) -&gt; int</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/BrokenResolution.py</code> Python<pre><code>@staticmethod\ndef round_component(value: Number, *, scale: Number=1) -&gt; int:\n    return max(1, 2*round(scale*value/2))\n</code></pre>"},{"location":"broken/reference/core/brokenresolution/#Core.BrokenResolution.BrokenResolution.round_resolution","title":"<code>round_resolution(width: Number, height: Number, *, scale: Number = 1) -&gt; Tuple[int, int]</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/BrokenResolution.py</code> Python<pre><code>@staticmethod\ndef round_resolution(width: Number, height: Number, *, scale: Number=1) -&gt; Tuple[int, int]:\n    return (BrokenResolution.round_component(width*scale), BrokenResolution.round_component(height*scale))\n</code></pre>"},{"location":"broken/reference/core/brokenresolution/#Core.BrokenResolution.BrokenResolution.fit","title":"<code>fit(old: Tuple[int, int] = None, new: Tuple[int, int] = None, max: Tuple[int, int] = None, scale: float = 1.0, ar: float = None) -&gt; Tuple[int, int]</code>  <code>staticmethod</code>","text":"<p>Fit, Scale and optionally force Aspect Ratio on a base to a (un)limited target resolution</p> This method solves the following problem <p>\"A window is at some initial size (ow, oh) and a resize was asked to (nw, nh); what final resolution the window should be, optionally enforcing an aspect ratio (ar), and limited by the monitor resolution (mw, mh)?\"</p> <p>To which, the behavior is as follows in the two branches:     No aspect ratio (ar=None) is send:         - Returns the original resolution overrided by any new (nw, nh)</p> Text Only<pre><code>Aspect ratio (ar!=None) is send:\n    - If any of the new (nw, nh) is missing, find the other based on the aspect ratio\n    - Else, prioritize width changes, and downscale/upscale accordingly;\n    - Post-limits resolution to (mw, mh) by multiplying both components to max fit it\n</code></pre>"},{"location":"broken/reference/core/brokenresolution/#Core.BrokenResolution.BrokenResolution.fit--notes","title":"Notes","text":"Text Only<pre><code>- The resolution is rounded to the nearest multiple of 2, so FFmpeg is happy\n</code></pre>"},{"location":"broken/reference/core/brokenresolution/#Core.BrokenResolution.BrokenResolution.fit--parameters","title":"Parameters","text":"<p>old     Old resolution new     New resolution max     Maximum resolution scale     Scale factor ar     Force aspect ratio, if any</p>"},{"location":"broken/reference/core/brokenresolution/#Core.BrokenResolution.BrokenResolution.fit--returns","title":"Returns","text":"<p>(int, int)     The new best-fit width and height</p> Source code in <code>Broken/Core/BrokenResolution.py</code> Python<pre><code>@staticmethod\ndef fit(\n    old: Tuple[int, int]=None,\n    new: Tuple[int, int]=None,\n    max: Tuple[int, int]=None,\n    scale: float=1.0,\n    ar: float=None,\n) -&gt; Tuple[int, int]:\n    \"\"\"Fit, Scale and optionally force Aspect Ratio on a base to a (un)limited target resolution\n\n    This method solves the following problem:\n        \"A window is at some initial size (ow, oh) and a resize was asked to (nw, nh); what\n        final resolution the window should be, optionally enforcing an aspect ratio (ar),\n        and limited by the monitor resolution (mw, mh)?\"\n\n    To which, the behavior is as follows in the two branches:\n        No aspect ratio (ar=None) is send:\n            - Returns the original resolution overrided by any new (nw, nh)\n\n        Aspect ratio (ar!=None) is send:\n            - If any of the new (nw, nh) is missing, find the other based on the aspect ratio\n            - Else, prioritize width changes, and downscale/upscale accordingly;\n            - Post-limits resolution to (mw, mh) by multiplying both components to max fit it\n\n    Notes\n    -----\n        - The resolution is rounded to the nearest multiple of 2, so FFmpeg is happy\n\n    Parameters\n    ----------\n    old\n        Old resolution\n    new\n        New resolution\n    max\n        Maximum resolution\n    scale\n        Scale factor\n    ar\n        Force aspect ratio, if any\n\n    Returns\n    -------\n    (int, int)\n        The new best-fit width and height\n    \"\"\"\n\n    # Unpack\n    old_width, old_height = (old or (None, None))\n    new_width, new_height = (new or (None, None))\n    max_width, max_height = (max or (None, None))\n\n    log.debug(f\"Fit resolution: ({old_width}, {old_height}) -&gt; ({new_width}, {new_height})^({max_width}, {max_height}), AR {ar}\")\n\n    # Force or keep either component\n    (width, height) = ((new_width or old_width), (new_height or old_height))\n\n    if not all((width, height)):\n        raise ValueError(\"Can't build a resolution with missing component(s): ({width}, {height})\")\n\n    if (ar is None):\n        pass\n\n    else:\n        # Build from width (W) or from height (H)\n        from_width  = (width, width/ar)\n        from_height = (height*ar, height)\n\n        # Pick the non missing component's\n        if (new_height is None):\n            (width, height) = from_width\n        elif (new_width is None):\n            (width, height) = from_height\n\n        # Based on upscale or downscale\n        elif (new_width != old_width):\n            (width, height) = from_width\n        elif (new_height != old_height):\n            (width, height) = from_height\n\n    # Limit the resolution to (mw, mh) bounding box and keep aspect ratio\n    # - The idea is to find the maximum reduce factor for either component so it normalizes\n    #   to the respective (mw, mh), and apply it to both components to scale down\n    if (ar is not None):\n        reduce = __builtins__[\"max\"](\n            width/(min(width, max_width or math.inf) or 1),\n            height/(min(height, max_height or math.inf) or 1)\n        ) or 1\n\n        width, height = (width/reduce, height/reduce)\n\n    else:\n        # Limit each component independently\n        width  = min(width,  max_width or math.inf)\n        height = min(height, max_height or math.inf)\n\n    return BrokenResolution.round_resolution(width=width, height=height, scale=scale)\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/","title":"BrokenScheduler","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler","title":"<code>Core.BrokenScheduler</code>","text":""},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.precise_sleep","title":"<code>Core.BrokenScheduler.precise_sleep(seconds: float, *, error: float = 0.001) -&gt; None</code>","text":"<p>A precise alternative of time.sleep(), low cpu near-end thread spin</p> Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def precise_sleep(seconds: float, *, error: float=0.001) -&gt; None:\n    \"\"\"A precise alternative of time.sleep(), low cpu near-end thread spin\"\"\"\n    start = time.perf_counter()\n\n    # Sleep close to the due time\n    if (ahead := max(0, seconds - error)):\n        time.sleep(ahead)\n    else:\n        return\n\n    # Spin the thread until the time is up (precise Sleep)\n    while (time.perf_counter() - start) &lt; seconds:\n        pass\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask","title":"<code>Core.BrokenScheduler.BrokenTask</code>","text":"<p>A BrokenScheduler's client dataclass</p> Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>@define\nclass BrokenTask:\n    \"\"\"A BrokenScheduler's client dataclass\"\"\"\n\n    # # Basic\n\n    task: Callable = None\n    \"\"\"Function callable to call every synchronization. Automatically sends a 'time' or 'dt'\n    argument if the function's signature contains it\"\"\"\n\n    args: List[Any] = field(factory=list, repr=False)\n    \"\"\"Method's positional arguments\"\"\"\n\n    kwargs: Dict[str, Any] = field(factory=dict, repr=False)\n    \"\"\"Method's keyword arguments\"\"\"\n\n    output: Any = field(default=None, repr=False)\n    \"\"\"Method's return value of the last call\"\"\"\n\n    context: Any = None\n    \"\"\"Context to use when calling task (with statement)\"\"\"\n\n    lock: Lock = None\n    \"\"\"Threading Lock to use when calling task (with statement)\"\"\"\n\n    enabled: bool = True\n    \"\"\"Whether to enable this client or not\"\"\"\n\n    once: bool = False\n    \"\"\"Client will be removed after next call\"\"\"\n\n    # # Synchronization\n\n    frequency: float = 60.0\n    \"\"\"Ideal frequency of task calls\"\"\"\n\n    frameskip: bool = True\n    \"\"\"Constant deltatime mode (False) or real deltatime mode (True)\"\"\"\n\n    freewheel: bool = False\n    \"\"\"\"Rendering\" mode, do not sleep on real time, exact virtual frametimes\"\"\"\n\n    precise: bool = False\n    \"\"\"Use precise time sleeping for near-perfect frametimes\"\"\"\n\n    # # Timing\n\n    started: float = Factory(lambda: time.absolute())\n    \"\"\"Time when client was started (initializes $now+started, value in now() seconds)\"\"\"\n\n    next_call: float = None\n    \"\"\"Next time to call task (initializes $now+next_call, value in now() seconds)\"\"\"\n\n    last_call: float = None\n    \"\"\"Last time task was called (initializes $now+last_call, value in now() seconds)\"\"\"\n\n    # # Flags\n    _time: bool = False\n    _dt: bool = False\n\n    def __attrs_post_init__(self):\n        signature = inspect.signature(self.task)\n        self._dt   = (\"dt\"   in signature.parameters)\n        self._time = (\"time\" in signature.parameters)\n\n        # Assign idealistic values for decoupled\n        if self.freewheel: self.started = time.zero\n        self.last_call = (self.last_call or self.started) - self.period\n        self.next_call = (self.next_call or self.started)\n\n        # Note: We could use numpy.float128 for the most frametime precision on the above..\n        #       .. But the Client code is smart enough to auto adjust itself to sync\n\n    # # Useful properties\n\n    @property\n    def fps(self) -&gt; float:\n        return self.frequency\n\n    @fps.setter\n    def fps(self, value: float):\n        self.frequency = value\n\n    @property\n    def period(self) -&gt; float:\n        return (1 / self.frequency)\n\n    @period.setter\n    def period(self, value: float):\n        self.frequency = (1 / value)\n\n    @property\n    def should_delete(self) -&gt; bool:\n        return self.once and (not self.enabled)\n\n    @property\n    def should_live(self) -&gt; bool:\n        return not self.should_delete\n\n    # # Sorting\n\n    def __lt__(self, other: Self) -&gt; bool:\n        if (self.once and not other.once):\n            return True\n        return self.next_call &lt; other.next_call\n\n    def __gt__(self, other: Self) -&gt; bool:\n        if (not self.once and other.once):\n            return True\n        return self.next_call &gt; other.next_call\n\n    # # Implementation\n\n    def next(self, block: bool=True) -&gt; Self:\n\n        # Time to wait for next call if block\n        wait = max(0, (self.next_call - time.absolute()))\n\n        if self.freewheel:\n            pass\n        elif block:\n            if self.precise:\n                time.precise_sleep(wait)\n            else:\n                time.sleep(wait)\n        elif wait &gt; 0:\n            return None\n\n        # The assumed instant the code below will run instantly\n        now = self.next_call if self.freewheel else time.absolute()\n        if self._dt:   self.kwargs[\"dt\"]   = (now - self.last_call)\n        if self._time: self.kwargs[\"time\"] = (now - self.started)\n        self.last_call = now\n\n        # We only \"skip\" frames when \\sum{dt_i} &gt; period\n        if self.frameskip:\n            self._dt = min(self._dt, self.period)\n\n        # Enter or not the given context, call task with args and kwargs\n        with (self.lock or contextlib.nullcontext()):\n            with (self.context or contextlib.nullcontext()):\n                self.output = self.task(*self.args, **self.kwargs)\n\n        # Find a future multiple of period\n        while self.next_call &lt;= now:\n            self.next_call += self.period\n\n        # (Disabled &amp;&amp; Once) clients gets deleted\n        self.enabled = not self.once\n        return self\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.task","title":"<code>task: Callable = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Function callable to call every synchronization. Automatically sends a 'time' or 'dt' argument if the function's signature contains it</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.args","title":"<code>args: List[Any] = field(factory=list, repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Method's positional arguments</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.kwargs","title":"<code>kwargs: Dict[str, Any] = field(factory=dict, repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Method's keyword arguments</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.output","title":"<code>output: Any = field(default=None, repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Method's return value of the last call</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.context","title":"<code>context: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Context to use when calling task (with statement)</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.lock","title":"<code>lock: Lock = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Threading Lock to use when calling task (with statement)</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.enabled","title":"<code>enabled: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to enable this client or not</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.once","title":"<code>once: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Client will be removed after next call</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.frequency","title":"<code>frequency: float = 60.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Ideal frequency of task calls</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.frameskip","title":"<code>frameskip: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant deltatime mode (False) or real deltatime mode (True)</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.freewheel","title":"<code>freewheel: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>\"Rendering\" mode, do not sleep on real time, exact virtual frametimes</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.precise","title":"<code>precise: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use precise time sleeping for near-perfect frametimes</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.started","title":"<code>started: float = Factory(lambda: time.absolute())</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Time when client was started (initializes $now+started, value in now() seconds)</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.next_call","title":"<code>next_call: float = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Next time to call task (initializes $now+next_call, value in now() seconds)</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.last_call","title":"<code>last_call: float = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Last time task was called (initializes $now+last_call, value in now() seconds)</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def __attrs_post_init__(self):\n    signature = inspect.signature(self.task)\n    self._dt   = (\"dt\"   in signature.parameters)\n    self._time = (\"time\" in signature.parameters)\n\n    # Assign idealistic values for decoupled\n    if self.freewheel: self.started = time.zero\n    self.last_call = (self.last_call or self.started) - self.period\n    self.next_call = (self.next_call or self.started)\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.fps","title":"<code>fps: float</code>  <code>property</code> <code>writable</code>","text":""},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.period","title":"<code>period: float</code>  <code>property</code> <code>writable</code>","text":""},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.should_delete","title":"<code>should_delete: bool</code>  <code>property</code>","text":""},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.should_live","title":"<code>should_live: bool</code>  <code>property</code>","text":""},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.__lt__","title":"<code>__lt__(other: Self) -&gt; bool</code>","text":"Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def __lt__(self, other: Self) -&gt; bool:\n    if (self.once and not other.once):\n        return True\n    return self.next_call &lt; other.next_call\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.__gt__","title":"<code>__gt__(other: Self) -&gt; bool</code>","text":"Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def __gt__(self, other: Self) -&gt; bool:\n    if (not self.once and other.once):\n        return True\n    return self.next_call &gt; other.next_call\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenTask.next","title":"<code>next(block: bool = True) -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def next(self, block: bool=True) -&gt; Self:\n\n    # Time to wait for next call if block\n    wait = max(0, (self.next_call - time.absolute()))\n\n    if self.freewheel:\n        pass\n    elif block:\n        if self.precise:\n            time.precise_sleep(wait)\n        else:\n            time.sleep(wait)\n    elif wait &gt; 0:\n        return None\n\n    # The assumed instant the code below will run instantly\n    now = self.next_call if self.freewheel else time.absolute()\n    if self._dt:   self.kwargs[\"dt\"]   = (now - self.last_call)\n    if self._time: self.kwargs[\"time\"] = (now - self.started)\n    self.last_call = now\n\n    # We only \"skip\" frames when \\sum{dt_i} &gt; period\n    if self.frameskip:\n        self._dt = min(self._dt, self.period)\n\n    # Enter or not the given context, call task with args and kwargs\n    with (self.lock or contextlib.nullcontext()):\n        with (self.context or contextlib.nullcontext()):\n            self.output = self.task(*self.args, **self.kwargs)\n\n    # Find a future multiple of period\n    while self.next_call &lt;= now:\n        self.next_call += self.period\n\n    # (Disabled &amp;&amp; Once) clients gets deleted\n    self.enabled = not self.once\n    return self\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenScheduler","title":"<code>Core.BrokenScheduler.BrokenScheduler</code>","text":"Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>@define\nclass BrokenScheduler:\n    clients: Deque[BrokenTask] = Factory(deque)\n\n    def append(self, client: BrokenTask) -&gt; BrokenTask:\n        \"\"\"Adds a client to the manager with immediate next call\"\"\"\n        self.clients.append(client)\n        return client\n\n    def new(self, task: Callable, *a, **k) -&gt; BrokenTask:\n        \"\"\"Wraps around BrokenVsync for convenience\"\"\"\n        return self.append(BrokenTask(task=task, *a, **k))\n\n    def once(self, task: Callable, *a, **k) -&gt; BrokenTask:\n        \"\"\"Wraps around BrokenVsync for convenience\"\"\"\n        return self.append(BrokenTask(task=task, *a, **k, once=True))\n\n    @property\n    def enabled_tasks(self) -&gt; Iterable[BrokenTask]:\n        for client in self.clients:\n            if client.enabled:\n                yield client\n\n    @property\n    def next_task(self) -&gt; Optional[BrokenTask]:\n        \"\"\"Returns the next client to be called\"\"\"\n        return min(self.enabled_tasks, default=None)\n\n    def _sanitize(self) -&gt; None:\n        \"\"\"Removes disabled 'once' clients\"\"\"\n        move = 0\n        # Optimization: Replace first N clients with valid ones, then pop remaining pointers\n        for client in self.clients:\n            if client.should_live:\n                self.clients[move] = client\n                move += 1\n        for _ in range(len(self.clients) - move):\n            self.clients.pop()\n\n    def next(self, block=True) -&gt; Optional[BrokenTask]:\n        if (client := self.next_task) is None:\n            return\n        try:\n            return client.next(block=block)\n        finally:\n            if client.should_delete:\n                self._sanitize()\n\n    def all_once(self) -&gt; None:\n        \"\"\"Calls all 'once' clients. Useful for @partial calls on the main thread\"\"\"\n        for client in self.clients:\n            if client.once:\n                client.next()\n        self._sanitize()\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenScheduler.clients","title":"<code>clients: Deque[BrokenTask] = Factory(deque)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenScheduler.append","title":"<code>append(client: BrokenTask) -&gt; BrokenTask</code>","text":"<p>Adds a client to the manager with immediate next call</p> Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def append(self, client: BrokenTask) -&gt; BrokenTask:\n    \"\"\"Adds a client to the manager with immediate next call\"\"\"\n    self.clients.append(client)\n    return client\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenScheduler.new","title":"<code>new(task: Callable, *a, **k) -&gt; BrokenTask</code>","text":"<p>Wraps around BrokenVsync for convenience</p> Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def new(self, task: Callable, *a, **k) -&gt; BrokenTask:\n    \"\"\"Wraps around BrokenVsync for convenience\"\"\"\n    return self.append(BrokenTask(task=task, *a, **k))\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenScheduler.once","title":"<code>once(task: Callable, *a, **k) -&gt; BrokenTask</code>","text":"<p>Wraps around BrokenVsync for convenience</p> Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def once(self, task: Callable, *a, **k) -&gt; BrokenTask:\n    \"\"\"Wraps around BrokenVsync for convenience\"\"\"\n    return self.append(BrokenTask(task=task, *a, **k, once=True))\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenScheduler.enabled_tasks","title":"<code>enabled_tasks: Iterable[BrokenTask]</code>  <code>property</code>","text":""},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenScheduler.next_task","title":"<code>next_task: Optional[BrokenTask]</code>  <code>property</code>","text":"<p>Returns the next client to be called</p>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenScheduler.next","title":"<code>next(block=True) -&gt; Optional[BrokenTask]</code>","text":"Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def next(self, block=True) -&gt; Optional[BrokenTask]:\n    if (client := self.next_task) is None:\n        return\n    try:\n        return client.next(block=block)\n    finally:\n        if client.should_delete:\n            self._sanitize()\n</code></pre>"},{"location":"broken/reference/core/brokenscheduler/#Core.BrokenScheduler.BrokenScheduler.all_once","title":"<code>all_once() -&gt; None</code>","text":"<p>Calls all 'once' clients. Useful for @partial calls on the main thread</p> Source code in <code>Broken/Core/BrokenScheduler.py</code> Python<pre><code>def all_once(self) -&gt; None:\n    \"\"\"Calls all 'once' clients. Useful for @partial calls on the main thread\"\"\"\n    for client in self.clients:\n        if client.once:\n            client.next()\n    self._sanitize()\n</code></pre>"},{"location":"broken/reference/core/brokenspinner/","title":"BrokenSpinner","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner","title":"<code>Core.BrokenSpinner</code>","text":""},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.Spinners","title":"<code>Core.BrokenSpinner.Spinners</code>","text":"Source code in <code>Broken/Core/BrokenSpinner.py</code> Python<pre><code>class Spinners:\n    Simple: str = \"\u280b\u2819\u2839\u2838\u283c\u2834\u2826\u2827\u2807\u280f\"\n</code></pre>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.Spinners.Simple","title":"<code>Simple: str = '\u280b\u2819\u2839\u2838\u283c\u2834\u2826\u2827\u2807\u280f'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner","title":"<code>Core.BrokenSpinner.BrokenSpinner</code>","text":"Source code in <code>Broken/Core/BrokenSpinner.py</code> Python<pre><code>@define\nclass BrokenSpinner:\n\n    text: str = \"\"\n    \"\"\"The text to display next to the spinner. Also defines if the spinner is active\"\"\"\n\n    spinner: Union[str, List[str]] = Spinners.Simple\n    \"\"\"A Sequence or list of printable objects to use as the spinner\"\"\"\n\n    framerate: float = 10\n    \"\"\"Update rate of the spinner\"\"\"\n\n    _index: int = 0\n    \"\"\"Current index of the spinner\"\"\"\n\n    @property\n    def frametime(self) -&gt; float:\n        return 1/self.framerate\n\n    # Singleton to save spawning multiple threads\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, \"_instance\"):\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __attrs_post_init__(self):\n        Thread(target=self._worker, daemon=True).start()\n\n    def start(self, text: str) -&gt; Self:\n        self.text = text\n        return self\n\n    def stop(self) -&gt; Self:\n        self.text = \"\"\n        while self._spinning:\n            time.sleep(0.01)\n        return self\n\n    def __enter__(self) -&gt; Self:\n        return self\n\n    def __exit__(self, a, b, c) -&gt; None:\n        self.stop()\n\n    def _write(self, text: str=\"\") -&gt; None:\n        \"\"\"Clean current stdout line and flush write new text\"\"\"\n        sys.stdout.write(f\"\\r\\033[K{text}\")\n        sys.stdout.flush()\n\n    _spinning: bool = False\n\n    def _worker(self):\n        while True:\n\n            # Get and write next character\n            while bool(self.text):\n                self._spinning = True\n                self._index += 1\n                char = self.spinner[self._index % len(self.spinner)]\n                self._write(f\"{char} {self.text}\")\n\n                # Sleep for a frametime, but break if there's no text\n                start = time.perf_counter()\n\n                while bool(self.text) and (time.perf_counter() - start &lt; self.frametime):\n                    time.sleep(0.01/self.framerate)\n\n            # Cleanup\n            if self._spinning:\n                self._write()\n\n            self._spinning = False\n            time.sleep(0.01)\n</code></pre>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.text","title":"<code>text: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The text to display next to the spinner. Also defines if the spinner is active</p>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.spinner","title":"<code>spinner: Union[str, List[str]] = Spinners.Simple</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A Sequence or list of printable objects to use as the spinner</p>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.framerate","title":"<code>framerate: float = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Update rate of the spinner</p>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.frametime","title":"<code>frametime: float</code>  <code>property</code>","text":""},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.__new__","title":"<code>__new__(*args, **kwargs)</code>","text":"Source code in <code>Broken/Core/BrokenSpinner.py</code> Python<pre><code>def __new__(cls, *args, **kwargs):\n    if not hasattr(cls, \"_instance\"):\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"Source code in <code>Broken/Core/BrokenSpinner.py</code> Python<pre><code>def __attrs_post_init__(self):\n    Thread(target=self._worker, daemon=True).start()\n</code></pre>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.start","title":"<code>start(text: str) -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenSpinner.py</code> Python<pre><code>def start(self, text: str) -&gt; Self:\n    self.text = text\n    return self\n</code></pre>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.stop","title":"<code>stop() -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenSpinner.py</code> Python<pre><code>def stop(self) -&gt; Self:\n    self.text = \"\"\n    while self._spinning:\n        time.sleep(0.01)\n    return self\n</code></pre>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.__enter__","title":"<code>__enter__() -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenSpinner.py</code> Python<pre><code>def __enter__(self) -&gt; Self:\n    return self\n</code></pre>"},{"location":"broken/reference/core/brokenspinner/#Core.BrokenSpinner.BrokenSpinner.__exit__","title":"<code>__exit__(a, b, c) -&gt; None</code>","text":"Source code in <code>Broken/Core/BrokenSpinner.py</code> Python<pre><code>def __exit__(self, a, b, c) -&gt; None:\n    self.stop()\n</code></pre>"},{"location":"broken/reference/core/brokenthread/","title":"BrokenThread","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread","title":"<code>Core.BrokenThread</code>","text":""},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThreadPool","title":"<code>Core.BrokenThread.BrokenThreadPool</code>","text":"Source code in <code>Broken/Core/BrokenThread.py</code> Python<pre><code>@define\nclass BrokenThreadPool:\n    threads: List[Thread] = []\n    max: int = 1\n\n    @property\n    def alive(self) -&gt; List[Thread]:\n        return [thread for thread in self.threads if thread.is_alive()]\n\n    @property\n    def n_alive(self) -&gt; int:\n        return len(self.alive)\n\n    def sanitize(self) -&gt; None:\n        self.threads = self.alive\n\n    def append(self, thread: Thread, wait: float=0.01) -&gt; Thread:\n        while self.n_alive &gt;= self.max:\n            time.sleep(wait)\n        self.sanitize()\n        self.threads.append(thread)\n        return thread\n\n    def join(self) -&gt; None:\n        for thread in self.threads:\n            thread.join()\n</code></pre>"},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThreadPool.threads","title":"<code>threads: List[Thread] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThreadPool.max","title":"<code>max: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThreadPool.alive","title":"<code>alive: List[Thread]</code>  <code>property</code>","text":""},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThreadPool.n_alive","title":"<code>n_alive: int</code>  <code>property</code>","text":""},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThreadPool.sanitize","title":"<code>sanitize() -&gt; None</code>","text":"Source code in <code>Broken/Core/BrokenThread.py</code> Python<pre><code>def sanitize(self) -&gt; None:\n    self.threads = self.alive\n</code></pre>"},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThreadPool.append","title":"<code>append(thread: Thread, wait: float = 0.01) -&gt; Thread</code>","text":"Source code in <code>Broken/Core/BrokenThread.py</code> Python<pre><code>def append(self, thread: Thread, wait: float=0.01) -&gt; Thread:\n    while self.n_alive &gt;= self.max:\n        time.sleep(wait)\n    self.sanitize()\n    self.threads.append(thread)\n    return thread\n</code></pre>"},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThreadPool.join","title":"<code>join() -&gt; None</code>","text":"Source code in <code>Broken/Core/BrokenThread.py</code> Python<pre><code>def join(self) -&gt; None:\n    for thread in self.threads:\n        thread.join()\n</code></pre>"},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThread","title":"<code>Core.BrokenThread.BrokenThread</code>","text":"Source code in <code>Broken/Core/BrokenThread.py</code> Python<pre><code>@define\nclass BrokenThread:\n    pools = {}\n\n    def __new__(cls, *args, **kwargs) -&gt; Thread:\n        return cls.new(*args, **kwargs)\n\n    @staticmethod\n    def pool(name: str) -&gt; BrokenThreadPool:\n        return BrokenThread.pools.setdefault(name, BrokenThreadPool())\n\n    @staticmethod\n    def join_all_pools() -&gt; None:\n        for pool in BrokenThread.pools.values():\n            pool.join()\n\n    @staticmethod\n    def new(\n        target: Callable,\n        *args: List[Any],\n        start: bool=True,\n        join: bool=False,\n        loop: bool=False,\n        period: float=0.0,\n        pool: str=None,\n        max: int=10,\n        daemon: bool=False,\n        locals: bool=False,\n        self: bool=False,\n        **kwargs: Dict[str, Any],\n    ) -&gt; Thread:\n        \"\"\"\n        Create a thread on a callable, yeet whatever you think it works\n        \u2022 Support for a basic Thread Pool, why no native way?\n\n        Args:\n            target: The function to call, consider using functools.partial or this kwargs\n            args:   Arguments to pass to the function (positional, unnamed)\n            kwargs: Keyword arguments to pass to the function\n            start:  Start the thread immediately after creation\n            join:   Wait for the thread to finish after creation\n            loop:   Wrap the target callable in a loop\n            period: Time in seconds to wait between calls in loop=True\n            pool:   Name of the pool to append the thread to, see BrokenThreadPool\n            max:    Maximum threads in the pool\n            daemon: When the main thread exits, daemon threads are also terminated\n\n        Advanced:\n            locals:   Whether to pass the current scope locals to the callable or not\n            self:     Include \"self\" in the locals if locals=True\n\n        Returns:\n            The created Thread object\n        \"\"\"\n\n        # Update kwargs with locals\n        if locals: kwargs.update(last_locals(level=2, self=self))\n        the_target = target\n\n        # Wrap the callback in a loop\n        @functools.wraps(target)\n        def looped(*args, **kwargs):\n            while True:\n                target(*args, **kwargs)\n                time.sleep(period)\n        the_target = (looped if loop else the_target)\n\n        # Create Thread object\n        parallel = Thread(\n            target=the_target,\n            daemon=daemon,\n            args=args,\n            kwargs=kwargs\n        )\n\n        # Maybe wait for the pool to be free\n        if pool and (pool := BrokenThread.pools.setdefault(pool, BrokenThreadPool())):\n            pool.max = max\n            pool.append(parallel)\n        if start:\n            parallel.start()\n        if join and start:\n            parallel.join()\n        return parallel\n</code></pre>"},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThread.pools","title":"<code>pools = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThread.__new__","title":"<code>__new__(*args, **kwargs) -&gt; Thread</code>","text":"Source code in <code>Broken/Core/BrokenThread.py</code> Python<pre><code>def __new__(cls, *args, **kwargs) -&gt; Thread:\n    return cls.new(*args, **kwargs)\n</code></pre>"},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThread.pool","title":"<code>pool(name: str) -&gt; BrokenThreadPool</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/BrokenThread.py</code> Python<pre><code>@staticmethod\ndef pool(name: str) -&gt; BrokenThreadPool:\n    return BrokenThread.pools.setdefault(name, BrokenThreadPool())\n</code></pre>"},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThread.join_all_pools","title":"<code>join_all_pools() -&gt; None</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/BrokenThread.py</code> Python<pre><code>@staticmethod\ndef join_all_pools() -&gt; None:\n    for pool in BrokenThread.pools.values():\n        pool.join()\n</code></pre>"},{"location":"broken/reference/core/brokenthread/#Core.BrokenThread.BrokenThread.new","title":"<code>new(target: Callable, *args: List[Any], start: bool = True, join: bool = False, loop: bool = False, period: float = 0.0, pool: str = None, max: int = 10, daemon: bool = False, locals: bool = False, self: bool = False, **kwargs: Dict[str, Any]) -&gt; Thread</code>  <code>staticmethod</code>","text":"<p>Create a thread on a callable, yeet whatever you think it works \u2022 Support for a basic Thread Pool, why no native way?</p> <p>Parameters:</p> <ul> <li> <code>target</code>             (<code>Callable</code>)         \u2013          <p>The function to call, consider using functools.partial or this kwargs</p> </li> <li> <code>args</code>             (<code>List[Any]</code>, default:                 <code>()</code> )         \u2013          <p>Arguments to pass to the function (positional, unnamed)</p> </li> <li> <code>kwargs</code>             (<code>Dict[str, Any]</code>, default:                 <code>{}</code> )         \u2013          <p>Keyword arguments to pass to the function</p> </li> <li> <code>start</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Start the thread immediately after creation</p> </li> <li> <code>join</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Wait for the thread to finish after creation</p> </li> <li> <code>loop</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Wrap the target callable in a loop</p> </li> <li> <code>period</code>             (<code>float</code>, default:                 <code>0.0</code> )         \u2013          <p>Time in seconds to wait between calls in loop=True</p> </li> <li> <code>pool</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>Name of the pool to append the thread to, see BrokenThreadPool</p> </li> <li> <code>max</code>             (<code>int</code>, default:                 <code>10</code> )         \u2013          <p>Maximum threads in the pool</p> </li> <li> <code>daemon</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>When the main thread exits, daemon threads are also terminated</p> </li> </ul> Advanced <p>locals:   Whether to pass the current scope locals to the callable or not self:     Include \"self\" in the locals if locals=True</p> <p>Returns:</p> <ul> <li> <code>Thread</code>         \u2013          <p>The created Thread object</p> </li> </ul> Source code in <code>Broken/Core/BrokenThread.py</code> Python<pre><code>@staticmethod\ndef new(\n    target: Callable,\n    *args: List[Any],\n    start: bool=True,\n    join: bool=False,\n    loop: bool=False,\n    period: float=0.0,\n    pool: str=None,\n    max: int=10,\n    daemon: bool=False,\n    locals: bool=False,\n    self: bool=False,\n    **kwargs: Dict[str, Any],\n) -&gt; Thread:\n    \"\"\"\n    Create a thread on a callable, yeet whatever you think it works\n    \u2022 Support for a basic Thread Pool, why no native way?\n\n    Args:\n        target: The function to call, consider using functools.partial or this kwargs\n        args:   Arguments to pass to the function (positional, unnamed)\n        kwargs: Keyword arguments to pass to the function\n        start:  Start the thread immediately after creation\n        join:   Wait for the thread to finish after creation\n        loop:   Wrap the target callable in a loop\n        period: Time in seconds to wait between calls in loop=True\n        pool:   Name of the pool to append the thread to, see BrokenThreadPool\n        max:    Maximum threads in the pool\n        daemon: When the main thread exits, daemon threads are also terminated\n\n    Advanced:\n        locals:   Whether to pass the current scope locals to the callable or not\n        self:     Include \"self\" in the locals if locals=True\n\n    Returns:\n        The created Thread object\n    \"\"\"\n\n    # Update kwargs with locals\n    if locals: kwargs.update(last_locals(level=2, self=self))\n    the_target = target\n\n    # Wrap the callback in a loop\n    @functools.wraps(target)\n    def looped(*args, **kwargs):\n        while True:\n            target(*args, **kwargs)\n            time.sleep(period)\n    the_target = (looped if loop else the_target)\n\n    # Create Thread object\n    parallel = Thread(\n        target=the_target,\n        daemon=daemon,\n        args=args,\n        kwargs=kwargs\n    )\n\n    # Maybe wait for the pool to be free\n    if pool and (pool := BrokenThread.pools.setdefault(pool, BrokenThreadPool())):\n        pool.max = max\n        pool.append(parallel)\n    if start:\n        parallel.start()\n    if join and start:\n        parallel.join()\n    return parallel\n</code></pre>"},{"location":"broken/reference/core/brokentorch/","title":"BrokenTorch","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokentorch/#Core.BrokenTorch","title":"<code>Core.BrokenTorch</code>","text":""},{"location":"broken/reference/core/brokentorch/#Core.BrokenTorch.TorchFlavor","title":"<code>Core.BrokenTorch.TorchFlavor</code>","text":"Source code in <code>Broken/Core/BrokenTorch.py</code> Python<pre><code>class TorchFlavor(BrokenEnum):\n    CPU   = \"2.3.1+cpu@cpu\"\n    CUDA  = \"2.3.1+cu118@cuda\"\n    ROCM  = \"2.3.1+rocm6.0@rocm\"\n    MACOS = \"2.3.1+cpu@mac\"\n</code></pre>"},{"location":"broken/reference/core/brokentorch/#Core.BrokenTorch.TorchFlavor.CPU","title":"<code>CPU = '2.3.1+cpu@cpu'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokentorch/#Core.BrokenTorch.TorchFlavor.CUDA","title":"<code>CUDA = '2.3.1+cu118@cuda'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokentorch/#Core.BrokenTorch.TorchFlavor.ROCM","title":"<code>ROCM = '2.3.1+rocm6.0@rocm'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokentorch/#Core.BrokenTorch.TorchFlavor.MACOS","title":"<code>MACOS = '2.3.1+cpu@mac'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokentorch/#Core.BrokenTorch.BrokenTorch","title":"<code>Core.BrokenTorch.BrokenTorch</code>","text":"<p>The Bane of my Existence and the SSD Killer - Packaging PyTorch</p> Source code in <code>Broken/Core/BrokenTorch.py</code> Python<pre><code>class BrokenTorch:\n    \"\"\"\n    The Bane of my Existence and the SSD Killer - Packaging PyTorch\n    \"\"\"\n\n    @staticmethod\n    def install():\n        if os.getenv(\"SKIP_TORCH\", \"0\") == \"1\":\n            return\n\n        import site\n        current_flavor = None\n\n        # Try getting current installed flavor, if any, without importing torch\n        # Note: Reversed as Windows lists system first, and we might have multiple on Docker\n        for site_packages in map(Path, reversed(site.getsitepackages())):\n            if (torch_version := (site_packages/\"torch\"/\"version.py\")).exists():\n                exec(torch_version.read_text(), namespace := {})\n                current_flavor = namespace[\"__version__\"].split(\"+\")[1]\n                break\n\n        # Workaround (#pyapp): Until we can send envs to PyAapp, do this monsterous hack\n        if Broken.PYAPP:\n            version_flavor = os.getenv(\"PYAPP_COMMAND_NAME\", \"\")\n            if (\"+\" not in version_flavor):\n                return None\n\n        # Development mode: No PyTorch was found\n        elif (current_flavor is None) or (os.getenv(\"MANAGE_TORCH\", \"0\") == \"1\"):\n            from rich.prompt import Prompt\n            log.warning(\"\")\n\n            if BrokenPlatform.OnMacOS:\n                version_flavor = TorchFlavor.MACOS\n            else:\n                log.warning(\"\\n\".join((\n                    \"This project requires PyTorch, but it was not found\",\n                    \"\u2022 Checked all site.getsitepackages() locations\",\n                    \"\",\n                    \"Check Hardware/Platform availability at:\",\n                    \"\u2022 https://pytorch.org/get-started/locally\",\n                    \"\u2022 https://brokensrc.dev/special/pytorch\",\n                    \"\",\n                    \"As a rule of thumb:\",\n                    \"\u2022 [royal_blue1](Windows + Linux)[/royal_blue1] NVIDIA GPU (&gt;= GTX 700): 'cuda'\",\n                    \"\u2022 [royal_blue1](Linux)[/royal_blue1] AMD GPU (&gt;= Radeon RX 5000): 'rocm'\",\n                    \"\u2022 [royal_blue1](Other)[/royal_blue1] Intel ARC, No discrete GPU: 'cpu'\",\n                    \"\",\n                    \"Tip: You can use 'SKIP_TORCH=1' to bypass this check next time\",\n                    \"Tip: You can use 'MANAGE_TORCH=1' to get back here next time\",\n                    \"Tip: Set 'HSA_OVERRIDE_GFX_VERSION=10.3.0' for RX 5000 Series\"\n                ))),\n                try:\n                    version_flavor = Prompt.ask(\n                        \"\\n:: What PyTorch flavor do you want to install?\\n\\n\",\n                        choices=[f\"{flavor.name.lower()}\" for flavor in TorchFlavor if flavor != TorchFlavor.MACOS],\n                        default=\"cuda\"\n                    )\n                    print()\n                except KeyboardInterrupt:\n                    exit(0)\n        else:\n            return\n\n        # Must be a valid Enum item of TorchFlavor\n        if not (version_flavor := TorchFlavor.get(version_flavor)):\n            raise ValueError(f\"Invalid PyTorch Flavor ({version_flavor})\")\n\n        # Remove the @ prefix for unique enums, get version and /whl/${flavor}\n        version, flavor = version_flavor.value.split(\"@\")[0].split(\"+\")\n\n        # If flavors mismatch, install the correct one\n        if (current_flavor != flavor):\n            log.info(f\"Installing PyTorch Flavor ({version_flavor}), current is ({current_flavor})\")\n            PIP = (sys.executable, \"-m\", \"uv\", \"pip\")\n            source_url = f\"https://download.pytorch.org/whl/{flavor}\"\n            shell(PIP, \"uninstall\", \"torch\", \"--quiet\")\n            shell(PIP, \"install\", f\"torch=={version}+{flavor}\", \"torchvision\", \"--index-url\", source_url)\n            shell(PIP, \"install\", \"transformers\")\n        else:\n            log.info(f\"PyTorch Flavor ({version_flavor}) already installed\")\n</code></pre>"},{"location":"broken/reference/core/brokentorch/#Core.BrokenTorch.BrokenTorch.install","title":"<code>install()</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/BrokenTorch.py</code> Python<pre><code>@staticmethod\ndef install():\n    if os.getenv(\"SKIP_TORCH\", \"0\") == \"1\":\n        return\n\n    import site\n    current_flavor = None\n\n    # Try getting current installed flavor, if any, without importing torch\n    # Note: Reversed as Windows lists system first, and we might have multiple on Docker\n    for site_packages in map(Path, reversed(site.getsitepackages())):\n        if (torch_version := (site_packages/\"torch\"/\"version.py\")).exists():\n            exec(torch_version.read_text(), namespace := {})\n            current_flavor = namespace[\"__version__\"].split(\"+\")[1]\n            break\n\n    # Workaround (#pyapp): Until we can send envs to PyAapp, do this monsterous hack\n    if Broken.PYAPP:\n        version_flavor = os.getenv(\"PYAPP_COMMAND_NAME\", \"\")\n        if (\"+\" not in version_flavor):\n            return None\n\n    # Development mode: No PyTorch was found\n    elif (current_flavor is None) or (os.getenv(\"MANAGE_TORCH\", \"0\") == \"1\"):\n        from rich.prompt import Prompt\n        log.warning(\"\")\n\n        if BrokenPlatform.OnMacOS:\n            version_flavor = TorchFlavor.MACOS\n        else:\n            log.warning(\"\\n\".join((\n                \"This project requires PyTorch, but it was not found\",\n                \"\u2022 Checked all site.getsitepackages() locations\",\n                \"\",\n                \"Check Hardware/Platform availability at:\",\n                \"\u2022 https://pytorch.org/get-started/locally\",\n                \"\u2022 https://brokensrc.dev/special/pytorch\",\n                \"\",\n                \"As a rule of thumb:\",\n                \"\u2022 [royal_blue1](Windows + Linux)[/royal_blue1] NVIDIA GPU (&gt;= GTX 700): 'cuda'\",\n                \"\u2022 [royal_blue1](Linux)[/royal_blue1] AMD GPU (&gt;= Radeon RX 5000): 'rocm'\",\n                \"\u2022 [royal_blue1](Other)[/royal_blue1] Intel ARC, No discrete GPU: 'cpu'\",\n                \"\",\n                \"Tip: You can use 'SKIP_TORCH=1' to bypass this check next time\",\n                \"Tip: You can use 'MANAGE_TORCH=1' to get back here next time\",\n                \"Tip: Set 'HSA_OVERRIDE_GFX_VERSION=10.3.0' for RX 5000 Series\"\n            ))),\n            try:\n                version_flavor = Prompt.ask(\n                    \"\\n:: What PyTorch flavor do you want to install?\\n\\n\",\n                    choices=[f\"{flavor.name.lower()}\" for flavor in TorchFlavor if flavor != TorchFlavor.MACOS],\n                    default=\"cuda\"\n                )\n                print()\n            except KeyboardInterrupt:\n                exit(0)\n    else:\n        return\n\n    # Must be a valid Enum item of TorchFlavor\n    if not (version_flavor := TorchFlavor.get(version_flavor)):\n        raise ValueError(f\"Invalid PyTorch Flavor ({version_flavor})\")\n\n    # Remove the @ prefix for unique enums, get version and /whl/${flavor}\n    version, flavor = version_flavor.value.split(\"@\")[0].split(\"+\")\n\n    # If flavors mismatch, install the correct one\n    if (current_flavor != flavor):\n        log.info(f\"Installing PyTorch Flavor ({version_flavor}), current is ({current_flavor})\")\n        PIP = (sys.executable, \"-m\", \"uv\", \"pip\")\n        source_url = f\"https://download.pytorch.org/whl/{flavor}\"\n        shell(PIP, \"uninstall\", \"torch\", \"--quiet\")\n        shell(PIP, \"install\", f\"torch=={version}+{flavor}\", \"torchvision\", \"--index-url\", source_url)\n        shell(PIP, \"install\", \"transformers\")\n    else:\n        log.info(f\"PyTorch Flavor ({version_flavor}) already installed\")\n</code></pre>"},{"location":"broken/reference/core/brokentyper/","title":"BrokenTyper","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper","title":"<code>Core.BrokenTyper</code>","text":""},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.console","title":"<code>Core.BrokenTyper.console = get_console()</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper","title":"<code>Core.BrokenTyper.BrokenTyper</code>","text":"<p>Yet another Typer wrapper, with goodies</p> Source code in <code>Broken/Core/BrokenTyper.py</code> Python<pre><code>@define\nclass BrokenTyper:\n    \"\"\"Yet another Typer wrapper, with goodies\"\"\"\n    description: str = \"\"\n\n    app: typer.Typer = None\n    \"\"\"The main managed typer.Typer instance\"\"\"\n\n    chain: bool = False\n    \"\"\"Same as Typer.chain\"\"\"\n\n    commands: Set[str] = Factory(set)\n    \"\"\"List of known commands\"\"\"\n\n    default: str = None\n    \"\"\"Default command to run if none is provided\"\"\"\n\n    repl: bool = False\n    \"\"\"If True, will run a REPL instead of a command\"\"\"\n\n    help_option: bool = False\n\n    epilog: str = (\n        f\"\u2022 Made with [red]:heart:[/red] by [green][link=https://github.com/Tremeschin]Tremeschin[/link][/green] [yellow]v{Broken.VERSION}[/yellow]\\n\\n\"\n        \"\u2192 [italic grey53]Consider [blue][link=https://brokensrc.dev/about/sponsors/]Sponsoring[/link][/blue] my work[/italic grey53]\")\n\n    def __attrs_post_init__(self):\n        self.app = typer.Typer(\n            add_help_option=self.help_option,\n            pretty_exceptions_enable=False,\n            no_args_is_help=True,\n            add_completion=False,\n            rich_markup_mode=\"rich\",\n            chain=self.chain,\n            epilog=self.epilog,\n        )\n\n    _panel: str = None\n\n    @contextlib.contextmanager\n    def panel(self, name: str) -&gt; Generator[None, None, None]:\n        try:\n            self._panel = name\n            yield\n        finally:\n            self._panel = None\n\n    def command(self,\n        target: Union[Callable, BaseModel],\n        help: str=None,\n        add_help_option: bool=True,\n        naih: bool=False,\n        name: str=None,\n        context: bool=True,\n        default: bool=False,\n        panel: str=None,\n        post: Callable=None,\n        **kwargs,\n    ) -&gt; None:\n\n        # Command must be implemented\n        if getattr(target, \"__isabstractmethod__\", False):\n            return\n\n        # Convert pydantic to a wrapper with same signature\n        _class = (target if isinstance(target, type) else target.__class__)\n        _instance = (target() if isinstance(target, type) else target)\n\n        if issubclass(_class, BaseModel):\n            target = pydantic_cli(instance=_instance, post=post)\n            name = (name or _class.__name__)\n            naih = True # (Complex command)\n        else:\n            name = (name or target.__name__)\n\n        # Add to known or default commands, create it\n        name = name.replace(\"_\", \"-\").lower()\n        self.default = (name if default else self.default)\n        self.commands.add(name)\n        self.app.command(name=name,\n            help=(help or target.__doc__),\n            add_help_option=add_help_option,\n            no_args_is_help=naih,\n            rich_help_panel=(panel or self._panel),\n            context_settings=dict(\n                allow_extra_args=True,\n                ignore_unknown_options=True,\n            ) if context else None,\n            **kwargs,\n        )(target)\n\n    @property\n    def _repl(self) -&gt; bool:\n        BYPASS = (os.getenv(\"REPL\", \"1\") == \"0\")\n        return (self.repl and not BYPASS)\n\n    def __call__(self, *args: Iterable[Any]) -&gt; None:\n        self.app.info.help = (self.description or \"No help provided\")\n        args = (flatten(args) or sys.argv[1:])\n\n        for i in itertools.count():\n\n            # On subsequent runs, prompt for command\n            if (self._repl) and (i &gt; 0):\n                try:\n                    args = shlex.split(typer.prompt(\n                        text=\"\",\n                        prompt_suffix=\"\u276f\",\n                        show_default=False,\n                        default=\"\"\n                    ))\n                except click.exceptions.Abort:\n                    log.trace(\"BrokenTyper exit KeyboardInterrupt\")\n                    break\n\n            # Insert default command if none\n            if self.default and not bool(args):\n                args.insert(0, self.default)\n\n            try:\n                # Safety: Flat cast everything to str\n                self.app(list(map(str, flatten(args))))\n            except SystemExit:\n                log.trace(\"Skipping SystemExit on BrokenTyper\")\n            except KeyboardInterrupt:\n                log.success(\"BrokenTyper exit KeyboardInterrupt\")\n\n            # Exit out non-repl mode\n            if (not self._repl):\n                break\n\n            # Some action was taken, like 'depthflow main -o ./video.mp4'\n            if (i == 0) and bool(args):\n                break\n\n            # Pretty welcome message on the first 'empty' run\n            if (i == 0):\n                console.print(Panel(\n                    title=\"( \ud83d\udd34\ud83d\udfe1\ud83d\udfe2 ) Welcome to the Interactive Shell mode for Releases \ud83d\ude80\",\n                    title_align=\"left\",\n                    border_style=\"bold grey42\",\n                    expand=False,\n                    renderable=Group(\n                        Text.from_markup(\n                            \"\\nHere's your chance to [royal_blue1]run commands on a basic shell[/royal_blue1], interactively\\n\\n\"\n                            \"&gt; This mode is [royal_blue1]Experimental[/royal_blue1] and projects might not work as expected\\n\\n\"\n                            \"\u2022 Preferably run the projects on a [royal_blue1]Terminal[/royal_blue1] as [spring_green1]./program.exe (args)[/spring_green1]\\n\"\n                            \"\u2022 You can skip this shell mode with [spring_green1]'REPL=0'[/spring_green1] environment var\\n\"\n                        ), Panel(\n                                \"\u2022 Run [spring_green1]'--help'[/spring_green1] or press [spring_green1]'Enter'[/spring_green1] for a command list [bold bright_black](seen above)[/bold bright_black]\\n\"\n                            \"\u2022 Press [spring_green1]'CTRL+C'[/spring_green1] to exit this shell [bold bright_black](or close the Terminal)[/bold bright_black]\",\n                            title=\"Tips\",\n                            border_style=\"green\"\n                        )\n                    ),\n                ))\n\n            # The args were \"consumed\"\n            args = []\n</code></pre>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.app","title":"<code>app: typer.Typer = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The main managed typer.Typer instance</p>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.chain","title":"<code>chain: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Same as Typer.chain</p>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.commands","title":"<code>commands: Set[str] = Factory(set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of known commands</p>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.default","title":"<code>default: str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default command to run if none is provided</p>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.repl","title":"<code>repl: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, will run a REPL instead of a command</p>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.help_option","title":"<code>help_option: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.epilog","title":"<code>epilog: str = f'\u2022 Made with [red]:heart:[/red] by [green][link=https://github.com/Tremeschin]Tremeschin[/link][/green] [yellow]v{Broken.VERSION}[/yellow]\u2192 [italic grey53]Consider [blue][link=https://brokensrc.dev/about/sponsors/]Sponsoring[/link][/blue] my work[/italic grey53]'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"Source code in <code>Broken/Core/BrokenTyper.py</code> Python<pre><code>def __attrs_post_init__(self):\n    self.app = typer.Typer(\n        add_help_option=self.help_option,\n        pretty_exceptions_enable=False,\n        no_args_is_help=True,\n        add_completion=False,\n        rich_markup_mode=\"rich\",\n        chain=self.chain,\n        epilog=self.epilog,\n    )\n</code></pre>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.panel","title":"<code>panel(name: str) -&gt; Generator[None, None, None]</code>","text":"Source code in <code>Broken/Core/BrokenTyper.py</code> Python<pre><code>@contextlib.contextmanager\ndef panel(self, name: str) -&gt; Generator[None, None, None]:\n    try:\n        self._panel = name\n        yield\n    finally:\n        self._panel = None\n</code></pre>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.command","title":"<code>command(target: Union[Callable, BaseModel], help: str = None, add_help_option: bool = True, naih: bool = False, name: str = None, context: bool = True, default: bool = False, panel: str = None, post: Callable = None, **kwargs) -&gt; None</code>","text":"Source code in <code>Broken/Core/BrokenTyper.py</code> Python<pre><code>def command(self,\n    target: Union[Callable, BaseModel],\n    help: str=None,\n    add_help_option: bool=True,\n    naih: bool=False,\n    name: str=None,\n    context: bool=True,\n    default: bool=False,\n    panel: str=None,\n    post: Callable=None,\n    **kwargs,\n) -&gt; None:\n\n    # Command must be implemented\n    if getattr(target, \"__isabstractmethod__\", False):\n        return\n\n    # Convert pydantic to a wrapper with same signature\n    _class = (target if isinstance(target, type) else target.__class__)\n    _instance = (target() if isinstance(target, type) else target)\n\n    if issubclass(_class, BaseModel):\n        target = pydantic_cli(instance=_instance, post=post)\n        name = (name or _class.__name__)\n        naih = True # (Complex command)\n    else:\n        name = (name or target.__name__)\n\n    # Add to known or default commands, create it\n    name = name.replace(\"_\", \"-\").lower()\n    self.default = (name if default else self.default)\n    self.commands.add(name)\n    self.app.command(name=name,\n        help=(help or target.__doc__),\n        add_help_option=add_help_option,\n        no_args_is_help=naih,\n        rich_help_panel=(panel or self._panel),\n        context_settings=dict(\n            allow_extra_args=True,\n            ignore_unknown_options=True,\n        ) if context else None,\n        **kwargs,\n    )(target)\n</code></pre>"},{"location":"broken/reference/core/brokentyper/#Core.BrokenTyper.BrokenTyper.__call__","title":"<code>__call__(*args: Iterable[Any]) -&gt; None</code>","text":"Source code in <code>Broken/Core/BrokenTyper.py</code> Python<pre><code>def __call__(self, *args: Iterable[Any]) -&gt; None:\n    self.app.info.help = (self.description or \"No help provided\")\n    args = (flatten(args) or sys.argv[1:])\n\n    for i in itertools.count():\n\n        # On subsequent runs, prompt for command\n        if (self._repl) and (i &gt; 0):\n            try:\n                args = shlex.split(typer.prompt(\n                    text=\"\",\n                    prompt_suffix=\"\u276f\",\n                    show_default=False,\n                    default=\"\"\n                ))\n            except click.exceptions.Abort:\n                log.trace(\"BrokenTyper exit KeyboardInterrupt\")\n                break\n\n        # Insert default command if none\n        if self.default and not bool(args):\n            args.insert(0, self.default)\n\n        try:\n            # Safety: Flat cast everything to str\n            self.app(list(map(str, flatten(args))))\n        except SystemExit:\n            log.trace(\"Skipping SystemExit on BrokenTyper\")\n        except KeyboardInterrupt:\n            log.success(\"BrokenTyper exit KeyboardInterrupt\")\n\n        # Exit out non-repl mode\n        if (not self._repl):\n            break\n\n        # Some action was taken, like 'depthflow main -o ./video.mp4'\n        if (i == 0) and bool(args):\n            break\n\n        # Pretty welcome message on the first 'empty' run\n        if (i == 0):\n            console.print(Panel(\n                title=\"( \ud83d\udd34\ud83d\udfe1\ud83d\udfe2 ) Welcome to the Interactive Shell mode for Releases \ud83d\ude80\",\n                title_align=\"left\",\n                border_style=\"bold grey42\",\n                expand=False,\n                renderable=Group(\n                    Text.from_markup(\n                        \"\\nHere's your chance to [royal_blue1]run commands on a basic shell[/royal_blue1], interactively\\n\\n\"\n                        \"&gt; This mode is [royal_blue1]Experimental[/royal_blue1] and projects might not work as expected\\n\\n\"\n                        \"\u2022 Preferably run the projects on a [royal_blue1]Terminal[/royal_blue1] as [spring_green1]./program.exe (args)[/spring_green1]\\n\"\n                        \"\u2022 You can skip this shell mode with [spring_green1]'REPL=0'[/spring_green1] environment var\\n\"\n                    ), Panel(\n                            \"\u2022 Run [spring_green1]'--help'[/spring_green1] or press [spring_green1]'Enter'[/spring_green1] for a command list [bold bright_black](seen above)[/bold bright_black]\\n\"\n                        \"\u2022 Press [spring_green1]'CTRL+C'[/spring_green1] to exit this shell [bold bright_black](or close the Terminal)[/bold bright_black]\",\n                        title=\"Tips\",\n                        border_style=\"green\"\n                    )\n                ),\n            ))\n\n        # The args were \"consumed\"\n        args = []\n</code></pre>"},{"location":"broken/reference/core/brokenutils/","title":"BrokenUtils","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils","title":"<code>Core.BrokenUtils</code>","text":""},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.SameTracker","title":"<code>Core.BrokenUtils.SameTracker</code>","text":"<p>Doumo same desu. If a value is the same, returns True, else updates it and returns False \u2022 Useful on ignoring expensive calls where parameters doesn't changes</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>@define\nclass SameTracker:\n    \"\"\"Doumo same desu. If a value is the same, returns True, else updates it and returns False\n    \u2022 Useful on ignoring expensive calls where parameters doesn't changes\"\"\"\n    value: Any = None\n\n    def __call__(self, value: Any=True) -&gt; bool:\n        if self.value != value:\n            self.value = value\n            return False\n        return True\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.SameTracker.value","title":"<code>value: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.SameTracker.__call__","title":"<code>__call__(value: Any = True) -&gt; bool</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __call__(self, value: Any=True) -&gt; bool:\n    if self.value != value:\n        self.value = value\n        return False\n    return True\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.OnceTracker","title":"<code>Core.BrokenUtils.OnceTracker</code>","text":"<p>Returns False the first time it's called, never nest style: <code>if once/already(): return</code></p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>@define\nclass OnceTracker:\n    \"\"\"Returns False the first time it's called, never nest style: `if once/already(): return`\"\"\"\n    _first: bool = False\n\n    def __call__(self) -&gt; bool:\n        if not self._first:\n            self._first = True\n            return False\n        return True\n\n    def decorator(method: Callable) -&gt; Callable:\n        tracker = OnceTracker()\n        @functools.wraps(method)\n        def wrapper(*args, **kwargs):\n            if tracker():\n                return\n            return method(*args, **kwargs)\n        return wrapper\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.OnceTracker.__call__","title":"<code>__call__() -&gt; bool</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __call__(self) -&gt; bool:\n    if not self._first:\n        self._first = True\n        return False\n    return True\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.OnceTracker.decorator","title":"<code>decorator(method: Callable) -&gt; Callable</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def decorator(method: Callable) -&gt; Callable:\n    tracker = OnceTracker()\n    @functools.wraps(method)\n    def wrapper(*args, **kwargs):\n        if tracker():\n            return\n        return method(*args, **kwargs)\n    return wrapper\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.PlainTracker","title":"<code>Core.BrokenUtils.PlainTracker</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>@define\nclass PlainTracker:\n    value: Any = None\n\n    def __call__(self, set: bool=None) -&gt; bool:\n        \"\"\"Returns value if None else sets it\"\"\"\n        if set is not None:\n            self.value = set\n        return self.value\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.PlainTracker.value","title":"<code>value: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.PlainTracker.__call__","title":"<code>__call__(set: bool = None) -&gt; bool</code>","text":"<p>Returns value if None else sets it</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __call__(self, set: bool=None) -&gt; bool:\n    \"\"\"Returns value if None else sets it\"\"\"\n    if set is not None:\n        self.value = set\n    return self.value\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Ignore","title":"<code>Core.BrokenUtils.Ignore</code>","text":"<p>A class that does nothing. No-operation faster Mock</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>class Ignore:\n    \"\"\"A class that does nothing. No-operation faster Mock\"\"\"\n    def __nop__(self, *args, **kwargs) -&gt; Self:\n        return self\n    def __call__(self, *args, **kwargs) -&gt; Self:\n        return self\n    def __getattr__(self, _):\n        return self.__nop__\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Ignore.__nop__","title":"<code>__nop__(*args, **kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __nop__(self, *args, **kwargs) -&gt; Self:\n    return self\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Ignore.__call__","title":"<code>__call__(*args, **kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __call__(self, *args, **kwargs) -&gt; Self:\n    return self\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Ignore.__getattr__","title":"<code>__getattr__(_)</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __getattr__(self, _):\n    return self.__nop__\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenAttrs","title":"<code>Core.BrokenUtils.BrokenAttrs</code>","text":"<p>Walk over an @attrs.defined class and call post on all classes in the MRO</p>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenAttrs--warn-must-not-define-attrs_post_init-in-an-inheriting-class","title":"Warn: Must NOT define attrs_post_init in an inheriting class","text":""},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenAttrs--fixme-can-improve-by-starting-on-brokenattrs-itself","title":"Fixme: Can improve by starting on BrokenAttrs itself","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>class BrokenAttrs:\n    \"\"\"\n    Walk over an @attrs.defined class and call __post__ on all classes in the MRO\n    # Warn: Must NOT define __attrs_post_init__ in an inheriting class\n    # Fixme: Can improve by starting on BrokenAttrs itself\n    \"\"\"\n    def __attrs_post_init__(self):\n        for cls in reversed(type(self).mro()):\n            if method := cls.__dict__.get(\"__post__\"):\n                method(self)\n\n    @abstractmethod\n    def __post__(self) -&gt; None:\n        ...\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenAttrs.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __attrs_post_init__(self):\n    for cls in reversed(type(self).mro()):\n        if method := cls.__dict__.get(\"__post__\"):\n            method(self)\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenAttrs.__post__","title":"<code>__post__() -&gt; None</code>  <code>abstractmethod</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>@abstractmethod\ndef __post__(self) -&gt; None:\n    ...\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenWatchdog","title":"<code>Core.BrokenUtils.BrokenWatchdog</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>class BrokenWatchdog(ABC):\n\n    @abstractmethod\n    def __changed__(self, key, value) -&gt; None:\n        \"\"\"Called when a property changes\"\"\"\n        ...\n\n    def __setattr__(self, key, value):\n        \"\"\"Calls __changed__ when a property changes\"\"\"\n        super().__setattr__(key, value)\n        self.__changed__(key, value)\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenWatchdog.__changed__","title":"<code>__changed__(key, value) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Called when a property changes</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>@abstractmethod\ndef __changed__(self, key, value) -&gt; None:\n    \"\"\"Called when a property changes\"\"\"\n    ...\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenWatchdog.__setattr__","title":"<code>__setattr__(key, value)</code>","text":"<p>Calls changed when a property changes</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __setattr__(self, key, value):\n    \"\"\"Calls __changed__ when a property changes\"\"\"\n    super().__setattr__(key, value)\n    self.__changed__(key, value)\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenSingleton","title":"<code>Core.BrokenUtils.BrokenSingleton</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>class BrokenSingleton(ABC):\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, \"__instance__\"):\n            cls.__instance__ = super().__new__(cls)\n            cls.__singleton__(*args, **kwargs)\n        return cls.__instance__\n\n    @abstractmethod\n    def __singleton__(self, *args, **kwargs):\n        \"\"\"__init__ but for the singleton\"\"\"\n        ...\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenSingleton.__new__","title":"<code>__new__(*args, **kwargs)</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __new__(cls, *args, **kwargs):\n    if not hasattr(cls, \"__instance__\"):\n        cls.__instance__ = super().__new__(cls)\n        cls.__singleton__(*args, **kwargs)\n    return cls.__instance__\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenSingleton.__singleton__","title":"<code>__singleton__(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>init but for the singleton</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>@abstractmethod\ndef __singleton__(self, *args, **kwargs):\n    \"\"\"__init__ but for the singleton\"\"\"\n    ...\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenFluentBuilder","title":"<code>Core.BrokenUtils.BrokenFluentBuilder</code>","text":"<p>Do you ever feel like using a builder-like fluent syntax for changing attributes of an object?</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>class BrokenFluentBuilder:\n    \"\"\"\n    Do you ever feel like using a builder-like fluent syntax for changing attributes of an object?\n    \"\"\"\n    def __call__(self, **kwargs) -&gt; Self:\n        \"\"\"Updates the instance with the provided kwargs\"\"\"\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n        return self\n\n    def copy(self, **kwargs) -&gt; Self:\n        \"\"\"Returns a copy of this instance\"\"\"\n        new = copy.deepcopy(self)\n        for key, value in kwargs.items():\n            setattr(new, key, value)\n        return new\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenFluentBuilder.__call__","title":"<code>__call__(**kwargs) -&gt; Self</code>","text":"<p>Updates the instance with the provided kwargs</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __call__(self, **kwargs) -&gt; Self:\n    \"\"\"Updates the instance with the provided kwargs\"\"\"\n    for key, value in kwargs.items():\n        setattr(self, key, value)\n    return self\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenFluentBuilder.copy","title":"<code>copy(**kwargs) -&gt; Self</code>","text":"<p>Returns a copy of this instance</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def copy(self, **kwargs) -&gt; Self:\n    \"\"\"Returns a copy of this instance\"\"\"\n    new = copy.deepcopy(self)\n    for key, value in kwargs.items():\n        setattr(new, key, value)\n    return new\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenRelay","title":"<code>Core.BrokenUtils.BrokenRelay</code>","text":"<p>A utility class for sharing one-to-many callbacks in a 'observer' pattern style. Multiple callabacks can be subscribed to receive the same args and kwargs when an instance of this class is called. Useful cases are to avoid inheritance when sharing callbacks.</p> Example Python<pre><code>relay = BrokenRelay()\n\n# Basic usage\nrelay.subscribe(callback1, callback2)\nrelay(*args, **kwargs) # Calls callback1 and callback2\n\n# Can also 'inject' us to bound callables\nwindow = moderngl_window(...)\nwindow.key_event_func = relay\nwindow.key_event_func = relay @ (camera.walk, camera.rotate)\n</code></pre> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>@define\nclass BrokenRelay:\n    \"\"\"\n    A utility class for sharing one-to-many callbacks in a 'observer' pattern style. Multiple\n    callabacks can be subscribed to receive the same args and kwargs when an instance of this class\n    is called. Useful cases are to avoid inheritance when sharing callbacks.\n\n    Example:\n        ```python\n        relay = BrokenRelay()\n\n        # Basic usage\n        relay.subscribe(callback1, callback2)\n        relay(*args, **kwargs) # Calls callback1 and callback2\n\n        # Can also 'inject' us to bound callables\n        window = moderngl_window(...)\n        window.key_event_func = relay\n        window.key_event_func = relay @ (camera.walk, camera.rotate)\n        ```\n    \"\"\"\n    callbacks: Deque[Callable] = Factory(deque)\n\n    def __bind__(self, *callbacks: Iterable[Callable]) -&gt; Self:\n        self.callbacks += flatten(callbacks)\n        return self\n\n    def subscribe(self, *callbacks: Iterable[Callable]) -&gt; Self:\n        \"\"\"Adds callbacks to be called with same arguments as self.__call__\"\"\"\n        return self.__bind__(callbacks)\n\n    def __matmul__(self, *callbacks: Iterable[Callable]) -&gt; Self:\n        \"\"\"Convenience syntax for subscribing with `relay @ (A, B)`\"\"\"\n        return self.__bind__(callbacks)\n\n    def __call__(self, *args, **kwargs):\n        for callback in self.callbacks:\n            callback(*args, **kwargs)\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenRelay.callbacks","title":"<code>callbacks: Deque[Callable] = Factory(deque)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenRelay.__bind__","title":"<code>__bind__(*callbacks: Iterable[Callable]) -&gt; Self</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __bind__(self, *callbacks: Iterable[Callable]) -&gt; Self:\n    self.callbacks += flatten(callbacks)\n    return self\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenRelay.subscribe","title":"<code>subscribe(*callbacks: Iterable[Callable]) -&gt; Self</code>","text":"<p>Adds callbacks to be called with same arguments as self.call</p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def subscribe(self, *callbacks: Iterable[Callable]) -&gt; Self:\n    \"\"\"Adds callbacks to be called with same arguments as self.__call__\"\"\"\n    return self.__bind__(callbacks)\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenRelay.__matmul__","title":"<code>__matmul__(*callbacks: Iterable[Callable]) -&gt; Self</code>","text":"<p>Convenience syntax for subscribing with <code>relay @ (A, B)</code></p> Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __matmul__(self, *callbacks: Iterable[Callable]) -&gt; Self:\n    \"\"\"Convenience syntax for subscribing with `relay @ (A, B)`\"\"\"\n    return self.__bind__(callbacks)\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.BrokenRelay.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __call__(self, *args, **kwargs):\n    for callback in self.callbacks:\n        callback(*args, **kwargs)\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.LazyImport","title":"<code>Core.BrokenUtils.LazyImport</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>class LazyImport:\n    __import__ = copy.deepcopy(__import__)\n\n    def __init__(self, _name: str=None):\n        self._lzname_ = _name\n\n    def __load__(self) -&gt; Any:\n        del sys.modules[self._lzname_]\n        module = LazyImport.__import__(self._lzname_)\n        sys.modules[self._lzname_] = module\n\n        # Update the caller's globals with the reloaded\n        sys._getframe(2).f_globals[self._lzname_] = module\n\n        return module\n\n    def __getattr__(self, name) -&gt; Any:\n        return getattr(self.__load__(), name)\n\n    def __str__(self) -&gt; str:\n        return f\"{self.__class__.__name__}(name='{self._lzname_}')\"\n\n    def __enter__(self):\n\n        @functools.wraps(LazyImport.__import__)\n        def laziest(*args):\n            module = self.__class__(_name=args[0])\n            return sys.modules.setdefault(module._lzname_, module)\n\n        # Patch the import function with ours\n        __builtins__[\"__import__\"] = laziest\n\n    def __exit__(self, *args):\n        __builtins__[\"__import__\"] = LazyImport.__import__\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.LazyImport.__import__","title":"<code>__import__ = copy.deepcopy(__import__)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.LazyImport.__init__","title":"<code>__init__(_name: str = None)</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __init__(self, _name: str=None):\n    self._lzname_ = _name\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.LazyImport.__load__","title":"<code>__load__() -&gt; Any</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __load__(self) -&gt; Any:\n    del sys.modules[self._lzname_]\n    module = LazyImport.__import__(self._lzname_)\n    sys.modules[self._lzname_] = module\n\n    # Update the caller's globals with the reloaded\n    sys._getframe(2).f_globals[self._lzname_] = module\n\n    return module\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.LazyImport.__getattr__","title":"<code>__getattr__(name) -&gt; Any</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __getattr__(self, name) -&gt; Any:\n    return getattr(self.__load__(), name)\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.LazyImport.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __str__(self) -&gt; str:\n    return f\"{self.__class__.__name__}(name='{self._lzname_}')\"\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.LazyImport.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __enter__(self):\n\n    @functools.wraps(LazyImport.__import__)\n    def laziest(*args):\n        module = self.__class__(_name=args[0])\n        return sys.modules.setdefault(module._lzname_, module)\n\n    # Patch the import function with ours\n    __builtins__[\"__import__\"] = laziest\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.LazyImport.__exit__","title":"<code>__exit__(*args)</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __exit__(self, *args):\n    __builtins__[\"__import__\"] = LazyImport.__import__\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Patch","title":"<code>Core.BrokenUtils.Patch</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>@define\nclass Patch:\n    file: Path = field(converter=Path)\n    replaces: dict[str, str] = field(factory=dict)\n    __original__: str = None\n\n    def __attrs_post_init__(self):\n        self.__original__ = self.file.read_text(\"utf-8\")\n\n    def apply(self):\n        content = self.__original__\n        for key, value in self.replaces.items():\n            content = content.replace(key, value)\n        self.file.write_text(content, \"utf-8\")\n\n    def revert(self):\n        self.file.write_text(self.__original__, \"utf-8\")\n\n    def __enter__(self):\n        self.apply()\n    def __exit__(self, *args):\n        self.revert()\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Patch.file","title":"<code>file: Path = field(converter=Path)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Patch.replaces","title":"<code>replaces: dict[str, str] = field(factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Patch.__original__","title":"<code>__original__: str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Patch.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __attrs_post_init__(self):\n    self.__original__ = self.file.read_text(\"utf-8\")\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Patch.apply","title":"<code>apply()</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def apply(self):\n    content = self.__original__\n    for key, value in self.replaces.items():\n        content = content.replace(key, value)\n    self.file.write_text(content, \"utf-8\")\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Patch.revert","title":"<code>revert()</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def revert(self):\n    self.file.write_text(self.__original__, \"utf-8\")\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Patch.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __enter__(self):\n    self.apply()\n</code></pre>"},{"location":"broken/reference/core/brokenutils/#Core.BrokenUtils.Patch.__exit__","title":"<code>__exit__(*args)</code>","text":"Source code in <code>Broken/Core/BrokenUtils.py</code> Python<pre><code>def __exit__(self, *args):\n    self.revert()\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/","title":"BrokenDotmap","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap","title":"<code>Core.Staging.BrokenDotmap</code>","text":""},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap","title":"<code>Core.Staging.BrokenDotmap.BrokenDotmap</code>","text":"<p>Trivia \u2022 Tremeschin \ud83d\udc19 \ud83c\udfb2 \ud83c\udf3f \ud83d\udd31 \ud83e\udeb6, [7/7/23 1:29 AM] \u2022 I just made the most cursed user friendly lazy dictionary you'll ever see</p>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap--description","title":"Description","text":"<p>BrokenDict is a file-synced (or not!) dictionary similar to DotMap with some extra utilities - Support for TOML, JSON, YAML file formats, just specify the file extension of path on creation - Utility function .default(key, value) to set a default value for a key and sync it - Any dictionary modification outside .no_sync() context will be synced to the file</p>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap--usage","title":"Usage","text":"Python<pre><code># Any file format or None for file-less operation\nbroken_dict = BrokenDict(\"path/to/file.{toml,json,yaml}\")\n\n# Assignment\nbroken_dict[\"key\"] = \"value\"\nbroken_dict.key = \"value\"\n\n# Nested works\nbroken_dict.nested.key = \"value\"\n\n# Default values (returns key if exists else sets value)\nbroken_dict.default(\"key\", \"value\")\n\n# Load from dictionary (loads dict into broken_dict[\"key\"] = {\"cat\": \"dog\"})\nbroken_dict.key.from_dict({\"cat\": \"dog\"})\n\n# Get dictionary from this instance nest downwards\nbroken_dict.to_dict()\nbroken_dict.nested.to_dict()\n\n# Load dictionary from also any TOML, JSON, YAML file\nbroken_dict.inner_loaded.from_file(\"path/to/file.{toml,json,yaml}\")\n\n# Do some heavy operations without syncing and then sync\nwith broken_dict.no_sync():\n    for i in range(100):\n        broken_dict.primes[i] = is_prime(i)\n</code></pre> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>class BrokenDotmap:\n    \"\"\"\n    Trivia\n    \u2022 Tremeschin \ud83d\udc19 \ud83c\udfb2 \ud83c\udf3f \ud83d\udd31 \ud83e\udeb6, [7/7/23 1:29 AM]\n    \u2022 I just made the most cursed user friendly lazy dictionary you'll ever see\n\n    # Description\n    BrokenDict is a file-synced (or not!) dictionary similar to DotMap with some extra utilities\n    - Support for TOML, JSON, YAML file formats, just specify the file extension of path on creation\n    - Utility function .default(key, value) to set a default value for a key and sync it\n    - Any dictionary modification outside .no_sync() context will be synced to the file\n\n    # Usage\n    ```python\n    # Any file format or None for file-less operation\n    broken_dict = BrokenDict(\"path/to/file.{toml,json,yaml}\")\n\n    # Assignment\n    broken_dict[\"key\"] = \"value\"\n    broken_dict.key = \"value\"\n\n    # Nested works\n    broken_dict.nested.key = \"value\"\n\n    # Default values (returns key if exists else sets value)\n    broken_dict.default(\"key\", \"value\")\n\n    # Load from dictionary (loads dict into broken_dict[\"key\"] = {\"cat\": \"dog\"})\n    broken_dict.key.from_dict({\"cat\": \"dog\"})\n\n    # Get dictionary from this instance nest downwards\n    broken_dict.to_dict()\n    broken_dict.nested.to_dict()\n\n    # Load dictionary from also any TOML, JSON, YAML file\n    broken_dict.inner_loaded.from_file(\"path/to/file.{toml,json,yaml}\")\n\n    # Do some heavy operations without syncing and then sync\n    with broken_dict.no_sync():\n        for i in range(100):\n            broken_dict.primes[i] = is_prime(i)\n    ```\n    \"\"\"\n\n    @staticmethod\n    def is_dunder(key: str) -&gt; bool:\n        \"\"\"Check if a key is a dunder attribute\"\"\"\n        return key.startswith(\"__\") and key.endswith(\"__\")\n\n    def __init__(self,\n        path: Path=None,\n        sync: bool=True,\n        echo: bool=False,\n        super: Self=None,\n    ):\n\n        # A reference to the root instance of the dictionaries\n        self.__super__ = super or self\n\n        # Behavior configuration\n        self.__path__ = path\n        self.__sync__ = sync\n\n        # Load or create from file\n        if self.__path__ is not None:\n            self.__path__ = BrokenPath(self.__path__)\n\n            log.info(f\"\u2022 New BrokenDotmap @ ({self.__path__})\", echo=echo)\n\n            if self.__path__.exists():\n                self.from_file(self.__path__)\n            else:\n                self.sync()\n\n    # # Convenience flags\n\n    @property\n    def __ext__(self) -&gt; str:\n        \"\"\"Get the file extension of the path\"\"\"\n        return self.__path__.suffix.lower()\n\n    # # Loading and saving\n\n    def from_dict(self, data: dict={}) -&gt; Self:\n        \"\"\"Append a dictionary to this instance\"\"\"\n        for key, value in (data or {}).items():\n            self.set(key, self.__recurse__(value))\n        return self\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Get a dictionary from this instance downwards\"\"\"\n        return {\n            k: v.to_dict() if isinstance(v, type(self)) else v\n            for k, v in sorted(self.items(), key=lambda x: x[0])\n            if not BrokenDotmap.is_dunder(k)\n        }\n\n    def from_file(self, path: Path) -&gt; Self:\n        \"\"\"Load a file into this dotmap instance\"\"\"\n        path   = BrokenPath(path)\n        format = path.suffix.lower()\n\n        # Load data from file\n        try:\n            if (format == \".toml\"):\n                import toml\n                data = toml.loads(path.read_text())\n            elif (format == \".json\"):\n                import json\n                data = json.loads(path.read_text())\n            elif (format == \".yaml\"):\n                import yaml\n                data = yaml.load(path.read_text(), Loader=yaml.FullLoader)\n            elif (format == \".pickle\"):\n                import pickle\n                data = pickle.loads(path.read_bytes())\n            else:\n                log.error(f\"\u2022 BrokenDotmap: Unknown file format ({format})\")\n                log.error(f\"\u2514\u2500 File: ({path})\")\n                return\n\n        except Exception as e:\n            log.error(f\"\u2022 BrokenDotmap: Failed to load file ({path})\")\n            log.error(f\"\u2514\u2500 {e}\")\n            return\n\n        return self.from_dict(data)\n\n    def sync(self, sync: bool=True) -&gt; None:\n        \"\"\"Sync this instance to the file\"\"\"\n        self.__sync__ = sync\n        self.__super__.__sync_to_file__()\n\n    # Internal recursion\n\n    def __recurse__(self, value={}) -&gt; Union[Self, Any]:\n        \"\"\"Transforms a dict-like into Self or return the value itself\"\"\"\n        if isinstance(value, dict):\n            return type(self)(super=self.__super__).from_dict(value)\n        return value\n\n    # # Redirect items, keys\n\n    def items(self) -&gt; Dict[str, Any]:\n        return self.__dict__.items()\n\n    def keys(self) -&gt; list:\n        return list(self.__dict__.keys())\n\n    # # Patch Get methods\n\n    def get(self, key: str) -&gt; Union[Self, Any]:\n        \"\"\"If a key doesn't exist, recurse, else return its the value\"\"\"\n        return self.__dict__.setdefault(key, self.__recurse__())\n\n    def __getitem__(self, key: str) -&gt; Union[Self, Any]:\n        \"\"\"Handle dictionary item access using key indexing\"\"\"\n        return self.get(key)\n\n    def __getattr__(self, key: str) -&gt; Union[Self, Any]:\n        \"\"\"Handle attribute access using dot notation\"\"\"\n        return self.get(key)\n\n    # # Patch Set methods\n\n    def set(self, key: str, value: Any={}) -&gt; Any:\n        \"\"\"Set a key to a value, recurses on the value\"\"\"\n        self.__dict__[key] = self.__recurse__(value)\n        self.sync()\n        return value\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Handle dictionary item assignment using key indexing\"\"\"\n        self.set(key, value)\n\n    def __setattr__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Handle attribute assignment using dot notation\"\"\"\n\n        # Do not \"recurse\" on dunder attributes, they are self!\n        if BrokenDotmap.is_dunder(key):\n            self.__dict__[key] = value\n            return\n\n        self.set(key, value)\n\n    # # Utilities\n\n    def default(self, key: str, value: Any) -&gt; Any:\n        \"\"\"Set a default value for a key else don't change, returns it\"\"\"\n\n        # Return the value if it exists\n        if key in self.__dict__:\n            return self.__dict__[key]\n\n        # Set the value and sync (call it if callable - a use as a cache)\n        return self.set(key, value() if callable(value) else value)\n\n    def setdefault(self, key: str, value: Any) -&gt; Any:\n        \"\"\"Set a default value for a key else don't change, returns it\"\"\"\n        return self.default(key, value)\n\n    @contextlib.contextmanager\n    def no_sync(self) -&gt; Generator[None, None, None]:\n        \"\"\"Temporarily disables syncing, for example bulk operations\"\"\"\n        self.__sync__ = False\n        yield None\n        self.__sync__ = True\n        self._sync()\n\n    def inverse(self, value: Any) -&gt; Any | None:\n        \"\"\"Search by value\"\"\"\n        return next((k for k, v in self.items() if v == value), None)\n\n    # # Sync\n\n    def __sync_to_file__(self) -&gt; None:\n\n        # Non file mode\n        if self.__path__ is None:\n            return\n\n        # Don't sync mode\n        if not self.__sync__:\n            return\n\n        # Get the full dictionary to save\n        dict = self.to_dict()\n\n        # Load file based on format\n        if (self.__ext__ == \".toml\"):\n            import toml\n            self.__path__.write_text(toml.dumps(dict))\n        elif (self.__ext__ == \".json\"):\n            import json\n            self.__path__.write_text(json.dumps(dict, indent=2, ensure_ascii=False))\n        elif (self.__ext__ == \".yaml\"):\n            import yaml\n            self.__path__.write_text(yaml.dump(dict))\n        elif (self.__ext__ == \".pickle\"):\n            import pickle\n            self.__path__.write_bytes(pickle.dumps(dict))\n        else:\n            log.error(f\"BrokenDotmap: Unknown file format ({self.__ext__}), cannot save to file\")\n            return\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.is_dunder","title":"<code>is_dunder(key: str) -&gt; bool</code>  <code>staticmethod</code>","text":"<p>Check if a key is a dunder attribute</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>@staticmethod\ndef is_dunder(key: str) -&gt; bool:\n    \"\"\"Check if a key is a dunder attribute\"\"\"\n    return key.startswith(\"__\") and key.endswith(\"__\")\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__init__","title":"<code>__init__(path: Path = None, sync: bool = True, echo: bool = False, super: Self = None)</code>","text":"Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def __init__(self,\n    path: Path=None,\n    sync: bool=True,\n    echo: bool=False,\n    super: Self=None,\n):\n\n    # A reference to the root instance of the dictionaries\n    self.__super__ = super or self\n\n    # Behavior configuration\n    self.__path__ = path\n    self.__sync__ = sync\n\n    # Load or create from file\n    if self.__path__ is not None:\n        self.__path__ = BrokenPath(self.__path__)\n\n        log.info(f\"\u2022 New BrokenDotmap @ ({self.__path__})\", echo=echo)\n\n        if self.__path__.exists():\n            self.from_file(self.__path__)\n        else:\n            self.sync()\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__super__","title":"<code>__super__ = super or self</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__path__","title":"<code>__path__ = path</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__sync__","title":"<code>__sync__ = sync</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__ext__","title":"<code>__ext__: str</code>  <code>property</code>","text":"<p>Get the file extension of the path</p>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.from_dict","title":"<code>from_dict(data: dict = {}) -&gt; Self</code>","text":"<p>Append a dictionary to this instance</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def from_dict(self, data: dict={}) -&gt; Self:\n    \"\"\"Append a dictionary to this instance\"\"\"\n    for key, value in (data or {}).items():\n        self.set(key, self.__recurse__(value))\n    return self\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.to_dict","title":"<code>to_dict() -&gt; dict</code>","text":"<p>Get a dictionary from this instance downwards</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Get a dictionary from this instance downwards\"\"\"\n    return {\n        k: v.to_dict() if isinstance(v, type(self)) else v\n        for k, v in sorted(self.items(), key=lambda x: x[0])\n        if not BrokenDotmap.is_dunder(k)\n    }\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.from_file","title":"<code>from_file(path: Path) -&gt; Self</code>","text":"<p>Load a file into this dotmap instance</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def from_file(self, path: Path) -&gt; Self:\n    \"\"\"Load a file into this dotmap instance\"\"\"\n    path   = BrokenPath(path)\n    format = path.suffix.lower()\n\n    # Load data from file\n    try:\n        if (format == \".toml\"):\n            import toml\n            data = toml.loads(path.read_text())\n        elif (format == \".json\"):\n            import json\n            data = json.loads(path.read_text())\n        elif (format == \".yaml\"):\n            import yaml\n            data = yaml.load(path.read_text(), Loader=yaml.FullLoader)\n        elif (format == \".pickle\"):\n            import pickle\n            data = pickle.loads(path.read_bytes())\n        else:\n            log.error(f\"\u2022 BrokenDotmap: Unknown file format ({format})\")\n            log.error(f\"\u2514\u2500 File: ({path})\")\n            return\n\n    except Exception as e:\n        log.error(f\"\u2022 BrokenDotmap: Failed to load file ({path})\")\n        log.error(f\"\u2514\u2500 {e}\")\n        return\n\n    return self.from_dict(data)\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.sync","title":"<code>sync(sync: bool = True) -&gt; None</code>","text":"<p>Sync this instance to the file</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def sync(self, sync: bool=True) -&gt; None:\n    \"\"\"Sync this instance to the file\"\"\"\n    self.__sync__ = sync\n    self.__super__.__sync_to_file__()\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__recurse__","title":"<code>__recurse__(value={}) -&gt; Union[Self, Any]</code>","text":"<p>Transforms a dict-like into Self or return the value itself</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def __recurse__(self, value={}) -&gt; Union[Self, Any]:\n    \"\"\"Transforms a dict-like into Self or return the value itself\"\"\"\n    if isinstance(value, dict):\n        return type(self)(super=self.__super__).from_dict(value)\n    return value\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.items","title":"<code>items() -&gt; Dict[str, Any]</code>","text":"Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def items(self) -&gt; Dict[str, Any]:\n    return self.__dict__.items()\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.keys","title":"<code>keys() -&gt; list</code>","text":"Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def keys(self) -&gt; list:\n    return list(self.__dict__.keys())\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.get","title":"<code>get(key: str) -&gt; Union[Self, Any]</code>","text":"<p>If a key doesn't exist, recurse, else return its the value</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def get(self, key: str) -&gt; Union[Self, Any]:\n    \"\"\"If a key doesn't exist, recurse, else return its the value\"\"\"\n    return self.__dict__.setdefault(key, self.__recurse__())\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__getitem__","title":"<code>__getitem__(key: str) -&gt; Union[Self, Any]</code>","text":"<p>Handle dictionary item access using key indexing</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def __getitem__(self, key: str) -&gt; Union[Self, Any]:\n    \"\"\"Handle dictionary item access using key indexing\"\"\"\n    return self.get(key)\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__getattr__","title":"<code>__getattr__(key: str) -&gt; Union[Self, Any]</code>","text":"<p>Handle attribute access using dot notation</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def __getattr__(self, key: str) -&gt; Union[Self, Any]:\n    \"\"\"Handle attribute access using dot notation\"\"\"\n    return self.get(key)\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.set","title":"<code>set(key: str, value: Any = {}) -&gt; Any</code>","text":"<p>Set a key to a value, recurses on the value</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def set(self, key: str, value: Any={}) -&gt; Any:\n    \"\"\"Set a key to a value, recurses on the value\"\"\"\n    self.__dict__[key] = self.__recurse__(value)\n    self.sync()\n    return value\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__setitem__","title":"<code>__setitem__(key: str, value: Any) -&gt; None</code>","text":"<p>Handle dictionary item assignment using key indexing</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Handle dictionary item assignment using key indexing\"\"\"\n    self.set(key, value)\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__setattr__","title":"<code>__setattr__(key: str, value: Any) -&gt; None</code>","text":"<p>Handle attribute assignment using dot notation</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def __setattr__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Handle attribute assignment using dot notation\"\"\"\n\n    # Do not \"recurse\" on dunder attributes, they are self!\n    if BrokenDotmap.is_dunder(key):\n        self.__dict__[key] = value\n        return\n\n    self.set(key, value)\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.default","title":"<code>default(key: str, value: Any) -&gt; Any</code>","text":"<p>Set a default value for a key else don't change, returns it</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def default(self, key: str, value: Any) -&gt; Any:\n    \"\"\"Set a default value for a key else don't change, returns it\"\"\"\n\n    # Return the value if it exists\n    if key in self.__dict__:\n        return self.__dict__[key]\n\n    # Set the value and sync (call it if callable - a use as a cache)\n    return self.set(key, value() if callable(value) else value)\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.setdefault","title":"<code>setdefault(key: str, value: Any) -&gt; Any</code>","text":"<p>Set a default value for a key else don't change, returns it</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def setdefault(self, key: str, value: Any) -&gt; Any:\n    \"\"\"Set a default value for a key else don't change, returns it\"\"\"\n    return self.default(key, value)\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.no_sync","title":"<code>no_sync() -&gt; Generator[None, None, None]</code>","text":"<p>Temporarily disables syncing, for example bulk operations</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>@contextlib.contextmanager\ndef no_sync(self) -&gt; Generator[None, None, None]:\n    \"\"\"Temporarily disables syncing, for example bulk operations\"\"\"\n    self.__sync__ = False\n    yield None\n    self.__sync__ = True\n    self._sync()\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.inverse","title":"<code>inverse(value: Any) -&gt; Any | None</code>","text":"<p>Search by value</p> Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def inverse(self, value: Any) -&gt; Any | None:\n    \"\"\"Search by value\"\"\"\n    return next((k for k, v in self.items() if v == value), None)\n</code></pre>"},{"location":"broken/reference/core/staging/brokendotmap/#Core.Staging.BrokenDotmap.BrokenDotmap.__sync_to_file__","title":"<code>__sync_to_file__() -&gt; None</code>","text":"Source code in <code>Broken/Core/Staging/BrokenDotmap.py</code> Python<pre><code>def __sync_to_file__(self) -&gt; None:\n\n    # Non file mode\n    if self.__path__ is None:\n        return\n\n    # Don't sync mode\n    if not self.__sync__:\n        return\n\n    # Get the full dictionary to save\n    dict = self.to_dict()\n\n    # Load file based on format\n    if (self.__ext__ == \".toml\"):\n        import toml\n        self.__path__.write_text(toml.dumps(dict))\n    elif (self.__ext__ == \".json\"):\n        import json\n        self.__path__.write_text(json.dumps(dict, indent=2, ensure_ascii=False))\n    elif (self.__ext__ == \".yaml\"):\n        import yaml\n        self.__path__.write_text(yaml.dump(dict))\n    elif (self.__ext__ == \".pickle\"):\n        import pickle\n        self.__path__.write_bytes(pickle.dumps(dict))\n    else:\n        log.error(f\"BrokenDotmap: Unknown file format ({self.__ext__}), cannot save to file\")\n        return\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/","title":"umidi","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi","title":"<code>Core.Staging.umidi</code>","text":"<p>Absolutely clutch information for parsing MIDI files: \u2022 https://web.archive.org/web/20141227205754/http://www.sonicspot.com:80/guide/midifiles.html</p>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note","title":"<code>Core.Staging.umidi.Note</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass Note:\n    note:     int   = 60\n    velocity: int   = 100\n    channel:  int   = 0\n    start:    float = 0\n    end:      float = 0\n\n    def __hash__(self):\n        return hash((self.note, self.start, self.end, self.channel, self.velocity))\n\n    def __eq__(self, other):\n        return hash(self) == hash(other)\n\n    # # Initialization\n\n    @classmethod\n    @functools.lru_cache\n    def from_index(cls, note: int, **kwargs) -&gt; Self:\n        return cls(note=note, **kwargs)\n\n    @classmethod\n    @functools.lru_cache\n    def from_name(cls, name: str, **kwargs) -&gt; Self:\n        return cls(note=Note.name_to_index(name), **kwargs)\n\n    @classmethod\n    @functools.lru_cache\n    def from_frequency(cls, frequency: float, **kwargs) -&gt; Self:\n        return cls(note=Note.frequency_to_index(frequency), **kwargs)\n\n    @classmethod\n    @functools.lru_cache\n    def get(cls, object: Any, **kwargs) -&gt; Self:\n        if isinstance(object, Note):\n            return object(**kwargs)\n        elif isinstance(object, int):\n            return cls.from_index(object, **kwargs)\n        elif isinstance(object, str):\n            return cls.from_name(object, **kwargs)\n        elif isinstance(object, float):\n            return cls.from_frequency(object, **kwargs)\n        return cls(**kwargs)\n\n    # # Conversion\n\n    @staticmethod\n    @functools.lru_cache\n    def index_to_name(index: int) -&gt; str:\n        return f\"{PIANO_NOTES[index % 12]}{index//12 - 1}\"\n\n    @staticmethod\n    @functools.lru_cache\n    def index_to_frequency(index: int) -&gt; float:\n        return 440 * 2**((index - 69)/12)\n\n    @staticmethod\n    @functools.lru_cache\n    def name_to_index(name: str) -&gt; int:\n        note, octave = name[:-1].upper(), int(name[-1])\n        return PIANO_NOTES.index(note) + 12*(octave + 1)\n\n    @staticmethod\n    @functools.lru_cache\n    def name_to_frequency(name: str) -&gt; float:\n        return Note.index_to_frequency(Note.name_to_index(name))\n\n    @staticmethod\n    @functools.lru_cache\n    def frequency_to_index(frequency: float) -&gt; int:\n        return round(12*math.log2(frequency/440) + 69)\n\n    @staticmethod\n    @functools.lru_cache\n    def frequency_to_name(frequency: float) -&gt; str:\n        return Note.index_to_name(Note.frequency_to_index(frequency))\n\n    # # Utilities\n\n    @property\n    def frequency(self) -&gt; float:\n        return Note.index_to_frequency(self.note)\n\n    @frequency.setter\n    def frequency(self, value: float):\n        self.note = Note.frequency_to_index(value)\n\n    @property\n    def name(self) -&gt; str:\n        return Note.index_to_name(self.note)\n\n    @name.setter\n    def name(self, value: str):\n        self.note = Note.name_to_index(value)\n\n    # Black and White\n\n    def is_white(note: int) -&gt; bool:\n        return (note % 12) in {0, 2, 4, 5, 7, 9, 11}\n\n    def is_black(note: int) -&gt; bool:\n        return (note % 12) in {1, 3, 6, 8, 10}\n\n    @property\n    def white(self) -&gt; bool:\n        return Note.is_white(self.note)\n\n    @property\n    def black(self) -&gt; bool:\n        return Note.is_black(self.note)\n\n    # Temporal\n\n    @property\n    def duration(self):\n        return self.end - self.start\n\n    @duration.setter\n    def duration(self, value: float):\n        self.end = self.start + value\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.note","title":"<code>note: int = 60</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.velocity","title":"<code>velocity: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.channel","title":"<code>channel: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.start","title":"<code>start: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.end","title":"<code>end: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>def __hash__(self):\n    return hash((self.note, self.start, self.end, self.channel, self.velocity))\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>def __eq__(self, other):\n    return hash(self) == hash(other)\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.from_index","title":"<code>from_index(note: int, **kwargs) -&gt; Self</code>  <code>cached</code> <code>classmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@classmethod\n@functools.lru_cache\ndef from_index(cls, note: int, **kwargs) -&gt; Self:\n    return cls(note=note, **kwargs)\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.from_name","title":"<code>from_name(name: str, **kwargs) -&gt; Self</code>  <code>cached</code> <code>classmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@classmethod\n@functools.lru_cache\ndef from_name(cls, name: str, **kwargs) -&gt; Self:\n    return cls(note=Note.name_to_index(name), **kwargs)\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.from_frequency","title":"<code>from_frequency(frequency: float, **kwargs) -&gt; Self</code>  <code>cached</code> <code>classmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@classmethod\n@functools.lru_cache\ndef from_frequency(cls, frequency: float, **kwargs) -&gt; Self:\n    return cls(note=Note.frequency_to_index(frequency), **kwargs)\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.get","title":"<code>get(object: Any, **kwargs) -&gt; Self</code>  <code>cached</code> <code>classmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@classmethod\n@functools.lru_cache\ndef get(cls, object: Any, **kwargs) -&gt; Self:\n    if isinstance(object, Note):\n        return object(**kwargs)\n    elif isinstance(object, int):\n        return cls.from_index(object, **kwargs)\n    elif isinstance(object, str):\n        return cls.from_name(object, **kwargs)\n    elif isinstance(object, float):\n        return cls.from_frequency(object, **kwargs)\n    return cls(**kwargs)\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.index_to_name","title":"<code>index_to_name(index: int) -&gt; str</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef index_to_name(index: int) -&gt; str:\n    return f\"{PIANO_NOTES[index % 12]}{index//12 - 1}\"\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.index_to_frequency","title":"<code>index_to_frequency(index: int) -&gt; float</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef index_to_frequency(index: int) -&gt; float:\n    return 440 * 2**((index - 69)/12)\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.name_to_index","title":"<code>name_to_index(name: str) -&gt; int</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef name_to_index(name: str) -&gt; int:\n    note, octave = name[:-1].upper(), int(name[-1])\n    return PIANO_NOTES.index(note) + 12*(octave + 1)\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.name_to_frequency","title":"<code>name_to_frequency(name: str) -&gt; float</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef name_to_frequency(name: str) -&gt; float:\n    return Note.index_to_frequency(Note.name_to_index(name))\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.frequency_to_index","title":"<code>frequency_to_index(frequency: float) -&gt; int</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef frequency_to_index(frequency: float) -&gt; int:\n    return round(12*math.log2(frequency/440) + 69)\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.frequency_to_name","title":"<code>frequency_to_name(frequency: float) -&gt; str</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef frequency_to_name(frequency: float) -&gt; str:\n    return Note.index_to_name(Note.frequency_to_index(frequency))\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.frequency","title":"<code>frequency: float</code>  <code>property</code> <code>writable</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.is_white","title":"<code>is_white(note: int) -&gt; bool</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>def is_white(note: int) -&gt; bool:\n    return (note % 12) in {0, 2, 4, 5, 7, 9, 11}\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.is_black","title":"<code>is_black(note: int) -&gt; bool</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>def is_black(note: int) -&gt; bool:\n    return (note % 12) in {1, 3, 6, 8, 10}\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.white","title":"<code>white: bool</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.black","title":"<code>black: bool</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Note.duration","title":"<code>duration</code>  <code>property</code> <code>writable</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events","title":"<code>Core.Staging.umidi.Events</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>class Events:\n\n    # # Meta events\n\n    @define\n    class SequenceNumber(BaseEvent):\n        value: int\n\n    @define\n    class Text(BaseEvent):\n        text: str\n\n    @define\n    class Copyright(BaseEvent):\n        text: str\n\n    @define\n    class TrackName(BaseEvent):\n        text: str\n\n    @define\n    class InstrumentName(BaseEvent):\n        text: str\n\n    @define\n    class Lyrics(BaseEvent):\n        text: str\n\n    @define\n    class Marker(BaseEvent):\n        text: str\n\n    @define\n    class CuePoint(BaseEvent):\n        text: str\n\n    @define\n    class MidiChannelPrefix(BaseEvent):\n        channel: int\n\n    @define\n    class EndTrack:\n        ...\n\n    @define\n    class SetTempo(BaseEvent):\n        mpqn: int\n        \"\"\"Microseconds per Quarter Note\"\"\"\n\n        @property\n        def bpm(self) -&gt; float:\n            return MICROSECONDS_PER_MINUTE / self.mpqn\n\n    @define\n    class SMTPEOffset(BaseEvent):\n        hours: int\n        minutes: int\n        seconds: int\n        frames: int\n        subframes: int\n\n    @define\n    class TimeSignature(BaseEvent):\n        numerator: int\n        denominator: int\n        metronome: int\n        thirty_seconds: int\n\n    @define\n    class KeySignature(BaseEvent):\n        key: int\n        scale: int\n\n        @property\n        def major(self) -&gt; bool:\n            return (self.scale == 0)\n\n        @property\n        def minor(self) -&gt; bool:\n            return (self.scale == 1)\n\n    @define\n    class SequencerSpecific(BaseEvent):\n        text: str\n\n    # # Midi events\n\n    Note = Note\n\n    @define\n    class Pressure(BaseEvent):\n        note: int\n        pressure: int\n\n    @define\n    class Controller(BaseEvent):\n        controller: int\n        value: int\n\n        @property\n        def bank_select(self) -&gt; int:\n            return (self.value == 0x00)\n\n        @property\n        def modulation(self) -&gt; int:\n            return (self.value == 0x01)\n\n        ... # Todo\n\n    @define\n    class Program(BaseEvent):\n        program: int\n\n    @define\n    class ChannelPressure(BaseEvent):\n        pressure: int\n\n    @define\n    class PitchBend(BaseEvent):\n        value: int\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SequenceNumber","title":"<code>SequenceNumber</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass SequenceNumber(BaseEvent):\n    value: int\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SequenceNumber.value","title":"<code>value: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Text","title":"<code>Text</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass Text(BaseEvent):\n    text: str\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Text.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Copyright","title":"<code>Copyright</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass Copyright(BaseEvent):\n    text: str\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Copyright.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.TrackName","title":"<code>TrackName</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass TrackName(BaseEvent):\n    text: str\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.TrackName.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.InstrumentName","title":"<code>InstrumentName</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass InstrumentName(BaseEvent):\n    text: str\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.InstrumentName.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Lyrics","title":"<code>Lyrics</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass Lyrics(BaseEvent):\n    text: str\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Lyrics.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Marker","title":"<code>Marker</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass Marker(BaseEvent):\n    text: str\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Marker.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.CuePoint","title":"<code>CuePoint</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass CuePoint(BaseEvent):\n    text: str\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.CuePoint.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.MidiChannelPrefix","title":"<code>MidiChannelPrefix</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass MidiChannelPrefix(BaseEvent):\n    channel: int\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.MidiChannelPrefix.channel","title":"<code>channel: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.EndTrack","title":"<code>EndTrack</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass EndTrack:\n    ...\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SetTempo","title":"<code>SetTempo</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass SetTempo(BaseEvent):\n    mpqn: int\n    \"\"\"Microseconds per Quarter Note\"\"\"\n\n    @property\n    def bpm(self) -&gt; float:\n        return MICROSECONDS_PER_MINUTE / self.mpqn\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SetTempo.mpqn","title":"<code>mpqn: int</code>  <code>instance-attribute</code>","text":"<p>Microseconds per Quarter Note</p>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SetTempo.bpm","title":"<code>bpm: float</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SMTPEOffset","title":"<code>SMTPEOffset</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass SMTPEOffset(BaseEvent):\n    hours: int\n    minutes: int\n    seconds: int\n    frames: int\n    subframes: int\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SMTPEOffset.hours","title":"<code>hours: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SMTPEOffset.minutes","title":"<code>minutes: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SMTPEOffset.seconds","title":"<code>seconds: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SMTPEOffset.frames","title":"<code>frames: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SMTPEOffset.subframes","title":"<code>subframes: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.TimeSignature","title":"<code>TimeSignature</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass TimeSignature(BaseEvent):\n    numerator: int\n    denominator: int\n    metronome: int\n    thirty_seconds: int\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.TimeSignature.numerator","title":"<code>numerator: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.TimeSignature.denominator","title":"<code>denominator: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.TimeSignature.metronome","title":"<code>metronome: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.TimeSignature.thirty_seconds","title":"<code>thirty_seconds: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.KeySignature","title":"<code>KeySignature</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass KeySignature(BaseEvent):\n    key: int\n    scale: int\n\n    @property\n    def major(self) -&gt; bool:\n        return (self.scale == 0)\n\n    @property\n    def minor(self) -&gt; bool:\n        return (self.scale == 1)\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.KeySignature.key","title":"<code>key: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.KeySignature.scale","title":"<code>scale: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.KeySignature.major","title":"<code>major: bool</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.KeySignature.minor","title":"<code>minor: bool</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SequencerSpecific","title":"<code>SequencerSpecific</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass SequencerSpecific(BaseEvent):\n    text: str\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.SequencerSpecific.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Note","title":"<code>Note = Note</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Pressure","title":"<code>Pressure</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass Pressure(BaseEvent):\n    note: int\n    pressure: int\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Pressure.note","title":"<code>note: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Pressure.pressure","title":"<code>pressure: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Controller","title":"<code>Controller</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass Controller(BaseEvent):\n    controller: int\n    value: int\n\n    @property\n    def bank_select(self) -&gt; int:\n        return (self.value == 0x00)\n\n    @property\n    def modulation(self) -&gt; int:\n        return (self.value == 0x01)\n\n    ... # Todo\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Controller.controller","title":"<code>controller: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Controller.value","title":"<code>value: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Controller.bank_select","title":"<code>bank_select: int</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Controller.modulation","title":"<code>modulation: int</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Program","title":"<code>Program</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass Program(BaseEvent):\n    program: int\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.Program.program","title":"<code>program: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.ChannelPressure","title":"<code>ChannelPressure</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass ChannelPressure(BaseEvent):\n    pressure: int\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.ChannelPressure.pressure","title":"<code>pressure: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.PitchBend","title":"<code>PitchBend</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass PitchBend(BaseEvent):\n    value: int\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Events.PitchBend.value","title":"<code>value: int</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Midi","title":"<code>Core.Staging.umidi.Midi</code>","text":"Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>@define\nclass Midi:\n    format: int = 0\n    tracks: int = 0\n    _tempos: Deque[Tuple[float, Tempo]] = Factory(deque)\n\n    @property\n    def tempos(self) -&gt; Deque[Tuple[float, Tempo]]:\n        if len(self._tempos) == 0:\n            return deque(((0, 120),))\n        return self._tempos\n\n    def _tempo(self, time: float) -&gt; Tuple[float, Tempo]:\n        \"\"\"Returns the last tempo change not greater than this time and the next tempo change\"\"\"\n\n        for i, (when, _) in enumerate(self._tempos):\n\n            # Reached end of list, yield last tempo and only change at \"infinity\"\n            # ie. listen for new tempos but do nothing\n            if (i == len(self.tempos) - 1):\n                return (math.inf, self._tempos[-1][1])\n\n            # Found a tempo change that's one index greater than the current one\n            if (time &lt;= when):\n                return (when, self._tempos[i-1][1])\n\n        # On an empty tempos list, keep listening and default to 120 BPM\n        return (math.inf, 120)\n\n    def load(self, file: Path) -&gt; Iterable[Events]:\n        \"\"\"\n        Warn: Only files with all Tempo changes on the first track will be precisely parsed\n        \"\"\"\n\n        # Reading to a bytearray, memoryview is slower than buffered io\n        stream = io.BytesIO(Path(file).read_bytes())\n        _end = len(stream.getbuffer())\n        position = 0\n\n        # --------------------------------------|\n\n        # Note: We REALLY want to avoid self or lambdas, as these methods\n        # Note: are called SO MANY TIMES that it's not even funny\n\n        # Fixme: Slowest bottleneck, I tried\n        def read_variable_length() -&gt; int:\n            nonlocal position\n            value = 0\n            while True:\n                position += 1\n                byte = int.from_bytes(stream.read(1))\n                value = (value * BIT_SHIFT_7) | (byte &amp; 0x7F)\n                if (byte &amp; 0x80) == 0:\n                    return value\n\n        def read_string() -&gt; Union[str, bytes]:\n            nonlocal position\n            length = int.from_bytes(stream.read(1))\n            position += 1 + length\n            return stream.read(length).decode(encoding=\"utf-8\", errors=\"replace\")\n\n        # --------------------------------------|\n\n        # The chunk id start must be MThd (0x4D546864)\n        if (stream.read(4) != b\"MThd\"):\n            raise Exception(\"Invalid MIDI file\")\n        position += 4\n\n        # Skip chunk size as it's always 6\n        stream.read(4)\n        position += 4\n\n        # Read basic metadata\n        self.format = int.from_bytes(stream.read(2))\n        self.tracks = int.from_bytes(stream.read(2))\n        self.tempos.clear()\n        position += 4\n\n        if (self.format == 0) and (self.tracks &gt; 1):\n            raise Exception(\"Midi format 0 with more than one track\")\n\n        # Read the time division\n        time_division = int.from_bytes(stream.read(2))\n        position += 2\n\n        # Top bit is zero, then it's ticks per beat\n        if (time_division &amp; 0x8000) == 0:\n            ticks_per_beat = (time_division &amp; 0x7FFF)\n\n        # Top bit is one, then it's frames per second\n        else:\n            raise NotImplementedError(\"Frames per Second (SMPTE) Midi time division isn't implemented\")\n            _frames_per_second = (time_division &amp; 0x7F00) &gt;&gt; 8\n            _ticks_per_frame = (time_division &amp; 0x00FF)\n\n        # --------------------------------------|\n\n        # Read the tracks\n        for track in range(self.tracks):\n            chunk_id = stream.read(4)\n            position += 4\n\n            # Premature end of file or invalid start of track\n            if (chunk_id != b\"MTrk\"):\n                raise Exception(f\"Invalid MIDI file, expected ('MTrk'=0x4D546864) but got (0x{chunk_id.hex()})\")\n            elif (chunk_id == b\"\"):\n                break\n\n            # Trackers\n            pressing = dict()\n            time: float = 0\n\n            # Assume 120 BPM if no tempo is set\n            changes, tempo = self._tempo(time)\n            print(\"\u2022 New: Changed to\", tempo, \"at\", time, \"next on\", changes)\n\n            # Multiply by delta time to get seconds\n            seconds_per_tick = ((60/tempo)/ticks_per_beat)\n\n            # Read the chunk size of this track\n            chunk_size = int.from_bytes(stream.read(4))\n            position += 4\n            chunk_end = position + chunk_size\n\n            # Control events: Constant size two bytes as arguments\n            while (position &lt; chunk_end):\n                delta = read_variable_length()\n                byte  = int.from_bytes(stream.read(1))\n                position += 1\n\n                # Maybe reached EOF\n                if byte == b\"\":\n                    break\n\n                # Control events\n                elif (0x80 &lt;= byte &lt;= 0xEF):\n                    type    = (byte &amp; 0xF0)\n                    channel = (byte &amp; 0x0F)\n                    word    = int.from_bytes(stream.read(2))\n                    options = ((word &amp; 0xFF00)//BIT_SHIFT_8, (word &amp; 0x00FF))\n                    position += 2\n\n                    # Note ON and OFF events - Yield full duration notes\n                    if (off := (type == 0x80)) or (type == 0x90):\n                        time += (delta * seconds_per_tick)\n\n                        # Change tempo if needed\n                        if (changes &lt; time):\n                            changes, tempo = self._tempo(time)\n                            print(\"\u2022 Inner: Changed to\", tempo, \"at\", time, \"next on\", changes)\n\n                        note, velocity = options\n\n                        # If there was a note playing or same-note on, yield it\n                        if (other := pressing.get(channel, {}).pop(note, None)):\n                            other.end = time\n                            yield other\n\n                        # Insert a partial note on note_on\n                        if not (off or (velocity==0)):\n                            # print(\"Note\", note)\n                            pressing.setdefault(channel, {})[note] = Events.Note(\n                                note=note,\n                                velocity=velocity,\n                                channel=channel,\n                                start=time,\n                            )\n\n                    elif (type == 0xA0):\n                        pressure, note = options\n                        yield Events.Pressure(\n                            note=note,\n                            pressure=pressure,\n                            time=time,\n                        )\n\n                    elif (type == 0xB0):\n                        yield Events.Controller(\n                            controller=options[0],\n                            value=options[1],\n                            time=time,\n                        )\n\n                    elif (type == 0xC0):\n                        yield Events.Program(\n                            program=options[0],\n                            time=time,\n                        )\n\n                    elif (type == 0xD0):\n                        yield Events.ChannelPressure(\n                            pressure=options[0],\n                            time=time,\n                        )\n\n                    elif (type == 0xE0):\n                        yield Events.PitchBend(\n                            value=options[0] + (options[1] * BIT_SHIFT_7),\n                            time=time,\n                        )\n\n                # Meta events: Variable content length based on type\n                elif (byte == 0xFF):\n                    type = int.from_bytes(stream.read(1))\n                    position += 1\n\n                    if (type == 0x00):\n                        yield Events.SequenceNumber(\n                            value=int.from_bytes(stream.read(2)),\n                            time=time,\n                        )\n                        position += 2\n\n                    elif (type == 0x01):\n                        yield Events.Text(\n                            text=read_string(),\n                            time=time,\n                        )\n\n                    elif (type == 0x02):\n                        yield Events.Copyright(\n                            text=read_string(),\n                            time=time,\n                        )\n\n                    elif (type == 0x03):\n                        yield Events.TrackName(\n                            text=read_string(),\n                            time=time,\n                        )\n\n                    elif (type == 0x04):\n                        yield Events.InstrumentName(\n                            text=read_string(),\n                            time=time,\n                        )\n\n                        yield Events.Lyrics(\n                            text=read_string(),\n                            time=time,\n                        )\n\n                    elif (type == 0x06):\n                        yield Events.Marker(\n                            text=read_string(),\n                            time=time,\n                        )\n\n                    elif (type == 0x07):\n                        yield Events.CuePoint(\n                            text=read_string(),\n                            time=time,\n                        )\n\n                    elif (type == 0x20):\n                        yield Events.MidiChannelPrefix(\n                            channel=int.from_bytes(stream.read(1)),\n                            time=time,\n                        )\n                        position += 1\n\n                    elif (type == 0x2F):\n                        yield Events.EndTrack()\n                        stream.read(1)\n                        position += 1\n                        break\n\n                    elif (type == 0x51):\n                        mpqn  = int.from_bytes(stream.read(3))\n                        tempo = (MICROSECONDS_PER_MINUTE/mpqn)\n                        seconds_per_tick = ((60/tempo)/ticks_per_beat)\n                        self.tempos.append((time, tempo))\n                        yield Events.SetTempo(mpqn=mpqn, time=time)\n                        position += 3\n                        # print(f\"Tempo: {tempo:.2f} ({time=})\")\n\n                    elif (type == 0x54):\n                        yield Events.SMTPEOffset(\n                            hours=    int.from_bytes(stream.read(1)),\n                            minutes=  int.from_bytes(stream.read(1)),\n                            seconds=  int.from_bytes(stream.read(1)),\n                            frames=   int.from_bytes(stream.read(1)),\n                            subframes=int.from_bytes(stream.read(1)),\n                            time=time,\n                        )\n                        position += 5\n\n                    elif (type == 0x58):\n                        yield (_signature := Events.TimeSignature(\n                            numerator=     int.from_bytes(stream.read(1)),\n                            denominator=   int.from_bytes(stream.read(1)),\n                            metronome=     int.from_bytes(stream.read(1)),\n                            thirty_seconds=int.from_bytes(stream.read(1)),\n                            time=time,\n                        ))\n                        # tempo = (_signature.thirty_seconds)*(_signature.numerator)\n                        position += 4\n\n                    elif (type == 0x59):\n                        yield Events.KeySignature(\n                            key=  int.from_bytes(stream.read(1)),\n                            scale=int.from_bytes(stream.read(1)),\n                            time= time,\n                        )\n                        position += 2\n\n                    elif (type == 0x7F):\n                        yield Events.SequencerSpecific(\n                            text=read_variable_length(),\n                            time=time,\n                        )\n</code></pre>"},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Midi.format","title":"<code>format: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Midi.tracks","title":"<code>tracks: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Midi.tempos","title":"<code>tempos: Deque[Tuple[float, Tempo]]</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/umidi/#Core.Staging.umidi.Midi.load","title":"<code>load(file: Path) -&gt; Iterable[Events]</code>","text":"<p>Warn: Only files with all Tempo changes on the first track will be precisely parsed</p> Source code in <code>Broken/Core/Staging/umidi.py</code> Python<pre><code>def load(self, file: Path) -&gt; Iterable[Events]:\n    \"\"\"\n    Warn: Only files with all Tempo changes on the first track will be precisely parsed\n    \"\"\"\n\n    # Reading to a bytearray, memoryview is slower than buffered io\n    stream = io.BytesIO(Path(file).read_bytes())\n    _end = len(stream.getbuffer())\n    position = 0\n\n    # --------------------------------------|\n\n    # Note: We REALLY want to avoid self or lambdas, as these methods\n    # Note: are called SO MANY TIMES that it's not even funny\n\n    # Fixme: Slowest bottleneck, I tried\n    def read_variable_length() -&gt; int:\n        nonlocal position\n        value = 0\n        while True:\n            position += 1\n            byte = int.from_bytes(stream.read(1))\n            value = (value * BIT_SHIFT_7) | (byte &amp; 0x7F)\n            if (byte &amp; 0x80) == 0:\n                return value\n\n    def read_string() -&gt; Union[str, bytes]:\n        nonlocal position\n        length = int.from_bytes(stream.read(1))\n        position += 1 + length\n        return stream.read(length).decode(encoding=\"utf-8\", errors=\"replace\")\n\n    # --------------------------------------|\n\n    # The chunk id start must be MThd (0x4D546864)\n    if (stream.read(4) != b\"MThd\"):\n        raise Exception(\"Invalid MIDI file\")\n    position += 4\n\n    # Skip chunk size as it's always 6\n    stream.read(4)\n    position += 4\n\n    # Read basic metadata\n    self.format = int.from_bytes(stream.read(2))\n    self.tracks = int.from_bytes(stream.read(2))\n    self.tempos.clear()\n    position += 4\n\n    if (self.format == 0) and (self.tracks &gt; 1):\n        raise Exception(\"Midi format 0 with more than one track\")\n\n    # Read the time division\n    time_division = int.from_bytes(stream.read(2))\n    position += 2\n\n    # Top bit is zero, then it's ticks per beat\n    if (time_division &amp; 0x8000) == 0:\n        ticks_per_beat = (time_division &amp; 0x7FFF)\n\n    # Top bit is one, then it's frames per second\n    else:\n        raise NotImplementedError(\"Frames per Second (SMPTE) Midi time division isn't implemented\")\n        _frames_per_second = (time_division &amp; 0x7F00) &gt;&gt; 8\n        _ticks_per_frame = (time_division &amp; 0x00FF)\n\n    # --------------------------------------|\n\n    # Read the tracks\n    for track in range(self.tracks):\n        chunk_id = stream.read(4)\n        position += 4\n\n        # Premature end of file or invalid start of track\n        if (chunk_id != b\"MTrk\"):\n            raise Exception(f\"Invalid MIDI file, expected ('MTrk'=0x4D546864) but got (0x{chunk_id.hex()})\")\n        elif (chunk_id == b\"\"):\n            break\n\n        # Trackers\n        pressing = dict()\n        time: float = 0\n\n        # Assume 120 BPM if no tempo is set\n        changes, tempo = self._tempo(time)\n        print(\"\u2022 New: Changed to\", tempo, \"at\", time, \"next on\", changes)\n\n        # Multiply by delta time to get seconds\n        seconds_per_tick = ((60/tempo)/ticks_per_beat)\n\n        # Read the chunk size of this track\n        chunk_size = int.from_bytes(stream.read(4))\n        position += 4\n        chunk_end = position + chunk_size\n\n        # Control events: Constant size two bytes as arguments\n        while (position &lt; chunk_end):\n            delta = read_variable_length()\n            byte  = int.from_bytes(stream.read(1))\n            position += 1\n\n            # Maybe reached EOF\n            if byte == b\"\":\n                break\n\n            # Control events\n            elif (0x80 &lt;= byte &lt;= 0xEF):\n                type    = (byte &amp; 0xF0)\n                channel = (byte &amp; 0x0F)\n                word    = int.from_bytes(stream.read(2))\n                options = ((word &amp; 0xFF00)//BIT_SHIFT_8, (word &amp; 0x00FF))\n                position += 2\n\n                # Note ON and OFF events - Yield full duration notes\n                if (off := (type == 0x80)) or (type == 0x90):\n                    time += (delta * seconds_per_tick)\n\n                    # Change tempo if needed\n                    if (changes &lt; time):\n                        changes, tempo = self._tempo(time)\n                        print(\"\u2022 Inner: Changed to\", tempo, \"at\", time, \"next on\", changes)\n\n                    note, velocity = options\n\n                    # If there was a note playing or same-note on, yield it\n                    if (other := pressing.get(channel, {}).pop(note, None)):\n                        other.end = time\n                        yield other\n\n                    # Insert a partial note on note_on\n                    if not (off or (velocity==0)):\n                        # print(\"Note\", note)\n                        pressing.setdefault(channel, {})[note] = Events.Note(\n                            note=note,\n                            velocity=velocity,\n                            channel=channel,\n                            start=time,\n                        )\n\n                elif (type == 0xA0):\n                    pressure, note = options\n                    yield Events.Pressure(\n                        note=note,\n                        pressure=pressure,\n                        time=time,\n                    )\n\n                elif (type == 0xB0):\n                    yield Events.Controller(\n                        controller=options[0],\n                        value=options[1],\n                        time=time,\n                    )\n\n                elif (type == 0xC0):\n                    yield Events.Program(\n                        program=options[0],\n                        time=time,\n                    )\n\n                elif (type == 0xD0):\n                    yield Events.ChannelPressure(\n                        pressure=options[0],\n                        time=time,\n                    )\n\n                elif (type == 0xE0):\n                    yield Events.PitchBend(\n                        value=options[0] + (options[1] * BIT_SHIFT_7),\n                        time=time,\n                    )\n\n            # Meta events: Variable content length based on type\n            elif (byte == 0xFF):\n                type = int.from_bytes(stream.read(1))\n                position += 1\n\n                if (type == 0x00):\n                    yield Events.SequenceNumber(\n                        value=int.from_bytes(stream.read(2)),\n                        time=time,\n                    )\n                    position += 2\n\n                elif (type == 0x01):\n                    yield Events.Text(\n                        text=read_string(),\n                        time=time,\n                    )\n\n                elif (type == 0x02):\n                    yield Events.Copyright(\n                        text=read_string(),\n                        time=time,\n                    )\n\n                elif (type == 0x03):\n                    yield Events.TrackName(\n                        text=read_string(),\n                        time=time,\n                    )\n\n                elif (type == 0x04):\n                    yield Events.InstrumentName(\n                        text=read_string(),\n                        time=time,\n                    )\n\n                    yield Events.Lyrics(\n                        text=read_string(),\n                        time=time,\n                    )\n\n                elif (type == 0x06):\n                    yield Events.Marker(\n                        text=read_string(),\n                        time=time,\n                    )\n\n                elif (type == 0x07):\n                    yield Events.CuePoint(\n                        text=read_string(),\n                        time=time,\n                    )\n\n                elif (type == 0x20):\n                    yield Events.MidiChannelPrefix(\n                        channel=int.from_bytes(stream.read(1)),\n                        time=time,\n                    )\n                    position += 1\n\n                elif (type == 0x2F):\n                    yield Events.EndTrack()\n                    stream.read(1)\n                    position += 1\n                    break\n\n                elif (type == 0x51):\n                    mpqn  = int.from_bytes(stream.read(3))\n                    tempo = (MICROSECONDS_PER_MINUTE/mpqn)\n                    seconds_per_tick = ((60/tempo)/ticks_per_beat)\n                    self.tempos.append((time, tempo))\n                    yield Events.SetTempo(mpqn=mpqn, time=time)\n                    position += 3\n                    # print(f\"Tempo: {tempo:.2f} ({time=})\")\n\n                elif (type == 0x54):\n                    yield Events.SMTPEOffset(\n                        hours=    int.from_bytes(stream.read(1)),\n                        minutes=  int.from_bytes(stream.read(1)),\n                        seconds=  int.from_bytes(stream.read(1)),\n                        frames=   int.from_bytes(stream.read(1)),\n                        subframes=int.from_bytes(stream.read(1)),\n                        time=time,\n                    )\n                    position += 5\n\n                elif (type == 0x58):\n                    yield (_signature := Events.TimeSignature(\n                        numerator=     int.from_bytes(stream.read(1)),\n                        denominator=   int.from_bytes(stream.read(1)),\n                        metronome=     int.from_bytes(stream.read(1)),\n                        thirty_seconds=int.from_bytes(stream.read(1)),\n                        time=time,\n                    ))\n                    # tempo = (_signature.thirty_seconds)*(_signature.numerator)\n                    position += 4\n\n                elif (type == 0x59):\n                    yield Events.KeySignature(\n                        key=  int.from_bytes(stream.read(1)),\n                        scale=int.from_bytes(stream.read(1)),\n                        time= time,\n                    )\n                    position += 2\n\n                elif (type == 0x7F):\n                    yield Events.SequencerSpecific(\n                        text=read_variable_length(),\n                        time=time,\n                    )\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/baseloader/","title":"BaseLoader","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader","title":"<code>Core.Staging.Dotmap.BaseLoader</code>","text":""},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.T","title":"<code>Core.Staging.Dotmap.BaseLoader.T = TypeVar('T')</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader","title":"<code>Core.Staging.Dotmap.BaseLoader.DotmapLoader</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BaseLoader.py</code> Python<pre><code>@define\nclass DotmapLoader(ABC):\n\n    # ------------------------------------------|\n    # # Registration and initialization\n\n    loaders        = set()\n    __acronyms__   = {}\n\n    def register(cls: Type[Self]) -&gt; None:\n        \"\"\"Register a new loader\"\"\"\n        DotmapLoader.loaders.add(cls)\n\n        # Add loader acronyms\n        for acronym in cls.acronyms():\n            if acronym in DotmapLoader.__acronyms__:\n                log.warning(f\"Overriding loader acronym {acronym} with {cls}\")\n            DotmapLoader.__acronyms__[acronym] = cls\n\n    # # Initialization methods\n\n    def from_acronym(acronym: str) -&gt; Optional[Self]:\n        \"\"\"Try finding a loader from its acronym\"\"\"\n        return DotmapLoader.__acronyms__.get(acronym, None)\n\n    def smart_find(key: str=None, value: Any=None) -&gt; Optional[Self]:\n        \"\"\"Find a loader that can load the given key\"\"\"\n        suffix = Path(key).suffix.replace(\".\", \"\").lower()\n\n        if (loader := DotmapLoader.from_acronym(suffix)):\n            return loader\n        # for loader in DotmapLoader.loaders:\n        #     if loader.load(value=value):\n        #         return loader\n        return None\n\n    # ------------------------------------------|\n    # # Proper methods\n\n    value: Any = field(default=None)\n\n    @staticmethod\n    @abstractmethod\n    def acronyms(self) -&gt; Set[str]:\n        ...\n\n    @abstractmethod\n    def load() -&gt; T:\n        ...\n\n    @abstractmethod\n    def dump(path: Path) -&gt; None:\n        ...\n\n    # ------------------------------------------|\n\n    # # Default implementations\n\n    def __call__(self, value: Any) -&gt; T:\n        \"\"\"Handle calling the instance as a function\"\"\"\n        return type(self).load(value)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.loaders","title":"<code>loaders = set()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.__acronyms__","title":"<code>__acronyms__ = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.register","title":"<code>register() -&gt; None</code>","text":"<p>Register a new loader</p> Source code in <code>Broken/Core/Staging/Dotmap/BaseLoader.py</code> Python<pre><code>def register(cls: Type[Self]) -&gt; None:\n    \"\"\"Register a new loader\"\"\"\n    DotmapLoader.loaders.add(cls)\n\n    # Add loader acronyms\n    for acronym in cls.acronyms():\n        if acronym in DotmapLoader.__acronyms__:\n            log.warning(f\"Overriding loader acronym {acronym} with {cls}\")\n        DotmapLoader.__acronyms__[acronym] = cls\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.from_acronym","title":"<code>from_acronym(acronym: str) -&gt; Optional[Self]</code>","text":"<p>Try finding a loader from its acronym</p> Source code in <code>Broken/Core/Staging/Dotmap/BaseLoader.py</code> Python<pre><code>def from_acronym(acronym: str) -&gt; Optional[Self]:\n    \"\"\"Try finding a loader from its acronym\"\"\"\n    return DotmapLoader.__acronyms__.get(acronym, None)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.smart_find","title":"<code>smart_find(key: str = None, value: Any = None) -&gt; Optional[Self]</code>","text":"<p>Find a loader that can load the given key</p> Source code in <code>Broken/Core/Staging/Dotmap/BaseLoader.py</code> Python<pre><code>def smart_find(key: str=None, value: Any=None) -&gt; Optional[Self]:\n    \"\"\"Find a loader that can load the given key\"\"\"\n    suffix = Path(key).suffix.replace(\".\", \"\").lower()\n\n    if (loader := DotmapLoader.from_acronym(suffix)):\n        return loader\n    # for loader in DotmapLoader.loaders:\n    #     if loader.load(value=value):\n    #         return loader\n    return None\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.value","title":"<code>value: Any = field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.acronyms","title":"<code>acronyms() -&gt; Set[str]</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BaseLoader.py</code> Python<pre><code>@staticmethod\n@abstractmethod\ndef acronyms(self) -&gt; Set[str]:\n    ...\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.load","title":"<code>load() -&gt; T</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BaseLoader.py</code> Python<pre><code>@abstractmethod\ndef load() -&gt; T:\n    ...\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.dump","title":"<code>dump(path: Path) -&gt; None</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BaseLoader.py</code> Python<pre><code>@abstractmethod\ndef dump(path: Path) -&gt; None:\n    ...\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/baseloader/#Core.Staging.Dotmap.BaseLoader.DotmapLoader.__call__","title":"<code>__call__(value: Any) -&gt; T</code>","text":"<p>Handle calling the instance as a function</p> Source code in <code>Broken/Core/Staging/Dotmap/BaseLoader.py</code> Python<pre><code>def __call__(self, value: Any) -&gt; T:\n    \"\"\"Handle calling the instance as a function\"\"\"\n    return type(self).load(value)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/","title":"BrokenDotmap","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap","title":"<code>Core.Staging.Dotmap.BrokenDotmap</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.GLOBAL_UUID","title":"<code>Core.Staging.Dotmap.BrokenDotmap.GLOBAL_UUID = 0</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.__next_uuid__","title":"<code>Core.Staging.Dotmap.BrokenDotmap.__next_uuid__()</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __next_uuid__():\n    global GLOBAL_UUID\n    GLOBAL_UUID += 1\n    return GLOBAL_UUID\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap","title":"<code>Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>class BrokenDotmap(\n    collections.abc.MutableMapping,\n    collections.abc.Mapping,\n    collections.OrderedDict\n):\n    def __init__(self,\n        data: Dict[str, Any]=None,\n        *,\n        path: Path=None,\n        sync: bool=True,\n        auto: bool=True,\n\n        # Internal\n        _super:  Self=None,\n        _parent: Self=None,\n        _name:   str=None,\n        **kwargs\n    ):\n\n        # Initialize attributes\n        self.__path__   = BrokenPath(path)\n        self.__disk__   = bool(self.__path__)\n        self.__sync__   = sync\n        self.__auto__   = auto\n        self.__super__  = _super or self\n        self.__parent__ = _parent\n        self.__name__   = _name\n        self.__uuid__   = __next_uuid__()\n\n        # Update data with kwargs and load\n        data = (data or {}) | kwargs\n        self.from_dict(data)\n\n        # Can any loader load from path?\n        if self.__disk__ and not data:\n            if (loader := DotmapLoader.smart_find(key=self.__path__)):\n                self.from_dict(loader(self.__path__).load())\n\n    # # Internal\n\n    @property\n    def __is_super__(self) -&gt; bool:\n        return self == self.__super__\n\n    def __recurse__(self, key: str=None, value=None) -&gt; Self:\n        log.trace(f\"({self.__uuid__:2}) self.__recurse__(data={value}, key={key})\")\n        if isinstance(value, dict) or value is None:\n            log.trace(\"\u2022 Recursing with Self class\")\n            return type(self)(\n                _super  = self.__super__,\n                _parent = self,\n                _name   = key\n            ).from_dict(value)\n        return value\n\n    # # Loading and saving as Python dictionary\n\n    def from_dict(self, data: Dict=None) -&gt; Self:\n        \"\"\"Append a dictionary to this instance\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.from_dict(data={data})\")\n\n        # Transform self to a dictionary\n        if isinstance(data, type(self)):\n            data = data.as_dict\n\n        # Recurse on all values\n        for key, value in (data or {}).items():\n            self.set(key, self.__recurse__(key=key, value=value))\n\n        return self\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Get a dictionary from this instance downwards\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.to_dict()\")\n        return {\n            k: v.to_dict() if isinstance(v, type(self)) else v\n            for k, v in sorted(self.items(), key=lambda x: x[0])\n            if not dunder(k)\n        }\n\n    @property\n    def as_dict(self) -&gt; Dict[str, Any]:\n        log.trace(f\"({self.__uuid__:2}) self.as_dict\")\n        return self.to_dict()\n\n    @property\n    def dict(self) -&gt; Dict[str, Any]:\n        log.trace(f\"({self.__uuid__:2}) self.dict\")\n        return self.to_dict()\n\n    # # Base dictionary methods\n\n    def items(self) -&gt; Dict[str, Any]:\n        log.trace(f\"({self.__uuid__:2}) self.items()\")\n        return [(k, v) for k, v in self.__dict__.items() if not dunder(k)]\n\n    def keys(self) -&gt; list:\n        log.trace(f\"({self.__uuid__:2}) self.keys()\")\n        return [k for k in self.__dict__.keys() if not dunder(k)]\n\n    def values(self) -&gt; list:\n        log.trace(f\"({self.__uuid__:2}) self.values()\")\n        return [v for k, v in self.__dict__.items() if not dunder(k)]\n\n    # # Random dunder\n\n    def __len__(self) -&gt; int:\n        return len(self.keys())\n\n    def __iter__(self) -&gt; Iterator:\n        return iter(self.keys())\n\n    def delete(self, key: str) -&gt; None:\n        # if self.__disk__:\n            # (self.disk_path/key).unlink()\n        del self.__dict__[key]\n\n    def __delitem__(self, key: str) -&gt; None:\n        self.delete(key)\n\n    def __delattr__(self, key: str) -&gt; None:\n        self.delete(key)\n\n    def __contains__(self, key: str) -&gt; bool:\n        return key in self.__dict__\n\n    def __add__(self, other: Any) -&gt; Self:\n        if isinstance(other, dict):\n            self.update(other)\n            return self\n\n        if isinstance(other, type(self)):\n            self.update(other.as_dict)\n            return self\n\n        raise TypeError(f\"Cannot add {type(other)} to {type(self)}\")\n\n    # # Cool utilities\n\n    def update(self, other: Dict[str, Any], **kwargs) -&gt; Self:\n        self.__dict__.update((other or dict()) | kwargs)\n        return self\n\n    def copy(self):\n        return self.from_dict(self.as_dict)\n\n    def pop(self, key: str, default: Any=None) -&gt; Any:\n        return self.__dict__.pop(key, default)\n\n    def pretty_print(self, indent: int=4) -&gt; None:\n        try:\n            from rich import print as rich_print\n            rich_print(self.as_dict)\n        except ImportError:\n            print(json.dumps(self.as_dict, indent=indent, ensure_ascii=False))\n\n    # # Define get methods\n\n    def get(self, key: str) -&gt; Union[Self, Any]:\n        \"\"\"If a key doesn't exist, recurse, else return its the value\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.get(key={key})\")\n        return self.__dict__.setdefault(key, self.__recurse__(key=key))\n\n    def __getitem__(self, key: str) -&gt; Union[Self, Any]:\n        \"\"\"Handle dictionary item access using key indexing\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.__getitem__(key={key})\")\n        return self.get(key)\n\n    def __getattr__(self, key: str) -&gt; Union[Self, Any]:\n        \"\"\"Handle attribute access using dot notation\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.__getattr__(key={key})\")\n        return self.get(key)\n\n    # # Define set methods\n\n    def set(self,\n        key: str,\n        value: Any=None,\n        loader: DotmapLoader=None,\n    ) -&gt; Any:\n        \"\"\"Set a key to a value, recurses on the value\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.set(key={key}, value={value})\")\n\n        dot_key = key.replace(\"_\", \".\")\n\n        # Directly received a loader\n        if loader or not self.__auto__:\n            pass\n\n        # Value is a loader\n        elif issubclass(type(value), DotmapLoader):\n            loader = value\n\n        # Find any loaders that can load the input\n        else:\n            if (loader := DotmapLoader.smart_find(key=dot_key, value=value)):\n                log.trace(f\"\u2022 Matched Loader: {loader.__name__}\")\n\n        # Standard recurse on the value\n        if not loader:\n            self.__dict__[key] = self.__recurse__(key=key, value=value)\n            self.__name__ = key\n            self.sync()\n            return value\n\n        sync: bool = True\n\n        # Build path if disk, change value to be loaded from it\n        if self.__disk__:\n            path  = self.disk_path/dot_key\n            value = path if path.exists() else value\n            log.trace(f\"\u2022 Using path: {path}\")\n\n        # We have a loader class, not a loader instance\n        if not isinstance(loader, DotmapLoader):\n            value = loader(value).load()\n\n        # We have an instance of a loader\n        else:\n            if self.__disk__:\n                value = loader(path).load()\n            else:\n                value = loader.load()\n\n        # Replace this instance of Self with the loaded value on parent\n        (self.__parent__ or self).__dict__[key] = value\n        self.__sync_key__(key=key, value=value)\n        return value\n\n    def __setitem__(self, key: str, value: Any) -&gt; Union[Self, Any]:\n        \"\"\"Handle dictionary item assignment using key indexing\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.__setitem__(key={key}, value={value})\")\n        return self.set(key=key, value=value)\n\n    def __setattr__(self, key: str, value: Any) -&gt; Union[Self, Any]:\n        \"\"\"Handle attribute assignment using dot notation\"\"\"\n\n        # Do not \"recurse\" on dunder attributes, they are self!\n        if dunder(key):\n            self.__dict__[key] = value\n            return\n\n        log.trace(f\"({self.__uuid__:2}) self.__setattr__(key={key}, value={value})\")\n        return self.set(key=key, value=value)\n\n    def __call__(self, value: Any) -&gt; Union[Self, Any]:\n        \"\"\"Handle calling the instance as a function\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.__call__(value={value})\")\n        return self.set(key=self.__name__, value=value)\n\n    # # Syncing\n\n    @contextlib.contextmanager\n    def no_sync(self, after: bool=True) -&gt; Self:\n        \"\"\"\n        Temporarily disables syncing\n\n        Args:\n            after: Whether to sync after the context exits\n\n        Returns:\n            Self: Fluent interface\n        \"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.no_sync()\")\n        self.__super__.__sync__ = False\n        yield self\n        self.__super__.__sync__ = after\n        self.sync()\n\n    def enable_sync(self) -&gt; None:\n        self.__super__.__sync__ = True\n\n    def disable_sync(self) -&gt; None:\n        self.__super__.__sync__ = False\n\n    def __sync_key__(self, key: str, value: Any=None) -&gt; Self:\n        if not (self.__disk__ and self.__sync__):\n            return self\n\n        if (path := self.disk_path/key.replace(\"_\", \".\")).exists():\n            log.trace(f\"\u2022 Skipping syncing to path {path} as it exists\")\n            return self\n\n        # # Can any loader save this key?\n        if (loader := DotmapLoader.smart_find(key=path, value=value)):\n            log.trace(f\"\u2022 Matched save nested Loader: {loader.__name__}\")\n            loader(value).dump(path=BrokenPath.mkdir(path))\n\n    def sync(self) -&gt; Self:\n        log.trace(f\"({self.__uuid__:2}) self.sync()\")\n\n        # Must call sync on the super instance\n        if not self.__is_super__:\n            return self.__super__.sync()\n\n        # Syncing must be enabled\n        if not self.__sync__:\n            log.trace(\"\u2022 Syncing disabled\")\n            return self\n\n        # Do nothing on non-disk mode\n        if not self.__disk__:\n            return self\n\n        path = self.disk_path\n        log.trace(f\"\u2022 Syncing to disk: {path}\")\n\n        # Can any loader save the entirety of self?\n        if (loader := DotmapLoader.smart_find(key=path, value=self.as_dict)):\n            log.trace(f\"\u2022 Matched save Loader: {loader.__name__}\")\n            loader(self.as_dict).dump(path=BrokenPath.mkdir(path))\n            return self\n\n        # Else save each key individually, recursively\n        def save(path: Path, data: Dict[str, Any]):\n            for key, value in data.items():\n                if isinstance(value, dict):\n                    save(path/key, value)\n                    continue\n                self.__sync_key__(key, value)\n\n        save(path, self.as_dict)\n\n    # # Utilities\n\n    def default(self, key: str, value: Any) -&gt; Any:\n        \"\"\"Set a default value for a key else don't change, returns it\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.default(key={key}, value={value})\")\n\n        # Return the value if it exists\n        if key in self.__dict__:\n            return self.__dict__[key]\n\n        # Set the value and sync (call it if callable - a use as a cache)\n        return self.set(key, value() if callable(value) else value)\n\n    def setdefault(self, key: str, value: Any) -&gt; Any:\n        \"\"\"Set a default value for a key else don't change, returns it\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.setdefault(key={key}, value={value})\")\n        return self.default(key, value)\n\n    def inverse(self, value: Any) -&gt; Any | None:\n        \"\"\"Search by value\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.inverse(value={value})\")\n        return next((k for k, v in self.items() if v == value), None)\n\n    # # Disk mode\n\n    @property\n    def disk_path(self) -&gt; Path:\n        \"\"\"Get the path to the file on disk\"\"\"\n        log.trace(f\"({self.__uuid__:2}) self.disk_path\")\n\n        # The super instance is the one who saves to disk\n        if not self.__is_super__:\n            return self.__super__.disk_path\n\n        return self.__path__\n\n        # Traverse up the tree to get the path\n        components = []\n\n        while self.__name__:\n            components.append(self.__name__)\n            self = self.__parent__\n\n        # Build the path plus base\n        return Path(*reversed(components + [self.__path__]))\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__init__","title":"<code>__init__(data: Dict[str, Any] = None, *, path: Path = None, sync: bool = True, auto: bool = True, _super: Self = None, _parent: Self = None, _name: str = None, **kwargs)</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __init__(self,\n    data: Dict[str, Any]=None,\n    *,\n    path: Path=None,\n    sync: bool=True,\n    auto: bool=True,\n\n    # Internal\n    _super:  Self=None,\n    _parent: Self=None,\n    _name:   str=None,\n    **kwargs\n):\n\n    # Initialize attributes\n    self.__path__   = BrokenPath(path)\n    self.__disk__   = bool(self.__path__)\n    self.__sync__   = sync\n    self.__auto__   = auto\n    self.__super__  = _super or self\n    self.__parent__ = _parent\n    self.__name__   = _name\n    self.__uuid__   = __next_uuid__()\n\n    # Update data with kwargs and load\n    data = (data or {}) | kwargs\n    self.from_dict(data)\n\n    # Can any loader load from path?\n    if self.__disk__ and not data:\n        if (loader := DotmapLoader.smart_find(key=self.__path__)):\n            self.from_dict(loader(self.__path__).load())\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__path__","title":"<code>__path__ = BrokenPath(path)</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__disk__","title":"<code>__disk__ = bool(self.__path__)</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__sync__","title":"<code>__sync__ = sync</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__auto__","title":"<code>__auto__ = auto</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__super__","title":"<code>__super__ = _super or self</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__parent__","title":"<code>__parent__ = _parent</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__name__","title":"<code>__name__ = _name</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__uuid__","title":"<code>__uuid__ = __next_uuid__()</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__is_super__","title":"<code>__is_super__: bool</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__recurse__","title":"<code>__recurse__(key: str = None, value=None) -&gt; Self</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __recurse__(self, key: str=None, value=None) -&gt; Self:\n    log.trace(f\"({self.__uuid__:2}) self.__recurse__(data={value}, key={key})\")\n    if isinstance(value, dict) or value is None:\n        log.trace(\"\u2022 Recursing with Self class\")\n        return type(self)(\n            _super  = self.__super__,\n            _parent = self,\n            _name   = key\n        ).from_dict(value)\n    return value\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.from_dict","title":"<code>from_dict(data: Dict = None) -&gt; Self</code>","text":"<p>Append a dictionary to this instance</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def from_dict(self, data: Dict=None) -&gt; Self:\n    \"\"\"Append a dictionary to this instance\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.from_dict(data={data})\")\n\n    # Transform self to a dictionary\n    if isinstance(data, type(self)):\n        data = data.as_dict\n\n    # Recurse on all values\n    for key, value in (data or {}).items():\n        self.set(key, self.__recurse__(key=key, value=value))\n\n    return self\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Get a dictionary from this instance downwards</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Get a dictionary from this instance downwards\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.to_dict()\")\n    return {\n        k: v.to_dict() if isinstance(v, type(self)) else v\n        for k, v in sorted(self.items(), key=lambda x: x[0])\n        if not dunder(k)\n    }\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.as_dict","title":"<code>as_dict: Dict[str, Any]</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.dict","title":"<code>dict: Dict[str, Any]</code>  <code>property</code>","text":""},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.items","title":"<code>items() -&gt; Dict[str, Any]</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def items(self) -&gt; Dict[str, Any]:\n    log.trace(f\"({self.__uuid__:2}) self.items()\")\n    return [(k, v) for k, v in self.__dict__.items() if not dunder(k)]\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.keys","title":"<code>keys() -&gt; list</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def keys(self) -&gt; list:\n    log.trace(f\"({self.__uuid__:2}) self.keys()\")\n    return [k for k in self.__dict__.keys() if not dunder(k)]\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.values","title":"<code>values() -&gt; list</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def values(self) -&gt; list:\n    log.trace(f\"({self.__uuid__:2}) self.values()\")\n    return [v for k, v in self.__dict__.items() if not dunder(k)]\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__len__","title":"<code>__len__() -&gt; int</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __len__(self) -&gt; int:\n    return len(self.keys())\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__iter__","title":"<code>__iter__() -&gt; Iterator</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __iter__(self) -&gt; Iterator:\n    return iter(self.keys())\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.delete","title":"<code>delete(key: str) -&gt; None</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def delete(self, key: str) -&gt; None:\n    # if self.__disk__:\n        # (self.disk_path/key).unlink()\n    del self.__dict__[key]\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__delitem__","title":"<code>__delitem__(key: str) -&gt; None</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __delitem__(self, key: str) -&gt; None:\n    self.delete(key)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__delattr__","title":"<code>__delattr__(key: str) -&gt; None</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __delattr__(self, key: str) -&gt; None:\n    self.delete(key)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__contains__","title":"<code>__contains__(key: str) -&gt; bool</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __contains__(self, key: str) -&gt; bool:\n    return key in self.__dict__\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__add__","title":"<code>__add__(other: Any) -&gt; Self</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __add__(self, other: Any) -&gt; Self:\n    if isinstance(other, dict):\n        self.update(other)\n        return self\n\n    if isinstance(other, type(self)):\n        self.update(other.as_dict)\n        return self\n\n    raise TypeError(f\"Cannot add {type(other)} to {type(self)}\")\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.update","title":"<code>update(other: Dict[str, Any], **kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def update(self, other: Dict[str, Any], **kwargs) -&gt; Self:\n    self.__dict__.update((other or dict()) | kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.copy","title":"<code>copy()</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def copy(self):\n    return self.from_dict(self.as_dict)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.pop","title":"<code>pop(key: str, default: Any = None) -&gt; Any</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def pop(self, key: str, default: Any=None) -&gt; Any:\n    return self.__dict__.pop(key, default)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.pretty_print","title":"<code>pretty_print(indent: int = 4) -&gt; None</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def pretty_print(self, indent: int=4) -&gt; None:\n    try:\n        from rich import print as rich_print\n        rich_print(self.as_dict)\n    except ImportError:\n        print(json.dumps(self.as_dict, indent=indent, ensure_ascii=False))\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.get","title":"<code>get(key: str) -&gt; Union[Self, Any]</code>","text":"<p>If a key doesn't exist, recurse, else return its the value</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def get(self, key: str) -&gt; Union[Self, Any]:\n    \"\"\"If a key doesn't exist, recurse, else return its the value\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.get(key={key})\")\n    return self.__dict__.setdefault(key, self.__recurse__(key=key))\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__getitem__","title":"<code>__getitem__(key: str) -&gt; Union[Self, Any]</code>","text":"<p>Handle dictionary item access using key indexing</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __getitem__(self, key: str) -&gt; Union[Self, Any]:\n    \"\"\"Handle dictionary item access using key indexing\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.__getitem__(key={key})\")\n    return self.get(key)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__getattr__","title":"<code>__getattr__(key: str) -&gt; Union[Self, Any]</code>","text":"<p>Handle attribute access using dot notation</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __getattr__(self, key: str) -&gt; Union[Self, Any]:\n    \"\"\"Handle attribute access using dot notation\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.__getattr__(key={key})\")\n    return self.get(key)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.set","title":"<code>set(key: str, value: Any = None, loader: DotmapLoader = None) -&gt; Any</code>","text":"<p>Set a key to a value, recurses on the value</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def set(self,\n    key: str,\n    value: Any=None,\n    loader: DotmapLoader=None,\n) -&gt; Any:\n    \"\"\"Set a key to a value, recurses on the value\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.set(key={key}, value={value})\")\n\n    dot_key = key.replace(\"_\", \".\")\n\n    # Directly received a loader\n    if loader or not self.__auto__:\n        pass\n\n    # Value is a loader\n    elif issubclass(type(value), DotmapLoader):\n        loader = value\n\n    # Find any loaders that can load the input\n    else:\n        if (loader := DotmapLoader.smart_find(key=dot_key, value=value)):\n            log.trace(f\"\u2022 Matched Loader: {loader.__name__}\")\n\n    # Standard recurse on the value\n    if not loader:\n        self.__dict__[key] = self.__recurse__(key=key, value=value)\n        self.__name__ = key\n        self.sync()\n        return value\n\n    sync: bool = True\n\n    # Build path if disk, change value to be loaded from it\n    if self.__disk__:\n        path  = self.disk_path/dot_key\n        value = path if path.exists() else value\n        log.trace(f\"\u2022 Using path: {path}\")\n\n    # We have a loader class, not a loader instance\n    if not isinstance(loader, DotmapLoader):\n        value = loader(value).load()\n\n    # We have an instance of a loader\n    else:\n        if self.__disk__:\n            value = loader(path).load()\n        else:\n            value = loader.load()\n\n    # Replace this instance of Self with the loaded value on parent\n    (self.__parent__ or self).__dict__[key] = value\n    self.__sync_key__(key=key, value=value)\n    return value\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__setitem__","title":"<code>__setitem__(key: str, value: Any) -&gt; Union[Self, Any]</code>","text":"<p>Handle dictionary item assignment using key indexing</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __setitem__(self, key: str, value: Any) -&gt; Union[Self, Any]:\n    \"\"\"Handle dictionary item assignment using key indexing\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.__setitem__(key={key}, value={value})\")\n    return self.set(key=key, value=value)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__setattr__","title":"<code>__setattr__(key: str, value: Any) -&gt; Union[Self, Any]</code>","text":"<p>Handle attribute assignment using dot notation</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __setattr__(self, key: str, value: Any) -&gt; Union[Self, Any]:\n    \"\"\"Handle attribute assignment using dot notation\"\"\"\n\n    # Do not \"recurse\" on dunder attributes, they are self!\n    if dunder(key):\n        self.__dict__[key] = value\n        return\n\n    log.trace(f\"({self.__uuid__:2}) self.__setattr__(key={key}, value={value})\")\n    return self.set(key=key, value=value)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__call__","title":"<code>__call__(value: Any) -&gt; Union[Self, Any]</code>","text":"<p>Handle calling the instance as a function</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __call__(self, value: Any) -&gt; Union[Self, Any]:\n    \"\"\"Handle calling the instance as a function\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.__call__(value={value})\")\n    return self.set(key=self.__name__, value=value)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.no_sync","title":"<code>no_sync(after: bool = True) -&gt; Self</code>","text":"<p>Temporarily disables syncing</p> <p>Parameters:</p> <ul> <li> <code>after</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to sync after the context exits</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (            <code>Self</code> )        \u2013          <p>Fluent interface</p> </li> </ul> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>@contextlib.contextmanager\ndef no_sync(self, after: bool=True) -&gt; Self:\n    \"\"\"\n    Temporarily disables syncing\n\n    Args:\n        after: Whether to sync after the context exits\n\n    Returns:\n        Self: Fluent interface\n    \"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.no_sync()\")\n    self.__super__.__sync__ = False\n    yield self\n    self.__super__.__sync__ = after\n    self.sync()\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.enable_sync","title":"<code>enable_sync() -&gt; None</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def enable_sync(self) -&gt; None:\n    self.__super__.__sync__ = True\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.disable_sync","title":"<code>disable_sync() -&gt; None</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def disable_sync(self) -&gt; None:\n    self.__super__.__sync__ = False\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.__sync_key__","title":"<code>__sync_key__(key: str, value: Any = None) -&gt; Self</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def __sync_key__(self, key: str, value: Any=None) -&gt; Self:\n    if not (self.__disk__ and self.__sync__):\n        return self\n\n    if (path := self.disk_path/key.replace(\"_\", \".\")).exists():\n        log.trace(f\"\u2022 Skipping syncing to path {path} as it exists\")\n        return self\n\n    # # Can any loader save this key?\n    if (loader := DotmapLoader.smart_find(key=path, value=value)):\n        log.trace(f\"\u2022 Matched save nested Loader: {loader.__name__}\")\n        loader(value).dump(path=BrokenPath.mkdir(path))\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.sync","title":"<code>sync() -&gt; Self</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def sync(self) -&gt; Self:\n    log.trace(f\"({self.__uuid__:2}) self.sync()\")\n\n    # Must call sync on the super instance\n    if not self.__is_super__:\n        return self.__super__.sync()\n\n    # Syncing must be enabled\n    if not self.__sync__:\n        log.trace(\"\u2022 Syncing disabled\")\n        return self\n\n    # Do nothing on non-disk mode\n    if not self.__disk__:\n        return self\n\n    path = self.disk_path\n    log.trace(f\"\u2022 Syncing to disk: {path}\")\n\n    # Can any loader save the entirety of self?\n    if (loader := DotmapLoader.smart_find(key=path, value=self.as_dict)):\n        log.trace(f\"\u2022 Matched save Loader: {loader.__name__}\")\n        loader(self.as_dict).dump(path=BrokenPath.mkdir(path))\n        return self\n\n    # Else save each key individually, recursively\n    def save(path: Path, data: Dict[str, Any]):\n        for key, value in data.items():\n            if isinstance(value, dict):\n                save(path/key, value)\n                continue\n            self.__sync_key__(key, value)\n\n    save(path, self.as_dict)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.default","title":"<code>default(key: str, value: Any) -&gt; Any</code>","text":"<p>Set a default value for a key else don't change, returns it</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def default(self, key: str, value: Any) -&gt; Any:\n    \"\"\"Set a default value for a key else don't change, returns it\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.default(key={key}, value={value})\")\n\n    # Return the value if it exists\n    if key in self.__dict__:\n        return self.__dict__[key]\n\n    # Set the value and sync (call it if callable - a use as a cache)\n    return self.set(key, value() if callable(value) else value)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.setdefault","title":"<code>setdefault(key: str, value: Any) -&gt; Any</code>","text":"<p>Set a default value for a key else don't change, returns it</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def setdefault(self, key: str, value: Any) -&gt; Any:\n    \"\"\"Set a default value for a key else don't change, returns it\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.setdefault(key={key}, value={value})\")\n    return self.default(key, value)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.inverse","title":"<code>inverse(value: Any) -&gt; Any | None</code>","text":"<p>Search by value</p> Source code in <code>Broken/Core/Staging/Dotmap/BrokenDotmap.py</code> Python<pre><code>def inverse(self, value: Any) -&gt; Any | None:\n    \"\"\"Search by value\"\"\"\n    log.trace(f\"({self.__uuid__:2}) self.inverse(value={value})\")\n    return next((k for k, v in self.items() if v == value), None)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/brokendotmap/#Core.Staging.Dotmap.BrokenDotmap.BrokenDotmap.disk_path","title":"<code>disk_path: Path</code>  <code>property</code>","text":"<p>Get the path to the file on disk</p>"},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/","title":"LoaderPIL","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/#Core.Staging.Dotmap.Loaders.LoaderPIL","title":"<code>Core.Staging.Dotmap.Loaders.LoaderPIL</code>","text":""},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/#Core.Staging.Dotmap.Loaders.LoaderPIL.Core/Staging/Dotmap/Loaders/LoaderTOML/*","title":"<code>Core.Staging.Dotmap.Loaders.LoaderPIL.Core/Staging/Dotmap/Loaders/LoaderTOML/*</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderTOML.py</code> Python<pre><code>class LoaderTOML(DotmapLoader):\n\n    @staticmethod\n    def acronyms() -&gt; Set[str]:\n        return {\"toml\"}\n\n    def load(self) -&gt; T:\n        log.debug(f\":: LoaderTOML.load() for value ({self.value})\")\n\n        if not self.value:\n            return None\n\n        elif isinstance(self.value, str):\n            log.debug(f\"  :: Using string\")\n            return BrokenDotmap(toml.loads(self.value))\n\n        elif isinstance(self.value, dict):\n            log.debug(f\"  :: Using dictionary\")\n            return BrokenDotmap(self.value)\n\n        elif isinstance(self.value, bytes):\n            log.debug(f\"  :: Using bytes\")\n            return BrokenDotmap(toml.loads(self.value.decode(\"utf-8\")))\n\n        elif BrokenPath.empty_file(self.value):\n            log.debug(f\"  :: Using empty file\")\n            return BrokenDotmap()\n\n        elif BrokenPath.non_empty_file(self.value):\n            log.debug(f\"  :: Using non-empty file\")\n            return BrokenDotmap(toml.load(self.value))\n\n        else:\n            raise RuntimeError(f\"Cannot load TOML from value {self.value}\")\n\n    def dump(self, path: Path):\n        log.trace(f\":: LoaderTOML.dump() to ({path})\")\n        path.write_text(toml.dumps(self.value))\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/#Core.Staging.Dotmap.Loaders.LoaderPIL.Core/Staging/Dotmap/Loaders/LoaderTOML/*.acronyms","title":"<code>acronyms() -&gt; Set[str]</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderTOML.py</code> Python<pre><code>@staticmethod\ndef acronyms() -&gt; Set[str]:\n    return {\"toml\"}\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/#Core.Staging.Dotmap.Loaders.LoaderPIL.Core/Staging/Dotmap/Loaders/LoaderTOML/*.load","title":"<code>load() -&gt; T</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderTOML.py</code> Python<pre><code>def load(self) -&gt; T:\n    log.debug(f\":: LoaderTOML.load() for value ({self.value})\")\n\n    if not self.value:\n        return None\n\n    elif isinstance(self.value, str):\n        log.debug(f\"  :: Using string\")\n        return BrokenDotmap(toml.loads(self.value))\n\n    elif isinstance(self.value, dict):\n        log.debug(f\"  :: Using dictionary\")\n        return BrokenDotmap(self.value)\n\n    elif isinstance(self.value, bytes):\n        log.debug(f\"  :: Using bytes\")\n        return BrokenDotmap(toml.loads(self.value.decode(\"utf-8\")))\n\n    elif BrokenPath.empty_file(self.value):\n        log.debug(f\"  :: Using empty file\")\n        return BrokenDotmap()\n\n    elif BrokenPath.non_empty_file(self.value):\n        log.debug(f\"  :: Using non-empty file\")\n        return BrokenDotmap(toml.load(self.value))\n\n    else:\n        raise RuntimeError(f\"Cannot load TOML from value {self.value}\")\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/#Core.Staging.Dotmap.Loaders.LoaderPIL.Core/Staging/Dotmap/Loaders/LoaderTOML/*.dump","title":"<code>dump(path: Path)</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderTOML.py</code> Python<pre><code>def dump(self, path: Path):\n    log.trace(f\":: LoaderTOML.dump() to ({path})\")\n    path.write_text(toml.dumps(self.value))\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/#Core.Staging.Dotmap.Loaders.LoaderPIL.DotmapLoaderImage","title":"<code>Core.Staging.Dotmap.Loaders.LoaderPIL.DotmapLoaderImage</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderPIL.py</code> Python<pre><code>class DotmapLoaderImage(DotmapLoader):\n\n    @staticmethod\n    def acronyms() -&gt; Set[str]:\n        return {\"image\", \"png\", \"jpg\", \"jpeg\", \"bmp\"}\n\n    def load(self) -&gt; T:\n        log.debug(f\"\u2022 LoaderImage.load() for value ({self.value})\")\n\n        if not self.value:\n            return None\n\n        elif isinstance(self.value, Image):\n            log.debug(f\"  :: Using PIL.Image\")\n            return self.value\n\n        elif isinstance(self.value, str) and Path(self.value).exists():\n            log.debug(f\"  :: Using path\")\n            return PIL.Image.open(self.value)\n\n        elif isinstance(self.value, Path):\n            log.debug(f\"  :: Using path\")\n            return PIL.Image.open(self.value)\n\n        elif BrokenUtils.have_import(\"requests\") and validators.url(self.value):\n            log.debug(f\"  :: Using requests\")\n            return PIL.Image.open(io.BytesIO(requests.get(self.value).content))\n\n        elif BrokenUtils.have_import(\"numpy\") and isinstance(self.value, numpy.ndarray):\n            log.debug(f\"  :: Using numpy\")\n            return PIL.Image.fromarray(self.value)\n\n        elif isinstance(self.value, bytes):\n            log.debug(f\"  :: Using bytes\")\n            return PIL.Image.open(io.BytesIO(self.value))\n\n        return None\n\n    def dump(self, path: Path) -&gt; None:\n        log.debug(f\":: LoaderImage.dump() @ ({path}) - {self.value}\")\n        self.value.save(path)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/#Core.Staging.Dotmap.Loaders.LoaderPIL.DotmapLoaderImage.acronyms","title":"<code>acronyms() -&gt; Set[str]</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderPIL.py</code> Python<pre><code>@staticmethod\ndef acronyms() -&gt; Set[str]:\n    return {\"image\", \"png\", \"jpg\", \"jpeg\", \"bmp\"}\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/#Core.Staging.Dotmap.Loaders.LoaderPIL.DotmapLoaderImage.load","title":"<code>load() -&gt; T</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderPIL.py</code> Python<pre><code>def load(self) -&gt; T:\n    log.debug(f\"\u2022 LoaderImage.load() for value ({self.value})\")\n\n    if not self.value:\n        return None\n\n    elif isinstance(self.value, Image):\n        log.debug(f\"  :: Using PIL.Image\")\n        return self.value\n\n    elif isinstance(self.value, str) and Path(self.value).exists():\n        log.debug(f\"  :: Using path\")\n        return PIL.Image.open(self.value)\n\n    elif isinstance(self.value, Path):\n        log.debug(f\"  :: Using path\")\n        return PIL.Image.open(self.value)\n\n    elif BrokenUtils.have_import(\"requests\") and validators.url(self.value):\n        log.debug(f\"  :: Using requests\")\n        return PIL.Image.open(io.BytesIO(requests.get(self.value).content))\n\n    elif BrokenUtils.have_import(\"numpy\") and isinstance(self.value, numpy.ndarray):\n        log.debug(f\"  :: Using numpy\")\n        return PIL.Image.fromarray(self.value)\n\n    elif isinstance(self.value, bytes):\n        log.debug(f\"  :: Using bytes\")\n        return PIL.Image.open(io.BytesIO(self.value))\n\n    return None\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loaderpil/#Core.Staging.Dotmap.Loaders.LoaderPIL.DotmapLoaderImage.dump","title":"<code>dump(path: Path) -&gt; None</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderPIL.py</code> Python<pre><code>def dump(self, path: Path) -&gt; None:\n    log.debug(f\":: LoaderImage.dump() @ ({path}) - {self.value}\")\n    self.value.save(path)\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loadertoml/","title":"LoaderTOML","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/core/staging/dotmap/loaders/loadertoml/#Core.Staging.Dotmap.Loaders.LoaderTOML","title":"<code>Core.Staging.Dotmap.Loaders.LoaderTOML</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderTOML.py</code> Python<pre><code>class LoaderTOML(DotmapLoader):\n\n    @staticmethod\n    def acronyms() -&gt; Set[str]:\n        return {\"toml\"}\n\n    def load(self) -&gt; T:\n        log.debug(f\":: LoaderTOML.load() for value ({self.value})\")\n\n        if not self.value:\n            return None\n\n        elif isinstance(self.value, str):\n            log.debug(f\"  :: Using string\")\n            return BrokenDotmap(toml.loads(self.value))\n\n        elif isinstance(self.value, dict):\n            log.debug(f\"  :: Using dictionary\")\n            return BrokenDotmap(self.value)\n\n        elif isinstance(self.value, bytes):\n            log.debug(f\"  :: Using bytes\")\n            return BrokenDotmap(toml.loads(self.value.decode(\"utf-8\")))\n\n        elif BrokenPath.empty_file(self.value):\n            log.debug(f\"  :: Using empty file\")\n            return BrokenDotmap()\n\n        elif BrokenPath.non_empty_file(self.value):\n            log.debug(f\"  :: Using non-empty file\")\n            return BrokenDotmap(toml.load(self.value))\n\n        else:\n            raise RuntimeError(f\"Cannot load TOML from value {self.value}\")\n\n    def dump(self, path: Path):\n        log.trace(f\":: LoaderTOML.dump() to ({path})\")\n        path.write_text(toml.dumps(self.value))\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loadertoml/#Core.Staging.Dotmap.Loaders.LoaderTOML.acronyms","title":"<code>Core.Staging.Dotmap.Loaders.LoaderTOML.acronyms() -&gt; Set[str]</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderTOML.py</code> Python<pre><code>@staticmethod\ndef acronyms() -&gt; Set[str]:\n    return {\"toml\"}\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loadertoml/#Core.Staging.Dotmap.Loaders.LoaderTOML.load","title":"<code>Core.Staging.Dotmap.Loaders.LoaderTOML.load() -&gt; T</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderTOML.py</code> Python<pre><code>def load(self) -&gt; T:\n    log.debug(f\":: LoaderTOML.load() for value ({self.value})\")\n\n    if not self.value:\n        return None\n\n    elif isinstance(self.value, str):\n        log.debug(f\"  :: Using string\")\n        return BrokenDotmap(toml.loads(self.value))\n\n    elif isinstance(self.value, dict):\n        log.debug(f\"  :: Using dictionary\")\n        return BrokenDotmap(self.value)\n\n    elif isinstance(self.value, bytes):\n        log.debug(f\"  :: Using bytes\")\n        return BrokenDotmap(toml.loads(self.value.decode(\"utf-8\")))\n\n    elif BrokenPath.empty_file(self.value):\n        log.debug(f\"  :: Using empty file\")\n        return BrokenDotmap()\n\n    elif BrokenPath.non_empty_file(self.value):\n        log.debug(f\"  :: Using non-empty file\")\n        return BrokenDotmap(toml.load(self.value))\n\n    else:\n        raise RuntimeError(f\"Cannot load TOML from value {self.value}\")\n</code></pre>"},{"location":"broken/reference/core/staging/dotmap/loaders/loadertoml/#Core.Staging.Dotmap.Loaders.LoaderTOML.dump","title":"<code>Core.Staging.Dotmap.Loaders.LoaderTOML.dump(path: Path)</code>","text":"Source code in <code>Broken/Core/Staging/Dotmap/Loaders/LoaderTOML.py</code> Python<pre><code>def dump(self, path: Path):\n    log.trace(f\":: LoaderTOML.dump() to ({path})\")\n    path.write_text(toml.dumps(self.value))\n</code></pre>"},{"location":"broken/reference/externals/depthmap/","title":"Depthmap","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap","title":"<code>Externals.Depthmap</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthEstimator","title":"<code>Externals.Depthmap.DepthEstimator</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>class DepthEstimator(BaseModel, ABC):\n    model_config = ConfigDict(\n        arbitrary_types_allowed=True,\n        validate_assignment=True\n    )\n\n    model: str = Field(default=\"any\")\n\n    _lock: Optional[Lock] = PrivateAttr(default_factory=Lock)\n    \"\"\"Calling PyTorch in a multi-threaded environment isn't safe, so lock before any inference\"\"\"\n\n    _cache: Path = PrivateAttr(default=Broken.PROJECT.DIRECTORIES.CACHE/\"DepthEstimator\")\n    \"\"\"Path where the depth map will be cached. Broken.PROJECT is the current working project\"\"\"\n\n    @property\n    def device(self) -&gt; str:\n        if torch.cuda.is_available():\n            return \"cuda\"\n        return \"cpu\"\n\n    def normalize(self, array: numpy.ndarray) -&gt; numpy.ndarray:\n        return (array - array.min()) / ((array.max() - array.min()) or 1)\n\n    def load_torch(self) -&gt; None:\n        global torch\n        BrokenTorch.install()\n        with BrokenSpinner(text=\"Importing PyTorch...\"):\n            import torch\n\n    _loaded: SameTracker = PrivateAttr(default_factory=SameTracker)\n    \"\"\"Keeps track of the current loaded model name, to avoid reloading\"\"\"\n\n    def load_model(self) -&gt; None:\n        if self._loaded(self.model):\n            return\n        self._load_model()\n\n    @functools.wraps(load_model)\n    @abstractmethod\n    def _load_model(self) -&gt; None:\n        ...\n\n    def estimate(self,\n        image: LoadableImage,\n        cache: bool=True\n    ) -&gt; numpy.ndarray:\n\n        # Load image and find expected cache path\n        image = numpy.array(LoaderImage(image).convert(\"RGB\"))\n        cached_image = self._cache/f\"{image_hash(image)}-{self.__class__.__name__}-{self.model}.png\"\n        cached_image.parent.mkdir(parents=True, exist_ok=True)\n\n        # Load cached estimation if found\n        if (cache and cached_image.exists()):\n            depth = numpy.array(Image.open(cached_image))\n        else:\n            self.load_torch()\n            self.load_model()\n            with self._lock, BrokenSpinner(f\"Estimating Depthmap (Torch: {self.device})\"):\n                torch.set_num_threads(max(4, multiprocessing.cpu_count()//2))\n                depth = self._estimate(image)\n            depth = (self.normalize(depth) * 2**16).astype(numpy.uint16)\n            Image.fromarray(depth).save(cached_image)\n        return self.normalize(self._post_processing(depth))\n\n    def normal_map(self, depth: numpy.ndarray) -&gt; numpy.ndarray:\n        \"\"\"Estimates a normal map from a depth map using heuristics\"\"\"\n        dx = numpy.arctan2(200*numpy.gradient(depth, axis=1), 1)\n        dy = numpy.arctan2(200*numpy.gradient(depth, axis=0), 1)\n        normal = numpy.dstack((-dx, dy, numpy.ones_like(depth)))\n        return self.normalize(normal).astype(numpy.float32)\n\n    @functools.wraps(estimate)\n    @abstractmethod\n    def _estimate(self):\n        \"\"\"The implementation shall return a normalized numpy f32 array of the depth map\"\"\"\n        ...\n\n    @abstractmethod\n    def _post_processing(self, depth: numpy.ndarray) -&gt; numpy.ndarray:\n        \"\"\"A step to apply post processing on the depth map if needed\"\"\"\n        return depth\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthEstimator.model_config","title":"<code>model_config = ConfigDict(arbitrary_types_allowed=True, validate_assignment=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthEstimator.model","title":"<code>model: str = Field(default='any')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthEstimator.device","title":"<code>device: str</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthEstimator.normalize","title":"<code>normalize(array: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>def normalize(self, array: numpy.ndarray) -&gt; numpy.ndarray:\n    return (array - array.min()) / ((array.max() - array.min()) or 1)\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthEstimator.load_torch","title":"<code>load_torch() -&gt; None</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>def load_torch(self) -&gt; None:\n    global torch\n    BrokenTorch.install()\n    with BrokenSpinner(text=\"Importing PyTorch...\"):\n        import torch\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthEstimator.load_model","title":"<code>load_model() -&gt; None</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>def load_model(self) -&gt; None:\n    if self._loaded(self.model):\n        return\n    self._load_model()\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthEstimator.estimate","title":"<code>estimate(image: LoadableImage, cache: bool = True) -&gt; numpy.ndarray</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>def estimate(self,\n    image: LoadableImage,\n    cache: bool=True\n) -&gt; numpy.ndarray:\n\n    # Load image and find expected cache path\n    image = numpy.array(LoaderImage(image).convert(\"RGB\"))\n    cached_image = self._cache/f\"{image_hash(image)}-{self.__class__.__name__}-{self.model}.png\"\n    cached_image.parent.mkdir(parents=True, exist_ok=True)\n\n    # Load cached estimation if found\n    if (cache and cached_image.exists()):\n        depth = numpy.array(Image.open(cached_image))\n    else:\n        self.load_torch()\n        self.load_model()\n        with self._lock, BrokenSpinner(f\"Estimating Depthmap (Torch: {self.device})\"):\n            torch.set_num_threads(max(4, multiprocessing.cpu_count()//2))\n            depth = self._estimate(image)\n        depth = (self.normalize(depth) * 2**16).astype(numpy.uint16)\n        Image.fromarray(depth).save(cached_image)\n    return self.normalize(self._post_processing(depth))\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthEstimator.normal_map","title":"<code>normal_map(depth: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"<p>Estimates a normal map from a depth map using heuristics</p> Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>def normal_map(self, depth: numpy.ndarray) -&gt; numpy.ndarray:\n    \"\"\"Estimates a normal map from a depth map using heuristics\"\"\"\n    dx = numpy.arctan2(200*numpy.gradient(depth, axis=1), 1)\n    dy = numpy.arctan2(200*numpy.gradient(depth, axis=0), 1)\n    normal = numpy.dstack((-dx, dy, numpy.ones_like(depth)))\n    return self.normalize(normal).astype(numpy.float32)\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingBase","title":"<code>Externals.Depthmap.DepthAnythingBase</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>class DepthAnythingBase(DepthEstimator):\n\n    @abstractmethod\n    def prefix(self) -&gt; str:\n        ...\n\n    class Models(str, BrokenEnum):\n        Small = \"small\"\n        Base  = \"base\"\n        Large = \"large\"\n\n    model: Annotated[Models, typer.Option(\"--model\", \"-m\",\n        help=\"[bold][red](\ud83d\udd34 Basic)[/red][/bold] What model of DepthAnythingV2 to use\")] = \\\n        Field(default=\"base\")\n\n    _processor: Any = PrivateAttr(default=None)\n    _model: Any = PrivateAttr(default=None)\n\n    def _load_model(self) -&gt; None:\n        import transformers\n        HUGGINGFACE_MODEL = (f\"{self.prefix()}{self.model}-hf\")\n        self._processor = transformers.AutoImageProcessor.from_pretrained(HUGGINGFACE_MODEL)\n        self._model = transformers.AutoModelForDepthEstimation.from_pretrained(HUGGINGFACE_MODEL)\n        self._model.to(self.device)\n\n    def _estimate(self, image: numpy.ndarray) -&gt; numpy.ndarray:\n        inputs = self._processor(images=image, return_tensors=\"pt\")\n        inputs = {key: value.to(self.device) for key, value in inputs.items()}\n        with torch.no_grad():\n            depth = self._model(**inputs).predicted_depth\n        return depth.squeeze(1).cpu().numpy()[0]\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingBase.prefix","title":"<code>prefix() -&gt; str</code>  <code>abstractmethod</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>@abstractmethod\ndef prefix(self) -&gt; str:\n    ...\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingBase.Models","title":"<code>Models</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>class Models(str, BrokenEnum):\n    Small = \"small\"\n    Base  = \"base\"\n    Large = \"large\"\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingBase.Models.Small","title":"<code>Small = 'small'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingBase.Models.Base","title":"<code>Base = 'base'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingBase.Models.Large","title":"<code>Large = 'large'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingBase.model","title":"<code>model: Annotated[Models, typer.Option(--model, -m, help='[bold][red](\ud83d\udd34 Basic)[/red][/bold] What model of DepthAnythingV2 to use')] = Field(default='base')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingV1","title":"<code>Externals.Depthmap.DepthAnythingV1</code>","text":"<p>Configure and use DepthAnythingV1 green/green(by https://github.com/LiheYoung/Depth-Anything)[/dim]</p> Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>class DepthAnythingV1(DepthAnythingBase):\n    \"\"\"Configure and use DepthAnythingV1 [green](See 'dav1     --help' for options)[/green] [dim](by https://github.com/LiheYoung/Depth-Anything)[/dim]\"\"\"\n    def prefix(self) -&gt; str:\n        return  \"LiheYoung/depth-anything-\"\n\n    def _post_processing(self, depth: numpy.ndarray) -&gt; numpy.ndarray:\n        from scipy.ndimage import gaussian_filter, maximum_filter\n        depth = maximum_filter(input=depth, size=5)\n        depth = gaussian_filter(input=depth, sigma=0.3)\n        return depth\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingV1.prefix","title":"<code>prefix() -&gt; str</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>def prefix(self) -&gt; str:\n    return  \"LiheYoung/depth-anything-\"\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingV2","title":"<code>Externals.Depthmap.DepthAnythingV2</code>","text":"<p>Configure and use DepthAnythingV2 green/green(by https://github.com/DepthAnything/Depth-Anything-V2)[/dim]</p> Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>class DepthAnythingV2(DepthAnythingBase):\n    \"\"\"Configure and use DepthAnythingV2 [green](See 'dav2     --help' for options)[/green] [dim](by https://github.com/DepthAnything/Depth-Anything-V2)[/dim]\"\"\"\n    def prefix(self) -&gt; str:\n        return \"depth-anything/Depth-Anything-V2-\"\n\n    def _post_processing(self, depth: numpy.ndarray) -&gt; numpy.ndarray:\n        from scipy.ndimage import gaussian_filter, maximum_filter\n        depth = maximum_filter(input=depth, size=6)\n        depth = gaussian_filter(input=depth, sigma=0.9)\n        return depth\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.DepthAnythingV2.prefix","title":"<code>prefix() -&gt; str</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>def prefix(self) -&gt; str:\n    return \"depth-anything/Depth-Anything-V2-\"\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.ZoeDepth","title":"<code>Externals.Depthmap.ZoeDepth</code>","text":"<p>Configure and use ZoeDepth        green/green(by https://github.com/isl-org/ZoeDepth)[/dim]</p> Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>class ZoeDepth(DepthEstimator):\n    \"\"\"Configure and use ZoeDepth        [green](See 'zoedepth --help' for options)[/green] [dim](by https://github.com/isl-org/ZoeDepth)[/dim]\"\"\"\n    class Models(str, BrokenEnum):\n        N  = \"n\"\n        K  = \"k\"\n        NK = \"nk\"\n\n    model: Annotated[Models, typer.Option(\"--model\", \"-m\",\n        help=\"[bold][red](\ud83d\udd34 Basic)[/red][/bold] What model of ZoeDepth to use\")] = \\\n        Field(default=\"n\")\n\n    _model: Any = PrivateAttr(default=None)\n\n    def _load_model(self) -&gt; None:\n        try:\n            import timm\n        except ImportError:\n            shell(sys.executable, \"-m\", \"uv\", \"pip\", \"install\", \"timm==0.6.7\", \"--no-deps\")\n\n        self._model = torch.hub.load(\n            \"isl-org/ZoeDepth\", f\"ZoeD_{self.model.upper()}\",\n            pretrained=True, trust_repo=True\n        ).to(self.device)\n\n    # Downscale for the largest component to be 512 pixels (Zoe precision), invert for 0=infinity\n    def _estimate(self, image: numpy.ndarray) -&gt; numpy.ndarray:\n        depth = Image.fromarray(1 - self.normalize(self._model.infer_pil(image)))\n        new = BrokenResolution.fit(old=depth.size, max=(512, 512), ar=depth.size[0]/depth.size[1])\n        return numpy.array(depth.resize(new, resample=Image.LANCZOS)).astype(numpy.float32)\n\n    def _post_processing(self, depth: numpy.ndarray) -&gt; numpy.ndarray:\n        return depth\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.ZoeDepth.Models","title":"<code>Models</code>","text":"Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>class Models(str, BrokenEnum):\n    N  = \"n\"\n    K  = \"k\"\n    NK = \"nk\"\n</code></pre>"},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.ZoeDepth.Models.N","title":"<code>N = 'n'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.ZoeDepth.Models.K","title":"<code>K = 'k'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.ZoeDepth.Models.NK","title":"<code>NK = 'nk'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.ZoeDepth.model","title":"<code>model: Annotated[Models, typer.Option(--model, -m, help='[bold][red](\ud83d\udd34 Basic)[/red][/bold] What model of ZoeDepth to use')] = Field(default='n')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/depthmap/#Externals.Depthmap.Marigold","title":"<code>Externals.Depthmap.Marigold</code>","text":"<p>Configure and use Marigold        green/green(by https://github.com/prs-eth/Marigold)[/dim]</p> Source code in <code>Broken/Externals/Depthmap.py</code> Python<pre><code>class Marigold(DepthEstimator):\n    \"\"\"Configure and use Marigold        [green](See 'marigold --help' for options)[/green] [dim](by https://github.com/prs-eth/Marigold)[/dim]\"\"\"\n\n    _model: Any = PrivateAttr(default=None)\n\n    def _load_model(self) -&gt; None:\n        try:\n            import accelerate\n            import diffusers\n            import matplotlib\n        except ImportError:\n            shell(sys.executable, \"-m\", \"uv\", \"pip\", \"install\",\n                \"diffusers\", \"accelerate\", \"matplotlib\")\n\n        from diffusers import DiffusionPipeline\n\n        self._model = DiffusionPipeline.from_pretrained(\n            \"prs-eth/marigold-v1-0\",\n            custom_pipeline=\"marigold_depth_estimation\",\n            torch_dtype=torch.float16,\n            variant=\"fp16\",\n        ).to(self.device)\n\n    def _estimate(self, image: numpy.ndarray) -&gt; numpy.ndarray:\n        return (1 - self._model(\n            Image.fromarray(image),\n            denoising_steps=10,\n            ensemble_size=10,\n            match_input_res=False,\n            show_progress_bar=True,\n            color_map=None,\n            processing_res=792,\n        ).depth_np)\n\n    def _post_processing(self, depth: numpy.ndarray) -&gt; numpy.ndarray:\n        return depth\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/","title":"FFmpeg","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg","title":"<code>Externals.FFmpeg</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegModuleBase","title":"<code>Externals.FFmpeg.FFmpegModuleBase</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegModuleBase(BaseModel, ABC):\n    model_config = ConfigDict(validate_assignment=True)\n\n    @abstractmethod\n    def command(self) -&gt; Iterable[str]:\n        ...\n\n    def all(self, *args) -&gt; List[Optional[str]]:\n        if (None in args) or ('' in args):\n            return []\n        return args\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegModuleBase.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegModuleBase.command","title":"<code>command() -&gt; Iterable[str]</code>  <code>abstractmethod</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@abstractmethod\ndef command(self) -&gt; Iterable[str]:\n    ...\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegModuleBase.all","title":"<code>all(*args) -&gt; List[Optional[str]]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def all(self, *args) -&gt; List[Optional[str]]:\n    if (None in args) or ('' in args):\n        return []\n    return args\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPath","title":"<code>Externals.FFmpeg.FFmpegInputPath</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegInputPath(FFmpegModuleBase):\n    type: Literal[\"path\"] = \"path\"\n    path: Path\n\n    def command(self) -&gt; Iterable[str]:\n        return (\"-i\", self.path)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPath.type","title":"<code>type: Literal['path'] = 'path'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPath.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPath.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    return (\"-i\", self.path)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPipe","title":"<code>Externals.FFmpeg.FFmpegInputPipe</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegInputPipe(FFmpegModuleBase):\n    type: Literal[\"pipe\"] = \"pipe\"\n\n    format: Optional[Literal[\n        \"rawvideo\",\n        \"image2pipe\",\n        \"null\",\n    ]] = Field(default=\"rawvideo\")\n\n    pixel_format: Literal[\n        \"rgb24\",\n        \"rgba\",\n    ] = Field(default=\"rgb24\")\n\n    width: int = Field(default=1920, gt=0)\n    height: int = Field(default=1080, gt=0)\n\n    framerate: float = Field(default=60.0, gt=-1.0)\n\n    @field_validator(\"framerate\", mode=\"plain\")\n    def validate_framerate(cls, value: Union[float, str]) -&gt; float:\n        return eval(str(value))\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-f\", self.format)\n        yield (\"-s\", f\"{self.width}x{self.height}\")\n        yield (\"-pix_fmt\", self.pixel_format)\n        yield (\"-r\", self.framerate)\n        yield (\"-i\", \"-\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPipe.type","title":"<code>type: Literal['pipe'] = 'pipe'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPipe.format","title":"<code>format: Optional[Literal['rawvideo', 'image2pipe', 'null']] = Field(default='rawvideo')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPipe.pixel_format","title":"<code>pixel_format: Literal['rgb24', 'rgba'] = Field(default='rgb24')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPipe.width","title":"<code>width: int = Field(default=1920, gt=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPipe.height","title":"<code>height: int = Field(default=1080, gt=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPipe.framerate","title":"<code>framerate: float = Field(default=60.0, gt=-1.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPipe.validate_framerate","title":"<code>validate_framerate(value: Union[float, str]) -&gt; float</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@field_validator(\"framerate\", mode=\"plain\")\ndef validate_framerate(cls, value: Union[float, str]) -&gt; float:\n    return eval(str(value))\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputPipe.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-f\", self.format)\n    yield (\"-s\", f\"{self.width}x{self.height}\")\n    yield (\"-pix_fmt\", self.pixel_format)\n    yield (\"-r\", self.framerate)\n    yield (\"-i\", \"-\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegInputType","title":"<code>Externals.FFmpeg.FFmpegInputType: TypeAlias = Union[FFmpegInputPipe, FFmpegInputPath]</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPipe","title":"<code>Externals.FFmpeg.FFmpegOutputPipe</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegOutputPipe(FFmpegModuleBase):\n    type: Literal[\"pipe\"] = \"pipe\"\n    format: Optional[Literal[\n        \"rawvideo\",\n        \"image2pipe\",\n        \"null\",\n    ]] = Field(default=None)\n\n    pixel_format: Literal[\n        \"rgb24\",\n        \"rgba\",\n    ] = Field(default=\"rgb24\")\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-f\", self.format)\n        yield self.all(\"-pix_fmt\", self.pixel_format)\n        yield \"-\"\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPipe.type","title":"<code>type: Literal['pipe'] = 'pipe'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPipe.format","title":"<code>format: Optional[Literal['rawvideo', 'image2pipe', 'null']] = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPipe.pixel_format","title":"<code>pixel_format: Literal['rgb24', 'rgba'] = Field(default='rgb24')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPipe.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-f\", self.format)\n    yield self.all(\"-pix_fmt\", self.pixel_format)\n    yield \"-\"\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPath","title":"<code>Externals.FFmpeg.FFmpegOutputPath</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegOutputPath(FFmpegModuleBase):\n    type: Literal[\"path\"] = \"path\"\n    overwrite: bool = True\n    path: Path\n\n    pixel_format: Optional[Literal[\n        \"yuv420p\",\n        \"yuv444p\",\n    ]] = Field(default=\"yuv420p\")\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-pix_fmt\", self.pixel_format)\n        yield (self.path, self.overwrite*\"-y\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPath.type","title":"<code>type: Literal['path'] = 'path'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPath.overwrite","title":"<code>overwrite: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPath.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPath.pixel_format","title":"<code>pixel_format: Optional[Literal['yuv420p', 'yuv444p']] = Field(default='yuv420p')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputPath.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-pix_fmt\", self.pixel_format)\n    yield (self.path, self.overwrite*\"-y\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegOutputType","title":"<code>Externals.FFmpeg.FFmpegOutputType = Union[FFmpegOutputPipe, FFmpegOutputPath]</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264","title":"<code>Externals.FFmpeg.FFmpegVideoCodecH264</code>","text":"<p>https://trac.ffmpeg.org/wiki/Encode/H.264</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecH264(FFmpegModuleBase):\n    \"\"\"https://trac.ffmpeg.org/wiki/Encode/H.264\"\"\"\n    codec: Literal[\"h264\"] = \"h264\"\n\n    crf: int = Field(default=20, ge=0, le=51)\n    \"\"\"Constant Rate Factor. 0 is lossless, 51 is the worst quality\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/H.264#a1.ChooseaCRFvalue\n    \"\"\"\n\n    bitrate: Optional[int] = Field(default=None, gt=-1)\n\n    preset: Optional[Literal[\n        \"ultrafast\",\n        \"superfast\",\n        \"veryfast\",\n        \"faster\",\n        \"fast\",\n        \"medium\",\n        \"slow\",\n        \"slower\",\n        \"veryslow\",\n    ]] = Field(default=\"slow\")\n    \"\"\"How much time to spend on encoding. Slower options gives better compression\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/H.264#Preset\n    \"\"\"\n\n    tune: Optional[Literal[\n        \"film\",\n        \"animation\",\n        \"grain\",\n        \"stillimage\",\n        \"fastdecode\",\n        \"zerolatency\"\n    ]] = Field(default=None)\n    \"\"\"Tune x264 to keep and optimize for certain aspects of the input media. See link for more:\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/H.264#Tune\n    \"\"\"\n\n    profile: Optional[Literal[\n        \"baseline\",\n        \"main\",\n        \"high\",\n        \"high10\",\n        \"high422\",\n        \"high444\",\n    ]] = Field(default=None)\n    \"\"\"What features the encoder can use. The playback device must support the same profile level\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/H.264#Profile\n    \"\"\"\n\n    faststart: bool = Field(default=True)\n\n    rgb: bool = Field(default=False)\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:v\", \"libx264rgb\" if self.rgb else \"libx264\")\n        yield self.all(\"-profile\", self.profile)\n        yield self.all(\"-preset\", self.preset)\n        yield self.all(\"-tune\", self.tune)\n        yield self.all(\"-crf\", str(self.crf))\n        yield self.all(\"-movflags\", \"+faststart\"*self.faststart)\n        yield self.all(\"-b:v\", self.bitrate)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264.codec","title":"<code>codec: Literal['h264'] = 'h264'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264.crf","title":"<code>crf: int = Field(default=20, ge=0, le=51)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant Rate Factor. 0 is lossless, 51 is the worst quality \u2022 https://trac.ffmpeg.org/wiki/Encode/H.264#a1.ChooseaCRFvalue</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264.bitrate","title":"<code>bitrate: Optional[int] = Field(default=None, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264.preset","title":"<code>preset: Optional[Literal['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow']] = Field(default='slow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How much time to spend on encoding. Slower options gives better compression \u2022 https://trac.ffmpeg.org/wiki/Encode/H.264#Preset</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264.tune","title":"<code>tune: Optional[Literal['film', 'animation', 'grain', 'stillimage', 'fastdecode', 'zerolatency']] = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Tune x264 to keep and optimize for certain aspects of the input media. See link for more: \u2022 https://trac.ffmpeg.org/wiki/Encode/H.264#Tune</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264.profile","title":"<code>profile: Optional[Literal['baseline', 'main', 'high', 'high10', 'high422', 'high444']] = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>What features the encoder can use. The playback device must support the same profile level \u2022 https://trac.ffmpeg.org/wiki/Encode/H.264#Profile</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264.faststart","title":"<code>faststart: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264.rgb","title":"<code>rgb: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:v\", \"libx264rgb\" if self.rgb else \"libx264\")\n    yield self.all(\"-profile\", self.profile)\n    yield self.all(\"-preset\", self.preset)\n    yield self.all(\"-tune\", self.tune)\n    yield self.all(\"-crf\", str(self.crf))\n    yield self.all(\"-movflags\", \"+faststart\"*self.faststart)\n    yield self.all(\"-b:v\", self.bitrate)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC","title":"<code>Externals.FFmpeg.FFmpegVideoCodecH264_NVENC</code>","text":"<p><code>ffmpeg -h encoder=h264_nvenc</code></p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecH264_NVENC(FFmpegModuleBase):\n    \"\"\"`ffmpeg -h encoder=h264_nvenc`\"\"\"\n    codec: Literal[\"h264_nvenc\"] = \"h264_nvenc\"\n\n    preset: Optional[Literal[\n        \"default\", # Defaults to p4\n        \"slow\", # High quality 2 passes\n        \"medium\", # High quality 1 pass\n        \"fast\", # High quality 1 pass\n        \"hp\", # High performance\n        \"hq\", # High quality\n        \"bd\", # Balanced\n        \"ll\", # Low latency\n        \"llhq\", # Low latency high quality\n        \"llhp\", # Low latency high performance\n        \"lossless\", # Lossless\n        \"losslesshp\", # Lossless high performance\n        \"p1\", # fastest\n        \"p2\", # faster\n        \"p3\", # fast\n        \"p4\", # medium\n        \"p5\", # slow\n        \"p6\", # slower\n        \"p7\", # slowest\n    ]] = Field(default=\"p4\")\n\n    tune: Optional[Literal[\n        \"hq\", # High quality\n        \"ll\", # Low latency\n        \"ull\", # Ultra low latency\n        \"lossless\" # Lossless\n    ]] = Field(default=\"hq\")\n\n    profile: Optional[Literal[\n        \"baseline\", # Very old devices\n        \"main\", # Relatively modern devices\n        \"high\", # Modern devices\n        \"high444p\" # Modern devices\n    ]] = Field(default=\"high\")\n\n    rc: Optional[Literal[\n        \"constqp\", # Constant Quality 'Factor'\n        \"vbr\", # Variable bitrate\n        \"cbr\", # Constant bitrate\n    ]] = Field(default=\"vbr\")\n    \"\"\"'Rate Control' mode\"\"\"\n\n    rc_lookahead: Optional[int] = Field(default=32, gt=-1)\n    \"\"\"Number of frames to look ahead for the rate control\"\"\"\n\n    cbr: bool = Field(default=False)\n    \"\"\"Use Constant Bitrate mode\"\"\"\n\n    gpu: int = Field(default=0, gt=-1)\n    \"\"\"Use the Nth NVENC capable GPU for encoding\"\"\"\n\n    cq: int = Field(default=25, gt=-1)\n    \"\"\"Set the Constant Quality factor in a Variable Bitrate mode (similar to -crf)\"\"\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:v\", \"h264_nvenc\")\n        yield self.all(\"-b:v\", 0)\n        yield self.all(\"-preset\", self.preset)\n        yield self.all(\"-tune\", self.tune)\n        yield self.all(\"-profile\", self.profile)\n        yield self.all(\"-rc\", self.rc)\n        yield self.all(\"-rc-lookahead\", self.rc_lookahead)\n        yield self.all(\"-cbr\", int(self.cbr))\n        yield self.all(\"-cq\", self.cq)\n        yield self.all(\"-gpu\", self.gpu)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.codec","title":"<code>codec: Literal['h264_nvenc'] = 'h264_nvenc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.preset","title":"<code>preset: Optional[Literal['default', 'slow', 'medium', 'fast', 'hp', 'hq', 'bd', 'll', 'llhq', 'llhp', 'lossless', 'losslesshp', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7']] = Field(default='p4')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.tune","title":"<code>tune: Optional[Literal['hq', 'll', 'ull', 'lossless']] = Field(default='hq')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.profile","title":"<code>profile: Optional[Literal['baseline', 'main', 'high', 'high444p']] = Field(default='high')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.rc","title":"<code>rc: Optional[Literal['constqp', 'vbr', 'cbr']] = Field(default='vbr')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>'Rate Control' mode</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.rc_lookahead","title":"<code>rc_lookahead: Optional[int] = Field(default=32, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of frames to look ahead for the rate control</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.cbr","title":"<code>cbr: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Constant Bitrate mode</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.gpu","title":"<code>gpu: int = Field(default=0, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the Nth NVENC capable GPU for encoding</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.cq","title":"<code>cq: int = Field(default=25, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set the Constant Quality factor in a Variable Bitrate mode (similar to -crf)</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH264_NVENC.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:v\", \"h264_nvenc\")\n    yield self.all(\"-b:v\", 0)\n    yield self.all(\"-preset\", self.preset)\n    yield self.all(\"-tune\", self.tune)\n    yield self.all(\"-profile\", self.profile)\n    yield self.all(\"-rc\", self.rc)\n    yield self.all(\"-rc-lookahead\", self.rc_lookahead)\n    yield self.all(\"-cbr\", int(self.cbr))\n    yield self.all(\"-cq\", self.cq)\n    yield self.all(\"-gpu\", self.gpu)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265","title":"<code>Externals.FFmpeg.FFmpegVideoCodecH265</code>","text":"<p>https://trac.ffmpeg.org/wiki/Encode/H.265</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecH265(FFmpegModuleBase):\n    \"\"\"https://trac.ffmpeg.org/wiki/Encode/H.265\"\"\"\n    codec: Literal[\"h265\"] = \"h265\"\n\n    crf: int = Field(default=25, ge=0, le=51)\n    \"\"\"Constant Rate Factor. 0 is lossless, 51 is the worst quality\"\"\"\n\n    bitrate: Optional[int] = Field(default=None, gt=-1)\n\n    preset: Optional[Literal[\n        \"ultrafast\",\n        \"superfast\",\n        \"veryfast\",\n        \"faster\",\n        \"fast\",\n        \"medium\",\n        \"slow\",\n        \"slower\",\n        \"veryslow\",\n    ]] = Field(default=\"slow\")\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:v\", \"libx265\")\n        yield self.all(\"-preset\", self.preset)\n        yield self.all(\"-crf\", str(self.crf))\n        yield self.all(\"-b:v\", self.bitrate)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265.codec","title":"<code>codec: Literal['h265'] = 'h265'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265.crf","title":"<code>crf: int = Field(default=25, ge=0, le=51)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant Rate Factor. 0 is lossless, 51 is the worst quality</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265.bitrate","title":"<code>bitrate: Optional[int] = Field(default=None, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265.preset","title":"<code>preset: Optional[Literal['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow']] = Field(default='slow')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:v\", \"libx265\")\n    yield self.all(\"-preset\", self.preset)\n    yield self.all(\"-crf\", str(self.crf))\n    yield self.all(\"-b:v\", self.bitrate)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC","title":"<code>Externals.FFmpeg.FFmpegVideoCodecH265_NVENC</code>","text":"<p><code>ffmpeg -h encoder=hevc_nvenc</code></p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecH265_NVENC(FFmpegVideoCodecH265):\n    \"\"\"`ffmpeg -h encoder=hevc_nvenc`\"\"\"\n    codec: Literal[\"hevc_nvenc\"] = \"hevc_nvenc\"\n\n    preset: Optional[Literal[\n        \"default\", # Defaults to p4\n        \"slow\", # High quality 2 passes\n        \"medium\", # High quality 1 pass\n        \"fast\", # High quality 1 pass\n        \"hp\", # High performance\n        \"hq\", # High quality\n        \"bd\", # Balanced\n        \"ll\", # Low latency\n        \"llhq\", # Low latency high quality\n        \"llhp\", # Low latency high performance\n        \"lossless\", # Lossless\n        \"losslesshp\", # Lossless high performance\n        \"p1\", # fastest\n        \"p2\", # faster\n        \"p3\", # fast\n        \"p4\", # medium\n        \"p5\", # slow\n        \"p6\", # slower\n        \"p7\", # slowest\n    ]] = Field(default=\"p5\")\n\n    tune: Optional[Literal[\n        \"hq\", # High quality\n        \"ll\", # Low latency\n        \"ull\", # Ultra low latency\n        \"lossless\" # Lossless\n    ]] = Field(default=\"hq\")\n\n    profile: Optional[Literal[\n        \"main\", # Modern devices\n        \"main10\", # HDR 10 bits\n        \"rext\"\n    ]] = Field(default=None)\n\n    tier: Optional[Literal[\n        \"main\",\n        \"high\",\n    ]] = Field(default=\"high\")\n\n    rc: Optional[Literal[\n        \"constqp\", # Constant Quality 'Factor'\n        \"vbr\", # Variable bitrate\n        \"cbr\", # Constant bitrate\n    ]] = Field(default=\"vbr\")\n    \"\"\"'Rate Control' mode\"\"\"\n\n    rc_lookahead: Optional[int] = Field(default=10, gt=-1)\n    \"\"\"Number of frames to look ahead for the rate control\"\"\"\n\n    cbr: bool = Field(default=False)\n    \"\"\"Use Constant Bitrate mode\"\"\"\n\n    gpu: int = Field(default=0, gt=-1)\n    \"\"\"Use the Nth NVENC capable GPU for encoding\"\"\"\n\n    cq: int = Field(default=25, gt=-1)\n    \"\"\"Set the Constant Quality factor in a Variable Bitrate mode (similar to -crf)\"\"\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:v\", \"hevc_nvenc\")\n        yield self.all(\"-preset\", self.preset)\n        yield self.all(\"-tune\", self.tune)\n        yield self.all(\"-profile\", self.profile)\n        yield self.all(\"-tier\", self.tier)\n        yield self.all(\"-rc\", self.rc)\n        yield self.all(\"-rc-lookahead\", self.rc_lookahead)\n        yield self.all(\"-cbr\", int(self.cbr))\n        yield self.all(\"-cq\", self.cq)\n        yield self.all(\"-gpu\", self.gpu)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.codec","title":"<code>codec: Literal['hevc_nvenc'] = 'hevc_nvenc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.preset","title":"<code>preset: Optional[Literal['default', 'slow', 'medium', 'fast', 'hp', 'hq', 'bd', 'll', 'llhq', 'llhp', 'lossless', 'losslesshp', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7']] = Field(default='p5')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.tune","title":"<code>tune: Optional[Literal['hq', 'll', 'ull', 'lossless']] = Field(default='hq')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.profile","title":"<code>profile: Optional[Literal['main', 'main10', 'rext']] = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.tier","title":"<code>tier: Optional[Literal['main', 'high']] = Field(default='high')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.rc","title":"<code>rc: Optional[Literal['constqp', 'vbr', 'cbr']] = Field(default='vbr')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>'Rate Control' mode</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.rc_lookahead","title":"<code>rc_lookahead: Optional[int] = Field(default=10, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of frames to look ahead for the rate control</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.cbr","title":"<code>cbr: bool = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Constant Bitrate mode</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.gpu","title":"<code>gpu: int = Field(default=0, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the Nth NVENC capable GPU for encoding</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.cq","title":"<code>cq: int = Field(default=25, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set the Constant Quality factor in a Variable Bitrate mode (similar to -crf)</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecH265_NVENC.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:v\", \"hevc_nvenc\")\n    yield self.all(\"-preset\", self.preset)\n    yield self.all(\"-tune\", self.tune)\n    yield self.all(\"-profile\", self.profile)\n    yield self.all(\"-tier\", self.tier)\n    yield self.all(\"-rc\", self.rc)\n    yield self.all(\"-rc-lookahead\", self.rc_lookahead)\n    yield self.all(\"-cbr\", int(self.cbr))\n    yield self.all(\"-cq\", self.cq)\n    yield self.all(\"-gpu\", self.gpu)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecVP9","title":"<code>Externals.FFmpeg.FFmpegVideoCodecVP9</code>","text":"<p>https://trac.ffmpeg.org/wiki/Encode/VP9</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecVP9(FFmpegModuleBase):\n    \"\"\"https://trac.ffmpeg.org/wiki/Encode/VP9\"\"\"\n    codec: Literal[\"libvpx-vp9\"] = \"libvpx-vp9\"\n\n    crf: int = Field(default=30, gt=-1, lt=64)\n    \"\"\"Constant Rate Factor (0-63). Lower values mean better quality, recommended (15-31)\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/VP9#constantq\n    \"\"\"\n\n    speed: int = Field(default=4, gt=-1, lt=6)\n    \"\"\"Speed level (0-6). Higher values yields faster encoding but innacuracies in rate control\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/VP9#CPUUtilizationSpeed\n    \"\"\"\n\n    deadline: Optional[Literal[\n        \"good\", # General cases\n        \"best\", # Offline renders\n        \"realtime\",\n    ]] = Field(default=\"good\")\n    \"\"\"Tweak the encoding time philosophy. 'good' for general cases, 'best' for offline renders when\n    there's plenty time available and best quality, 'realtime' for streams and low latency\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/VP9#DeadlineQuality\n    \"\"\"\n\n    row_multithreading: bool = Field(default=True)\n    \"\"\"Faster encodes by splitting rows into multiple threads. Slight innacuracy on the rate control.\n    Recommended for &gt;= 1080p videos. Requires libvpx &gt;= 1.7.0 (you should have it)\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/VP9#rowmt\n    \"\"\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-c:v\", \"libvpx-vp9\")\n        yield (\"-crf\", self.crf)\n        yield (\"-b:v\", 0)\n        yield (\"-deadline\", self.deadline)\n        yield (\"-cpu-used\", self.speed)\n        yield (\"-row-mt\", \"1\") * self.row_multithreading\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecVP9.codec","title":"<code>codec: Literal['libvpx-vp9'] = 'libvpx-vp9'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecVP9.crf","title":"<code>crf: int = Field(default=30, gt=-1, lt=64)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant Rate Factor (0-63). Lower values mean better quality, recommended (15-31) \u2022 https://trac.ffmpeg.org/wiki/Encode/VP9#constantq</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecVP9.speed","title":"<code>speed: int = Field(default=4, gt=-1, lt=6)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Speed level (0-6). Higher values yields faster encoding but innacuracies in rate control \u2022 https://trac.ffmpeg.org/wiki/Encode/VP9#CPUUtilizationSpeed</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecVP9.deadline","title":"<code>deadline: Optional[Literal['good', 'best', 'realtime']] = Field(default='good')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Tweak the encoding time philosophy. 'good' for general cases, 'best' for offline renders when there's plenty time available and best quality, 'realtime' for streams and low latency \u2022 https://trac.ffmpeg.org/wiki/Encode/VP9#DeadlineQuality</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecVP9.row_multithreading","title":"<code>row_multithreading: bool = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Faster encodes by splitting rows into multiple threads. Slight innacuracy on the rate control. Recommended for &gt;= 1080p videos. Requires libvpx &gt;= 1.7.0 (you should have it) \u2022 https://trac.ffmpeg.org/wiki/Encode/VP9#rowmt</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecVP9.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-c:v\", \"libvpx-vp9\")\n    yield (\"-crf\", self.crf)\n    yield (\"-b:v\", 0)\n    yield (\"-deadline\", self.deadline)\n    yield (\"-cpu-used\", self.speed)\n    yield (\"-row-mt\", \"1\") * self.row_multithreading\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_LIBAOM","title":"<code>Externals.FFmpeg.FFmpegVideoCodecAV1_LIBAOM</code>","text":"<p>The reference encoder for AV1. Similar to VP9, not the fastest current implementation \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#libaom</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecAV1_LIBAOM(FFmpegModuleBase):\n    \"\"\"The reference encoder for AV1. Similar to VP9, not the fastest current implementation\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#libaom\n    \"\"\"\n    codec: Literal[\"libaom-av1\"] = \"libaom-av1\"\n\n    crf: int = Field(default=23, gt=-1, lt=64)\n    \"\"\"Constant Rate Factor (0-63). Lower values mean better quality, AV1 CRF 23 == x264 CRF 19\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#ConstantQuality\n    \"\"\"\n\n    speed: int = Field(default=3, gt=-1, lt=7)\n    \"\"\"Speed level (0-6). Higher values yields faster encoding but innacuracies in rate control\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#ControllingSpeedQuality\n    \"\"\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-c:v\", \"libaom-av1\")\n        yield (\"-crf\", self.crf)\n        yield (\"-cpu-used\", self.speed)\n        yield (\"-row-mt\", 1)\n        yield (\"-tiles\", \"2x2\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_LIBAOM.codec","title":"<code>codec: Literal['libaom-av1'] = 'libaom-av1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_LIBAOM.crf","title":"<code>crf: int = Field(default=23, gt=-1, lt=64)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant Rate Factor (0-63). Lower values mean better quality, AV1 CRF 23 == x264 CRF 19 \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#ConstantQuality</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_LIBAOM.speed","title":"<code>speed: int = Field(default=3, gt=-1, lt=7)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Speed level (0-6). Higher values yields faster encoding but innacuracies in rate control \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#ControllingSpeedQuality</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_LIBAOM.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-c:v\", \"libaom-av1\")\n    yield (\"-crf\", self.crf)\n    yield (\"-cpu-used\", self.speed)\n    yield (\"-row-mt\", 1)\n    yield (\"-tiles\", \"2x2\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_SVT","title":"<code>Externals.FFmpeg.FFmpegVideoCodecAV1_SVT</code>","text":"<p>The official codec for future development of AV1. Faster than libaom reference \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#SVT-AV1</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecAV1_SVT(FFmpegModuleBase):\n    \"\"\"The official codec for future development of AV1. Faster than libaom reference\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#SVT-AV1\n    \"\"\"\n    codec: Literal[\"libsvtav1\"] = \"libsvtav1\"\n\n    crf: int = Field(default=25, gt=-1, lt=64)\n    \"\"\"Constant Rate Factor (0-63). Lower values mean better quality,\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#CRF\n    \"\"\"\n\n    preset: int = Field(default=3, gt=-1, lt=9)\n    \"\"\"The speed of the encoding, 0 is slowest, 8 is fastest. Decreases compression efficiency.\n    \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#Presetsandtunes\n    \"\"\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-c:v\", \"libsvtav1\")\n        yield (\"-crf\", self.crf)\n        yield (\"-preset\", self.preset)\n        yield (\"-svtav1-params\", \"tune=0\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_SVT.codec","title":"<code>codec: Literal['libsvtav1'] = 'libsvtav1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_SVT.crf","title":"<code>crf: int = Field(default=25, gt=-1, lt=64)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant Rate Factor (0-63). Lower values mean better quality, \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#CRF</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_SVT.preset","title":"<code>preset: int = Field(default=3, gt=-1, lt=9)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The speed of the encoding, 0 is slowest, 8 is fastest. Decreases compression efficiency. \u2022 https://trac.ffmpeg.org/wiki/Encode/AV1#Presetsandtunes</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_SVT.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-c:v\", \"libsvtav1\")\n    yield (\"-crf\", self.crf)\n    yield (\"-preset\", self.preset)\n    yield (\"-svtav1-params\", \"tune=0\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_RAV1E","title":"<code>Externals.FFmpeg.FFmpegVideoCodecAV1_RAV1E</code>","text":"<p><code>ffmpeg -h encoder=librav1e</code> https://github.com/xiph/rav1e</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecAV1_RAV1E(FFmpegModuleBase):\n    \"\"\"`ffmpeg -h encoder=librav1e`\n    https://github.com/xiph/rav1e\n    \"\"\"\n    codec: Literal[\"librav1e\"] = \"librav1e\"\n\n    qp: int = Field(default=80, gt=-2)\n    \"\"\"Constant quantizer mode (from -1 to 255). Smaller values are higher quality\"\"\"\n\n    speed: int = Field(default=4, gt=-1, lt=11)\n    \"\"\"What speed preset to use (from -1 to 10) (default -1)\"\"\"\n\n    tile_rows: int = Field(default=2, gt=-1)\n    \"\"\"Number of tile rows to encode with (from -1 to I64_MAX) (default 0)\"\"\"\n\n    tile_columns: int = Field(default=2, gt=-1)\n    \"\"\"Number of tile columns to encode with (from -1 to I64_MAX) (default 0)\"\"\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-c:v\", \"librav1e\")\n        yield (\"-qp\", self.qp)\n        yield (\"-speed\", self.speed)\n        yield (\"-tile-rows\", self.tile_rows)\n        yield (\"-tile-columns\", self.tile_columns)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_RAV1E.codec","title":"<code>codec: Literal['librav1e'] = 'librav1e'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_RAV1E.qp","title":"<code>qp: int = Field(default=80, gt=-2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant quantizer mode (from -1 to 255). Smaller values are higher quality</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_RAV1E.speed","title":"<code>speed: int = Field(default=4, gt=-1, lt=11)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>What speed preset to use (from -1 to 10) (default -1)</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_RAV1E.tile_rows","title":"<code>tile_rows: int = Field(default=2, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of tile rows to encode with (from -1 to I64_MAX) (default 0)</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_RAV1E.tile_columns","title":"<code>tile_columns: int = Field(default=2, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of tile columns to encode with (from -1 to I64_MAX) (default 0)</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_RAV1E.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-c:v\", \"librav1e\")\n    yield (\"-qp\", self.qp)\n    yield (\"-speed\", self.speed)\n    yield (\"-tile-rows\", self.tile_rows)\n    yield (\"-tile-columns\", self.tile_columns)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC","title":"<code>Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC</code>","text":"<p><code>ffmpeg -h encoder=av1_nvenc</code> NVIDIA's NVENC encoder for AV1</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC--warning-requires-a-rtx-4000-gpu-ada-love-lace-architecture-or-newer","title":"Warning: REQUIRES A RTX 4000+ GPU (ADA Love Lace Architecture or newer","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecAV1_NVENC(FFmpegModuleBase):\n    \"\"\"`ffmpeg -h encoder=av1_nvenc`\n    NVIDIA's NVENC encoder for AV1\n    # Warning: REQUIRES A RTX 4000+ GPU (ADA Love Lace Architecture or newer\n    \"\"\"\n    codec: Literal[\"av1_nvenc\"] = \"av1_nvenc\"\n\n    preset: Optional[Literal[\n        \"default\", # Defaults to p4\n        \"slow\", # High quality 2 passes\n        \"medium\", # High quality 1 pass\n        \"fast\", # High quality 1 pass\n        \"p1\", # fastest\n        \"p2\", # faster\n        \"p3\", # fast\n        \"p4\", # medium\n        \"p5\", # slow\n        \"p6\", # slower\n        \"p7\", # slowest\n    ]] = Field(default=\"p5\")\n\n    tune: Optional[Literal[\n        \"hq\", # High quality\n        \"ll\", # Low latency\n        \"ull\", # Ultra low latency\n        \"lossless\" # Lossless\n    ]] = Field(default=\"hq\")\n\n    rc: Optional[Literal[\n        \"constqp\", # Constant Quality 'Factor'\n        \"vbr\", # Variable bitrate\n        \"cbr\", # Constant bitrate\n    ]] = Field(default=\"vbr\")\n    \"\"\"'Rate Control' mode\"\"\"\n\n    multipass: Optional[Literal[\n        \"disabled\",\n        \"qres\", # First pass is quarter resolution\n        \"fullres\", # First pass is full resolution\n    ]] = Field(default=\"fullres\")\n\n    tile_rows: Optional[int] = Field(default=2, gt=-1, lt=65)\n    \"\"\"Number of encoding tile rows, similar to -row-mt\"\"\"\n\n    tile_columns: Optional[int] = Field(default=2, gt=-1, lt=65)\n    \"\"\"Number of encoding tile columns, similar to -col-mt\"\"\"\n\n    rc_lookahead: Optional[int] = Field(default=10, gt=-1)\n    \"\"\"Number of frames to look ahead for the rate control\"\"\"\n\n    gpu: int = Field(default=0, gt=-1)\n    \"\"\"Use the Nth NVENC capable GPU for encoding\"\"\"\n\n    cq: int = Field(default=25, gt=-1)\n    \"\"\"Set the Constant Quality factor in a Variable Bitrate mode (similar to -crf)\"\"\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:v\", \"av1_nvenc\")\n        yield self.all(\"-preset\", self.preset)\n        yield self.all(\"-tune\", self.tune)\n        yield self.all(\"-rc\", self.rc)\n        yield self.all(\"-rc-lookahead\", self.rc_lookahead)\n        yield self.all(\"-cq\", self.cq)\n        yield self.all(\"-gpu\", self.gpu)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.codec","title":"<code>codec: Literal['av1_nvenc'] = 'av1_nvenc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.preset","title":"<code>preset: Optional[Literal['default', 'slow', 'medium', 'fast', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7']] = Field(default='p5')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.tune","title":"<code>tune: Optional[Literal['hq', 'll', 'ull', 'lossless']] = Field(default='hq')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.rc","title":"<code>rc: Optional[Literal['constqp', 'vbr', 'cbr']] = Field(default='vbr')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>'Rate Control' mode</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.multipass","title":"<code>multipass: Optional[Literal['disabled', 'qres', 'fullres']] = Field(default='fullres')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.tile_rows","title":"<code>tile_rows: Optional[int] = Field(default=2, gt=-1, lt=65)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of encoding tile rows, similar to -row-mt</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.tile_columns","title":"<code>tile_columns: Optional[int] = Field(default=2, gt=-1, lt=65)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of encoding tile columns, similar to -col-mt</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.rc_lookahead","title":"<code>rc_lookahead: Optional[int] = Field(default=10, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of frames to look ahead for the rate control</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.gpu","title":"<code>gpu: int = Field(default=0, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the Nth NVENC capable GPU for encoding</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.cq","title":"<code>cq: int = Field(default=25, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set the Constant Quality factor in a Variable Bitrate mode (similar to -crf)</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecAV1_NVENC.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:v\", \"av1_nvenc\")\n    yield self.all(\"-preset\", self.preset)\n    yield self.all(\"-tune\", self.tune)\n    yield self.all(\"-rc\", self.rc)\n    yield self.all(\"-rc-lookahead\", self.rc_lookahead)\n    yield self.all(\"-cq\", self.cq)\n    yield self.all(\"-gpu\", self.gpu)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecRawvideo","title":"<code>Externals.FFmpeg.FFmpegVideoCodecRawvideo</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecRawvideo(FFmpegModuleBase):\n    codec: Literal[\"rawvideo\"] = \"rawvideo\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-c:v\", \"rawvideo\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecRawvideo.codec","title":"<code>codec: Literal['rawvideo'] = 'rawvideo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecRawvideo.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-c:v\", \"rawvideo\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecNoVideo","title":"<code>Externals.FFmpeg.FFmpegVideoCodecNoVideo</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecNoVideo(FFmpegModuleBase):\n    codec: Literal[\"null\"] = \"null\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-c:v\", \"null\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecNoVideo.codec","title":"<code>codec: Literal['null'] = 'null'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecNoVideo.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-c:v\", \"null\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecCopy","title":"<code>Externals.FFmpeg.FFmpegVideoCodecCopy</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegVideoCodecCopy(FFmpegModuleBase):\n    codec: Literal[\"copy\"] = \"copy\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-c:v\", \"copy\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecCopy.codec","title":"<code>codec: Literal['copy'] = 'copy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecCopy.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-c:v\", \"copy\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegVideoCodecType","title":"<code>Externals.FFmpeg.FFmpegVideoCodecType: TypeAlias = Union[FFmpegVideoCodecH264, FFmpegVideoCodecH264_NVENC, FFmpegVideoCodecH265, FFmpegVideoCodecH265_NVENC, FFmpegVideoCodecVP9, FFmpegVideoCodecAV1_LIBAOM, FFmpegVideoCodecAV1_SVT, FFmpegVideoCodecAV1_NVENC, FFmpegVideoCodecAV1_RAV1E, FFmpegVideoCodecRawvideo, FFmpegVideoCodecNoVideo, FFmpegVideoCodecCopy]</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecAAC","title":"<code>Externals.FFmpeg.FFmpegAudioCodecAAC</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegAudioCodecAAC(FFmpegModuleBase):\n    codec: Literal[\"aac\"] = \"aac\"\n\n    bitrate: int = Field(default=192, gt=-1)\n    \"\"\"Bitrate in kilobits per second. This value is shared between all audio channels\"\"\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:a\", \"aac\")\n        yield self.all(\"-b:a\", f\"{self.bitrate}k\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecAAC.codec","title":"<code>codec: Literal['aac'] = 'aac'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecAAC.bitrate","title":"<code>bitrate: int = Field(default=192, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Bitrate in kilobits per second. This value is shared between all audio channels</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecAAC.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:a\", \"aac\")\n    yield self.all(\"-b:a\", f\"{self.bitrate}k\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecMP3","title":"<code>Externals.FFmpeg.FFmpegAudioCodecMP3</code>","text":"<p>https://trac.ffmpeg.org/wiki/Encode/MP3</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegAudioCodecMP3(FFmpegModuleBase):\n    \"\"\"https://trac.ffmpeg.org/wiki/Encode/MP3\"\"\"\n    codec: Literal[\"mp3\"] = \"mp3\"\n\n    qscale: int = Field(default=2, gt=-1)\n    \"\"\"Quality scale, 0-9, Variable Bitrate\"\"\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:a\", \"libmp3lame\")\n        yield self.all(\"-qscale:a\", self.qscale)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecMP3.codec","title":"<code>codec: Literal['mp3'] = 'mp3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecMP3.qscale","title":"<code>qscale: int = Field(default=2, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Quality scale, 0-9, Variable Bitrate</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecMP3.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:a\", \"libmp3lame\")\n    yield self.all(\"-qscale:a\", self.qscale)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecOpus","title":"<code>Externals.FFmpeg.FFmpegAudioCodecOpus</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegAudioCodecOpus(FFmpegModuleBase):\n    codec: Literal[\"libopus\"] = \"libopus\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:a\", \"libopus\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecOpus.codec","title":"<code>codec: Literal['libopus'] = 'libopus'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecOpus.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:a\", \"libopus\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecVorbis","title":"<code>Externals.FFmpeg.FFmpegAudioCodecVorbis</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegAudioCodecVorbis(FFmpegModuleBase):\n    codec: Literal[\"libvorbis\"] = \"libvorbis\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:a\", \"libvorbis\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecVorbis.codec","title":"<code>codec: Literal['libvorbis'] = 'libvorbis'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecVorbis.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:a\", \"libvorbis\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecFLAC","title":"<code>Externals.FFmpeg.FFmpegAudioCodecFLAC</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegAudioCodecFLAC(FFmpegModuleBase):\n    codec: Literal[\"flac\"] = \"flac\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield self.all(\"-c:a\", \"flac\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecFLAC.codec","title":"<code>codec: Literal['flac'] = 'flac'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecFLAC.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield self.all(\"-c:a\", \"flac\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecCopy","title":"<code>Externals.FFmpeg.FFmpegAudioCodecCopy</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegAudioCodecCopy(FFmpegModuleBase):\n    codec: Literal[\"copy\"] = \"copy\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-c:a\", \"copy\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecCopy.codec","title":"<code>codec: Literal['copy'] = 'copy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecCopy.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-c:a\", \"copy\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecNone","title":"<code>Externals.FFmpeg.FFmpegAudioCodecNone</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegAudioCodecNone(FFmpegModuleBase):\n    codec: Literal[\"none\"] = \"none\"\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-an\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecNone.codec","title":"<code>codec: Literal['none'] = 'none'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecNone.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-an\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecEmpty","title":"<code>Externals.FFmpeg.FFmpegAudioCodecEmpty</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegAudioCodecEmpty(FFmpegModuleBase):\n    codec: Literal[\"anullsrc\"] = \"anullsrc\"\n    samplerate: float = 44100\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-f\", \"lavfi\", \"-i\", f\"anullsrc=channel_layout=stereo:sample_rate={self.samplerate}\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecEmpty.codec","title":"<code>codec: Literal['anullsrc'] = 'anullsrc'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecEmpty.samplerate","title":"<code>samplerate: float = 44100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecEmpty.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-f\", \"lavfi\", \"-i\", f\"anullsrc=channel_layout=stereo:sample_rate={self.samplerate}\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM","title":"<code>Externals.FFmpeg.FFmpegPCM</code>","text":"<p>Raw pcm formats <code>ffmpeg -formats | grep PCM</code></p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegPCM(BrokenEnum):\n    \"\"\"Raw pcm formats `ffmpeg -formats | grep PCM`\"\"\"\n    PCM_FLOAT_32_BITS_BIG_ENDIAN       = \"pcm_f32be\"\n    PCM_FLOAT_32_BITS_LITTLE_ENDIAN    = \"pcm_f32le\"\n    PCM_FLOAT_64_BITS_BIG_ENDIAN       = \"pcm_f64be\"\n    PCM_FLOAT_64_BITS_LITTLE_ENDIAN    = \"pcm_f64le\"\n    PCM_SIGNED_16_BITS_BIG_ENDIAN      = \"pcm_s16be\"\n    PCM_SIGNED_16_BITS_LITTLE_ENDIAN   = \"pcm_s16le\"\n    PCM_SIGNED_24_BITS_BIG_ENDIAN      = \"pcm_s24be\"\n    PCM_SIGNED_24_BITS_LITTLE_ENDIAN   = \"pcm_s24le\"\n    PCM_SIGNED_32_BITS_BIG_ENDIAN      = \"pcm_s32be\"\n    PCM_SIGNED_32_BITS_LITTLE_ENDIAN   = \"pcm_s32le\"\n    PCM_UNSIGNED_16_BITS_BIG_ENDIAN    = \"pcm_u16be\"\n    PCM_UNSIGNED_16_BITS_LITTLE_ENDIAN = \"pcm_u16le\"\n    PCM_UNSIGNED_24_BITS_BIG_ENDIAN    = \"pcm_u24be\"\n    PCM_UNSIGNED_24_BITS_LITTLE_ENDIAN = \"pcm_u24le\"\n    PCM_UNSIGNED_32_BITS_BIG_ENDIAN    = \"pcm_u32be\"\n    PCM_UNSIGNED_32_BITS_LITTLE_ENDIAN = \"pcm_u32le\"\n    PCM_UNSIGNED_8_BITS                = \"pcm_u8\"\n    PCM_SIGNED_8_BITS                  = \"pcm_s8\"\n\n    @property\n    @functools.lru_cache\n    def size(self) -&gt; int:\n        return int(''.join(filter(str.isdigit, self.value)))//8\n\n    @property\n    @functools.lru_cache\n    def endian(self) -&gt; str:\n        return \"&lt;\" if (\"le\" in self.value) else \"&gt;\"\n\n    @property\n    @functools.lru_cache\n    def dtype(self) -&gt; numpy.dtype:\n        type = self.value.split(\"_\")[1][0]\n        return numpy.dtype(f\"{self.endian}{type}{self.size}\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_FLOAT_32_BITS_BIG_ENDIAN","title":"<code>PCM_FLOAT_32_BITS_BIG_ENDIAN = 'pcm_f32be'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_FLOAT_32_BITS_LITTLE_ENDIAN","title":"<code>PCM_FLOAT_32_BITS_LITTLE_ENDIAN = 'pcm_f32le'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_FLOAT_64_BITS_BIG_ENDIAN","title":"<code>PCM_FLOAT_64_BITS_BIG_ENDIAN = 'pcm_f64be'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_FLOAT_64_BITS_LITTLE_ENDIAN","title":"<code>PCM_FLOAT_64_BITS_LITTLE_ENDIAN = 'pcm_f64le'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_SIGNED_16_BITS_BIG_ENDIAN","title":"<code>PCM_SIGNED_16_BITS_BIG_ENDIAN = 'pcm_s16be'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_SIGNED_16_BITS_LITTLE_ENDIAN","title":"<code>PCM_SIGNED_16_BITS_LITTLE_ENDIAN = 'pcm_s16le'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_SIGNED_24_BITS_BIG_ENDIAN","title":"<code>PCM_SIGNED_24_BITS_BIG_ENDIAN = 'pcm_s24be'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_SIGNED_24_BITS_LITTLE_ENDIAN","title":"<code>PCM_SIGNED_24_BITS_LITTLE_ENDIAN = 'pcm_s24le'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_SIGNED_32_BITS_BIG_ENDIAN","title":"<code>PCM_SIGNED_32_BITS_BIG_ENDIAN = 'pcm_s32be'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_SIGNED_32_BITS_LITTLE_ENDIAN","title":"<code>PCM_SIGNED_32_BITS_LITTLE_ENDIAN = 'pcm_s32le'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_UNSIGNED_16_BITS_BIG_ENDIAN","title":"<code>PCM_UNSIGNED_16_BITS_BIG_ENDIAN = 'pcm_u16be'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_UNSIGNED_16_BITS_LITTLE_ENDIAN","title":"<code>PCM_UNSIGNED_16_BITS_LITTLE_ENDIAN = 'pcm_u16le'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_UNSIGNED_24_BITS_BIG_ENDIAN","title":"<code>PCM_UNSIGNED_24_BITS_BIG_ENDIAN = 'pcm_u24be'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_UNSIGNED_24_BITS_LITTLE_ENDIAN","title":"<code>PCM_UNSIGNED_24_BITS_LITTLE_ENDIAN = 'pcm_u24le'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_UNSIGNED_32_BITS_BIG_ENDIAN","title":"<code>PCM_UNSIGNED_32_BITS_BIG_ENDIAN = 'pcm_u32be'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_UNSIGNED_32_BITS_LITTLE_ENDIAN","title":"<code>PCM_UNSIGNED_32_BITS_LITTLE_ENDIAN = 'pcm_u32le'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_UNSIGNED_8_BITS","title":"<code>PCM_UNSIGNED_8_BITS = 'pcm_u8'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.PCM_SIGNED_8_BITS","title":"<code>PCM_SIGNED_8_BITS = 'pcm_s8'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.size","title":"<code>size: int</code>  <code>cached</code> <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.endian","title":"<code>endian: str</code>  <code>cached</code> <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegPCM.dtype","title":"<code>dtype: numpy.dtype</code>  <code>cached</code> <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecPCM","title":"<code>Externals.FFmpeg.FFmpegAudioCodecPCM</code>","text":"<p>Raw pcm formats <code>ffmpeg -formats | grep PCM</code></p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegAudioCodecPCM(FFmpegModuleBase):\n    \"\"\"Raw pcm formats `ffmpeg -formats | grep PCM`\"\"\"\n    format: FFmpegPCM = Field(default=FFmpegPCM.PCM_FLOAT_32_BITS_LITTLE_ENDIAN)\n\n    def command(self) -&gt; Iterable[str]:\n        yield (\"-c:a\", self.format.value, \"-f\", self.format.value.removeprefix(\"pcm_\"))\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecPCM.format","title":"<code>format: FFmpegPCM = Field(default=FFmpegPCM.PCM_FLOAT_32_BITS_LITTLE_ENDIAN)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecPCM.command","title":"<code>command() -&gt; Iterable[str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def command(self) -&gt; Iterable[str]:\n    yield (\"-c:a\", self.format.value, \"-f\", self.format.value.removeprefix(\"pcm_\"))\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegAudioCodecType","title":"<code>Externals.FFmpeg.FFmpegAudioCodecType: TypeAlias = Union[FFmpegAudioCodecAAC, FFmpegAudioCodecMP3, FFmpegAudioCodecOpus, FFmpegAudioCodecFLAC, FFmpegAudioCodecCopy, FFmpegAudioCodecNone, FFmpegAudioCodecEmpty, FFmpegAudioCodecPCM]</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterBase","title":"<code>Externals.FFmpeg.FFmpegFilterBase</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegFilterBase(BaseModel, ABC):\n\n    @abstractmethod\n    def string(self) -&gt; Iterable[str]:\n        ...\n\n    def __str__(self) -&gt; str:\n        return self.string()\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterBase.string","title":"<code>string() -&gt; Iterable[str]</code>  <code>abstractmethod</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@abstractmethod\ndef string(self) -&gt; Iterable[str]:\n    ...\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterBase.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def __str__(self) -&gt; str:\n    return self.string()\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterScale","title":"<code>Externals.FFmpeg.FFmpegFilterScale</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegFilterScale(FFmpegFilterBase):\n    width: int = Field(gt=0)\n    height: int = Field(gt=0)\n    resample: Literal[\n        \"lanczos\",\n        \"bicubic\",\n        \"fast_bilinear\",\n        \"point\",\n        \"spline\",\n    ] = Field(default=\"lanczos\")\n\n    def string(self) -&gt; str:\n        return f\"scale={self.width}:{self.height}:flags={self.resample}\"\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterScale.width","title":"<code>width: int = Field(gt=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterScale.height","title":"<code>height: int = Field(gt=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterScale.resample","title":"<code>resample: Literal['lanczos', 'bicubic', 'fast_bilinear', 'point', 'spline'] = Field(default='lanczos')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterScale.string","title":"<code>string() -&gt; str</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def string(self) -&gt; str:\n    return f\"scale={self.width}:{self.height}:flags={self.resample}\"\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterVerticalFlip","title":"<code>Externals.FFmpeg.FFmpegFilterVerticalFlip</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegFilterVerticalFlip(FFmpegFilterBase):\n    def string(self) -&gt; str:\n        return \"vflip\"\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterVerticalFlip.string","title":"<code>string() -&gt; str</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def string(self) -&gt; str:\n    return \"vflip\"\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterCustom","title":"<code>Externals.FFmpeg.FFmpegFilterCustom</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class FFmpegFilterCustom(FFmpegFilterBase):\n    content: str\n\n    def string(self) -&gt; str:\n        return self.content\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterCustom.content","title":"<code>content: str</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterCustom.string","title":"<code>string() -&gt; str</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def string(self) -&gt; str:\n    return self.content\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.FFmpegFilterType","title":"<code>Externals.FFmpeg.FFmpegFilterType: TypeAlias = Union[FFmpegFilterScale, FFmpegFilterVerticalFlip, FFmpegFilterCustom]</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.SerdeBaseModel","title":"<code>Externals.FFmpeg.SerdeBaseModel</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class SerdeBaseModel(BaseModel):\n    def serialize(self, json: bool=True) -&gt; Union[dict, str]:\n        if json: return self.model_dump_json()\n        return self.model_dump()\n\n    @classmethod\n    def deserialize(cls, value: Union[dict, str]) -&gt; Self:\n        if isinstance(value, dict):\n            return cls.model_validate(value)\n        elif isinstance(value, str):\n            return cls.model_validate_json(value)\n        else:\n            raise ValueError(f\"Can't deserialize value of type {type(value)}\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.SerdeBaseModel.serialize","title":"<code>serialize(json: bool = True) -&gt; Union[dict, str]</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def serialize(self, json: bool=True) -&gt; Union[dict, str]:\n    if json: return self.model_dump_json()\n    return self.model_dump()\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.SerdeBaseModel.deserialize","title":"<code>deserialize(value: Union[dict, str]) -&gt; Self</code>  <code>classmethod</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@classmethod\ndef deserialize(cls, value: Union[dict, str]) -&gt; Self:\n    if isinstance(value, dict):\n        return cls.model_validate(value)\n    elif isinstance(value, str):\n        return cls.model_validate_json(value)\n    else:\n        raise ValueError(f\"Can't deserialize value of type {type(value)}\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg","title":"<code>Externals.FFmpeg.BrokenFFmpeg</code>","text":"<p>Your Premium (^Fluent) FFmpeg class in Python, safety checks and sane defaults</p> <p>Todo: Write quick usage examples</p> <p>Note: FFmpeg always outputs text to the stderr, as stdout is reserved for pipe outputs <code>a | b</code></p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>class BrokenFFmpeg(SerdeBaseModel):\n    \"\"\"\n    Your Premium (^Fluent) FFmpeg class in Python, safety checks and sane defaults\n\n    Todo: Write quick usage examples\n\n    Note: FFmpeg always outputs text to the stderr, as stdout is reserved for pipe outputs `a | b`\n    \"\"\"\n\n    hide_banner: bool = True\n    \"\"\"Hides the compilation information of FFmpeg from the output\"\"\"\n\n    shortest: bool = False\n    \"\"\"\n    Ends the output at the shortest stream duration. For example, if the input is an 30s audio and\n    a 20s video, and we're joining the two, the final video will be 20s. Or piping frames, 30s\n\n    [**FFmpeg docs**](https://ffmpeg.org/ffmpeg.html#toc-Advanced-options)\n    \"\"\"\n\n    stream_loop: int = Field(default=0)\n    \"\"\"Loops the input stream N times to the right. Zero '0' is no loop, one '1' doubles the length\"\"\"\n\n    time: float = Field(default=0.0)\n\n    vsync: Literal[\"auto\", \"passthrough\", \"cfr\", \"vfr\"] = Field(default=\"cfr\")\n    \"\"\"\n    The video's framerate mode, applied to all subsequent output targets\n\n    - `auto`: FFmpeg default, choses between constant and variable framerate based on muxer support\n    - `cfr`: Constant Frame Rate, where frames are droped or duped to precisely match frametimes\n    - `vfr`: Variable Frame Rate, static frames are kept, no two frames have the same timestemp\n    - `passthrough`: The frames are passed through without modification on their timestamp\n\n    [**FFmpeg docs**](https://ffmpeg.org/ffmpeg.html#Advanced-options)\n    \"\"\"\n\n    loglevel: Literal[\n        \"error\",\n        \"info\",\n        \"verbose\",\n        \"debug\",\n        \"warning\",\n        \"panic\",\n        \"fatal\",\n    ] = Field(default=\"info\")\n\n    hwaccel: Optional[Literal[\n        \"auto\",\n        \"cuda\",\n        \"nvdec\",\n        \"vulkan\",\n    ]] = Field(default=None)\n    \"\"\"\n    What device to bootstrap, for decoding with hardware acceleration. In practice, it's only useful\n    when decoding from a source video file, might cause overhead on pipe input mode\n\n    - `auto`: Finds up the best device to use, more often than not nvdec or cuvid\n\n    TODO: Add the required initializers on the final command per option\n\n    [**FFmpeg docs**](https://trac.ffmpeg.org/wiki/HWAccelIntro)\n    \"\"\"\n\n    threads: int = Field(default=0, gt=-1)\n    \"\"\"\n    The number of threads the codec should use. Generally speaking, more threads yields worse quality\n    and compression ratios, but drastically improves performance. Some codecs might not use all\n    available CPU threads. '0' finds the optimal amount automatically\n\n    [**FFmpeg docs**](https://ffmpeg.org/ffmpeg-codecs.html#toc-Codec-Options)\n    \"\"\"\n\n    inputs: List[FFmpegInputType] = Field(default_factory=list)\n\n    filters: List[FFmpegFilterType] = Field(default_factory=list)\n\n    outputs: List[FFmpegOutputType] = Field(default_factory=list)\n    \"\"\"A list of outputs. Yes, FFmpeg natively supports multi-encoding targets\"\"\"\n\n    video_codec: Optional[FFmpegVideoCodecType] = Field(default=None)\n    \"\"\"The video codec to use and its configuration\"\"\"\n\n    audio_codec: Optional[FFmpegAudioCodecType] = Field(default=None)\n    \"\"\"The audio codec to use and its configuration\"\"\"\n\n    def quiet(self) -&gt; Self:\n        self.hide_banner = True\n        self.loglevel = \"error\"\n        return self\n\n    # ---------------------------------------------------------------------------------------------|\n    # Wrappers for all classes\n\n    # Inputs and Outputs\n\n    @functools.wraps(FFmpegInputPath)\n    def input(self, path: Path, **kwargs) -&gt; Self:\n        self.inputs.append(FFmpegInputPath(path=path, **kwargs))\n        return self\n\n    @functools.wraps(FFmpegInputPipe)\n    def pipe_input(self, **kwargs) -&gt; Self:\n        self.inputs.append(FFmpegInputPipe(**kwargs))\n        return self\n\n    @functools.wraps(FFmpegOutputPath)\n    def output(self, path: Path, **kwargs) -&gt; Self:\n        self.outputs.append(FFmpegOutputPath(path=path, **kwargs))\n        return self\n\n    @functools.wraps(FFmpegOutputPipe)\n    def pipe_output(self, **kwargs) -&gt; Self:\n        self.outputs.append(FFmpegOutputPipe(**kwargs))\n        return self\n\n    # Video codecs\n\n    @functools.wraps(FFmpegVideoCodecH264)\n    def h264(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecH264(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecH264_NVENC)\n    def h264_nvenc(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecH264_NVENC(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecH265)\n    def h265(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecH265(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecH265_NVENC)\n    def h265_nvenc(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecH265_NVENC(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecVP9)\n    def vp9(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecVP9(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecAV1_LIBAOM)\n    def av1_aom(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecAV1_LIBAOM(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecAV1_SVT)\n    def av1_svt(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecAV1_SVT(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecAV1_NVENC)\n    def av1_nvenc(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecAV1_NVENC(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecAV1_RAV1E)\n    def av1_rav1e(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecAV1_RAV1E(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecRawvideo)\n    def rawvideo(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecRawvideo(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecCopy)\n    def copy_video(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecCopy(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegVideoCodecNoVideo)\n    def no_video(self, **kwargs) -&gt; Self:\n        self.video_codec = FFmpegVideoCodecNoVideo(**kwargs)\n        return self\n\n    def apply_vcodec_str(self, codec: str) -&gt; Self:\n        codec = codec.replace(\"_\", \"-\").lower()\n        if   (codec == \"h264\"      ): self.h264()\n        elif (codec == \"h264-nvenc\"): self.h264_nvenc()\n        elif (codec == \"h265\"      ): self.h265()\n        elif (codec == \"h265-nvenc\"): self.h265_nvenc()\n        elif (codec == \"hevc-nvenc\"): self.h265_nvenc()\n        elif (codec == \"vp9\"       ): self.vp9()\n        elif (codec == \"av1-aom\"   ): self.av1_aom()\n        elif (codec == \"av1-svt\"   ): self.av1_svt()\n        elif (codec == \"av1-nvenc\" ): self.av1_nvenc()\n        elif (codec == \"av1-rav1e\" ): self.av1_rav1e()\n        else: raise ValueError(f\"Unknown Video Codec: {codec}\")\n        return self\n\n    # Audio codecs\n\n    @functools.wraps(FFmpegAudioCodecAAC)\n    def aac(self, **kwargs) -&gt; Self:\n        self.audio_codec = FFmpegAudioCodecAAC(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegAudioCodecMP3)\n    def mp3(self, **kwargs) -&gt; Self:\n        self.audio_codec = FFmpegAudioCodecMP3(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegAudioCodecOpus)\n    def opus(self, **kwargs) -&gt; Self:\n        self.audio_codec = FFmpegAudioCodecOpus(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegAudioCodecFLAC)\n    def flac(self, **kwargs) -&gt; Self:\n        self.audio_codec = FFmpegAudioCodecFLAC(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegAudioCodecPCM)\n    def pcm(self, format: FFmpegAudioCodecPCM=\"pcm_f32le\") -&gt; Self:\n        self.audio_codec = FFmpegAudioCodecPCM(format=format)\n        return self\n\n    @functools.wraps(FFmpegAudioCodecCopy)\n    def copy_audio(self, **kwargs) -&gt; Self:\n        self.audio_codec = FFmpegAudioCodecCopy(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegAudioCodecNone)\n    def no_audio(self, **kwargs) -&gt; Self:\n        self.audio_codec = FFmpegAudioCodecNone(**kwargs)\n        return self\n\n    @functools.wraps(FFmpegAudioCodecEmpty)\n    def empty_audio(self, **kwargs) -&gt; Self:\n        self.audio_codec = FFmpegAudioCodecEmpty(**kwargs)\n        return self\n\n    def apply_acodec_str(self, codec: str) -&gt; Self:\n        codec = codec.lower()\n        if   (codec == \"aac\"   ): self.aac()\n        elif (codec == \"mp3\"   ): self.mp3()\n        elif (codec == \"opus\"  ): self.opus()\n        elif (codec == \"flac\"  ): self.flac()\n        elif (codec == \"copy\"  ): self.copy_audio()\n        elif (codec == \"none\"  ): self.no_audio()\n        elif (codec == \"empty\" ): self.empty_audio()\n        else: raise ValueError(f\"Unknown Audio Codec: {codec}\")\n        return self\n\n    # Filters\n\n    @functools.wraps(FFmpegFilterScale)\n    def scale(self, **kwargs) -&gt; Self:\n        self.filters.append(FFmpegFilterScale(**kwargs))\n        return self\n\n    @functools.wraps(FFmpegFilterVerticalFlip)\n    def vflip(self, **kwargs) -&gt; Self:\n        self.filters.append(FFmpegFilterVerticalFlip(**kwargs))\n        return self\n\n    @functools.wraps(FFmpegFilterCustom)\n    def filter(self, **kwargs) -&gt; Self:\n        self.filters.append(FFmpegFilterCustom(**kwargs))\n        return self\n\n    # ---------------------------------------------------------------------------------------------|\n    # Command building and running\n\n    @property\n    def command(self) -&gt; List[str]:\n        BrokenFFmpeg.install()\n\n        if (not self.inputs):\n            raise ValueError(\"At least one input is required for FFmpeg\")\n        if (not self.outputs):\n            raise ValueError(\"At least one output is required for FFmpeg\")\n\n        command = deque()\n\n        def extend(*objects: Union[FFmpegModuleBase, Iterable[FFmpegModuleBase]]):\n            for item in flatten(objects):\n                if isinstance(item, FFmpegModuleBase):\n                    command.extend(flatten(item.command()))\n                else:\n                    command.append(item)\n\n        extend(shutil.which(\"ffmpeg\"))\n        extend((\"-stream_loop\", self.stream_loop)*bool(self.stream_loop))\n        extend(\"-threads\", self.threads)\n        extend(\"-hide_banner\"*self.hide_banner)\n        extend(\"-loglevel\", self.loglevel)\n        extend((\"-hwaccel\", self.hwaccel)*bool(self.hwaccel))\n        extend((\"-t\", self.time)*bool(self.time))\n        extend(self.inputs)\n\n        # Note: https://trac.ffmpeg.org/wiki/Creating%20multiple%20outputs\n        for output in self.outputs:\n            extend(self.audio_codec)\n            extend(self.video_codec)\n            extend((\"-vf\", \",\".join(map(str, self.filters)))*bool(self.filters))\n            extend(output)\n\n        extend(\"-shortest\"*self.shortest)\n        return list(map(str, denum(flatten(command))))\n\n    def run(self, **kwargs) -&gt; subprocess.CompletedProcess:\n        return shell(self.command, **kwargs)\n\n    def popen(self, **kwargs) -&gt; subprocess.Popen:\n        return shell(self.command, Popen=True, **kwargs)\n\n    # ---------------------------------------------------------------------------------------------|\n    # High level functions\n\n    @staticmethod\n    def install() -&gt; None:\n        if all(map(BrokenPath.which, (\"ffmpeg\", \"ffprobe\"))):\n            return\n\n        if not BrokenPlatform.OnMacOS:\n            log.info(\"FFmpeg wasn't found on System Path, will download a BtbN's Build\")\n            BrokenPath.get_external(''.join((\n                \"https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/\",\n                \"ffmpeg-master-latest-\",\n                BrokenPlatform.Name.replace(\"windows\", \"win\"),\n                BrokenPlatform.Architecture.replace(\"amd64\", \"64\"),\n                \"-gpl.zip\" if BrokenPlatform.OnWindows else \"-gpl.tar.xz\"\n            )))\n        else:\n            log.info(\"FFmpeg wasn't found on System Path, will download a EverMeet's Build\")\n            for binary in (\"ffmpeg\", \"ffprobe\"):\n                BrokenPath.get_external(f\"https://evermeet.cx/ffmpeg/getrelease/{binary}/zip\")\n\n    # # Video\n\n    @staticmethod\n    @functools.lru_cache\n    def get_video_resolution(path: Path, *, echo: bool=True) -&gt; Optional[Tuple[int, int]]:\n        \"\"\"Get the resolution of a video in a smart way\"\"\"\n        if not (path := BrokenPath(path, valid=True)):\n            return None\n        BrokenFFmpeg.install()\n        log.minor(f\"Getting Video Resolution of ({path})\", echo=echo)\n        return PIL.Image.open(io.BytesIO(shell(\n            shutil.which(\"ffmpeg\"), \"-hide_banner\", \"-loglevel\", \"error\",\n            \"-i\", path, \"-vframes\", \"1\", \"-f\", \"image2pipe\", \"-\",\n            stdout=PIPE, echo=echo\n        ).stdout), formats=[\"jpeg\"]).size\n\n    @staticmethod\n    def iter_video_frames(path: Path, *, skip: int=0, echo: bool=True) -&gt; Optional[Iterable[numpy.ndarray]]:\n        \"\"\"Generator for every frame of the video as numpy arrays, FAST!\"\"\"\n        if not (path := BrokenPath(path, valid=True)):\n            return None\n        BrokenFFmpeg.install()\n        (width, height) = BrokenFFmpeg.get_video_resolution(path)\n        log.minor(f\"Streaming Video Frames from file ({path}) @ ({width}x{height})\", echo=echo)\n        ffmpeg = (BrokenFFmpeg(vsync=\"cfr\")\n            .quiet()\n            .input(path=path)\n            .filter(content=f\"select='gte(n\\\\,{skip})'\")\n            .rawvideo()\n            .no_audio()\n            .pipe_output(format=\"rawvideo\")\n        ).popen(stdout=PIPE, echo=echo)\n\n        # Keep reading frames until we run out, each pixel is 3 bytes !\n        while (raw := ffmpeg.stdout.read(width * height * 3)):\n            yield numpy.frombuffer(raw, dtype=numpy.uint8).reshape((height, width, 3))\n\n    @staticmethod\n    @functools.lru_cache\n    def get_video_total_frames(path: Path, *, echo: bool=True) -&gt; Optional[int]:\n        \"\"\"Count the total frames of a video by decode voiding and parsing stats output\"\"\"\n        if not (path := BrokenPath(path, valid=True)):\n            return None\n        BrokenFFmpeg.install()\n        with BrokenSpinner(log.minor(f\"Getting total frames of video ({path}) by decoding every frame, might take a while..\")):\n            return int(re.compile(r\"frame=\\s*(\\d+)\").findall((\n                BrokenFFmpeg(vsync=\"cfr\")\n                .input(path=path)\n                .pipe_output(format=\"null\")\n            ).run(stderr=PIPE, echo=echo).stderr.decode())[-1])\n\n    @staticmethod\n    @functools.lru_cache\n    def get_video_duration(path: Path, *, echo: bool=True) -&gt; Optional[float]:\n        if not (path := BrokenPath(path, valid=True)):\n            return None\n        BrokenFFmpeg.install()\n        log.minor(f\"Getting Video Duration of file ({path})\", echo=echo)\n        return float(shell(\n            BrokenPath.which(\"ffprobe\"),\n            \"-i\", path,\n            \"-show_entries\", \"format=duration\",\n            \"-v\", \"quiet\", \"-of\", \"csv=p=0\",\n            output=True, echo=echo\n        ))\n\n    @staticmethod\n    @functools.lru_cache\n    def get_video_framerate(path: Path, *, precise: bool=False, echo: bool=True) -&gt; Optional[float]:\n        if not (path := BrokenPath(path, valid=True)):\n            return None\n        BrokenFFmpeg.install()\n        log.minor(f\"Getting Video Framerate of file ({path})\", echo=echo)\n        if precise:\n            A = BrokenFFmpeg.get_video_total_frames(path, echo=False)\n            B = BrokenFFmpeg.get_video_duration(path, echo=False)\n            return (A/B)\n        else:\n            return float(flatten(eval(shell(\n                BrokenPath.which(\"ffprobe\"),\n                \"-i\", path,\n                \"-show_entries\", \"stream=r_frame_rate\",\n                \"-v\", \"quiet\", \"-of\", \"csv=p=0\",\n                output=True, echo=echo\n            ).splitlines()[0]))[0])\n\n    # # Audio\n\n    @staticmethod\n    @functools.lru_cache\n    def get_audio_samplerate(path: Path, *, stream: int=0, echo: bool=True) -&gt; Optional[float]:\n        if not (path := BrokenPath(path, valid=True)):\n            return None\n        BrokenFFmpeg.install()\n        log.minor(f\"Getting Audio Samplerate of file ({path})\", echo=echo)\n        return int(shell(\n            BrokenPath.which(\"ffprobe\"),\n            \"-i\", path,\n            \"-show_entries\", \"stream=sample_rate\",\n            \"-v\", \"quiet\", \"-of\", \"csv=p=0\",\n            output=True, echo=echo\n        ).strip().splitlines()[stream])\n\n    @staticmethod\n    @functools.lru_cache\n    def get_audio_channels(path: Path, *, stream: int=0, echo: bool=True) -&gt; Optional[int]:\n        if not (path := BrokenPath(path, valid=True)):\n            return None\n        BrokenFFmpeg.install()\n        log.minor(f\"Getting Audio Channels of file ({path})\", echo=echo)\n        return int(shell(\n            BrokenPath.which(\"ffprobe\"),\n            \"-i\", path,\n            \"-show_entries\", \"stream=channels\",\n            \"-v\", \"quiet\", \"-of\", \"csv=p=0\",\n            output=True, echo=echo\n        ).strip().splitlines()[stream])\n\n    @staticmethod\n    def get_audio_duration(path: Path, *, echo: bool=True) -&gt; Optional[float]:\n        if not (path := BrokenPath(path, valid=True)):\n            return\n        try:\n            generator = BrokenAudioReader(path=path, chunk=10).stream\n            while next(generator) is not None: ...\n        except StopIteration as result:\n            return result.value\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.hide_banner","title":"<code>hide_banner: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hides the compilation information of FFmpeg from the output</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.shortest","title":"<code>shortest: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Ends the output at the shortest stream duration. For example, if the input is an 30s audio and a 20s video, and we're joining the two, the final video will be 20s. Or piping frames, 30s</p> <p>FFmpeg docs</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.stream_loop","title":"<code>stream_loop: int = Field(default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Loops the input stream N times to the right. Zero '0' is no loop, one '1' doubles the length</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.time","title":"<code>time: float = Field(default=0.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.vsync","title":"<code>vsync: Literal['auto', 'passthrough', 'cfr', 'vfr'] = Field(default='cfr')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The video's framerate mode, applied to all subsequent output targets</p> <ul> <li><code>auto</code>: FFmpeg default, choses between constant and variable framerate based on muxer support</li> <li><code>cfr</code>: Constant Frame Rate, where frames are droped or duped to precisely match frametimes</li> <li><code>vfr</code>: Variable Frame Rate, static frames are kept, no two frames have the same timestemp</li> <li><code>passthrough</code>: The frames are passed through without modification on their timestamp</li> </ul> <p>FFmpeg docs</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.loglevel","title":"<code>loglevel: Literal['error', 'info', 'verbose', 'debug', 'warning', 'panic', 'fatal'] = Field(default='info')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.hwaccel","title":"<code>hwaccel: Optional[Literal['auto', 'cuda', 'nvdec', 'vulkan']] = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>What device to bootstrap, for decoding with hardware acceleration. In practice, it's only useful when decoding from a source video file, might cause overhead on pipe input mode</p> <ul> <li><code>auto</code>: Finds up the best device to use, more often than not nvdec or cuvid</li> </ul> <p>TODO: Add the required initializers on the final command per option</p> <p>FFmpeg docs</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.threads","title":"<code>threads: int = Field(default=0, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of threads the codec should use. Generally speaking, more threads yields worse quality and compression ratios, but drastically improves performance. Some codecs might not use all available CPU threads. '0' finds the optimal amount automatically</p> <p>FFmpeg docs</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.inputs","title":"<code>inputs: List[FFmpegInputType] = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.filters","title":"<code>filters: List[FFmpegFilterType] = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.outputs","title":"<code>outputs: List[FFmpegOutputType] = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of outputs. Yes, FFmpeg natively supports multi-encoding targets</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.video_codec","title":"<code>video_codec: Optional[FFmpegVideoCodecType] = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The video codec to use and its configuration</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.audio_codec","title":"<code>audio_codec: Optional[FFmpegAudioCodecType] = Field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The audio codec to use and its configuration</p>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.quiet","title":"<code>quiet() -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def quiet(self) -&gt; Self:\n    self.hide_banner = True\n    self.loglevel = \"error\"\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.input","title":"<code>input(path: Path, **kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegInputPath)\ndef input(self, path: Path, **kwargs) -&gt; Self:\n    self.inputs.append(FFmpegInputPath(path=path, **kwargs))\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.pipe_input","title":"<code>pipe_input(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegInputPipe)\ndef pipe_input(self, **kwargs) -&gt; Self:\n    self.inputs.append(FFmpegInputPipe(**kwargs))\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.output","title":"<code>output(path: Path, **kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegOutputPath)\ndef output(self, path: Path, **kwargs) -&gt; Self:\n    self.outputs.append(FFmpegOutputPath(path=path, **kwargs))\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.pipe_output","title":"<code>pipe_output(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegOutputPipe)\ndef pipe_output(self, **kwargs) -&gt; Self:\n    self.outputs.append(FFmpegOutputPipe(**kwargs))\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.h264","title":"<code>h264(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecH264)\ndef h264(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecH264(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.h264_nvenc","title":"<code>h264_nvenc(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecH264_NVENC)\ndef h264_nvenc(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecH264_NVENC(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.h265","title":"<code>h265(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecH265)\ndef h265(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecH265(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.h265_nvenc","title":"<code>h265_nvenc(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecH265_NVENC)\ndef h265_nvenc(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecH265_NVENC(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.vp9","title":"<code>vp9(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecVP9)\ndef vp9(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecVP9(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.av1_aom","title":"<code>av1_aom(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecAV1_LIBAOM)\ndef av1_aom(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecAV1_LIBAOM(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.av1_svt","title":"<code>av1_svt(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecAV1_SVT)\ndef av1_svt(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecAV1_SVT(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.av1_nvenc","title":"<code>av1_nvenc(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecAV1_NVENC)\ndef av1_nvenc(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecAV1_NVENC(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.av1_rav1e","title":"<code>av1_rav1e(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecAV1_RAV1E)\ndef av1_rav1e(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecAV1_RAV1E(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.rawvideo","title":"<code>rawvideo(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecRawvideo)\ndef rawvideo(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecRawvideo(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.copy_video","title":"<code>copy_video(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecCopy)\ndef copy_video(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecCopy(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.no_video","title":"<code>no_video(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegVideoCodecNoVideo)\ndef no_video(self, **kwargs) -&gt; Self:\n    self.video_codec = FFmpegVideoCodecNoVideo(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.apply_vcodec_str","title":"<code>apply_vcodec_str(codec: str) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def apply_vcodec_str(self, codec: str) -&gt; Self:\n    codec = codec.replace(\"_\", \"-\").lower()\n    if   (codec == \"h264\"      ): self.h264()\n    elif (codec == \"h264-nvenc\"): self.h264_nvenc()\n    elif (codec == \"h265\"      ): self.h265()\n    elif (codec == \"h265-nvenc\"): self.h265_nvenc()\n    elif (codec == \"hevc-nvenc\"): self.h265_nvenc()\n    elif (codec == \"vp9\"       ): self.vp9()\n    elif (codec == \"av1-aom\"   ): self.av1_aom()\n    elif (codec == \"av1-svt\"   ): self.av1_svt()\n    elif (codec == \"av1-nvenc\" ): self.av1_nvenc()\n    elif (codec == \"av1-rav1e\" ): self.av1_rav1e()\n    else: raise ValueError(f\"Unknown Video Codec: {codec}\")\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.aac","title":"<code>aac(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegAudioCodecAAC)\ndef aac(self, **kwargs) -&gt; Self:\n    self.audio_codec = FFmpegAudioCodecAAC(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.mp3","title":"<code>mp3(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegAudioCodecMP3)\ndef mp3(self, **kwargs) -&gt; Self:\n    self.audio_codec = FFmpegAudioCodecMP3(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.opus","title":"<code>opus(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegAudioCodecOpus)\ndef opus(self, **kwargs) -&gt; Self:\n    self.audio_codec = FFmpegAudioCodecOpus(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.flac","title":"<code>flac(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegAudioCodecFLAC)\ndef flac(self, **kwargs) -&gt; Self:\n    self.audio_codec = FFmpegAudioCodecFLAC(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.pcm","title":"<code>pcm(format: FFmpegAudioCodecPCM = 'pcm_f32le') -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegAudioCodecPCM)\ndef pcm(self, format: FFmpegAudioCodecPCM=\"pcm_f32le\") -&gt; Self:\n    self.audio_codec = FFmpegAudioCodecPCM(format=format)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.copy_audio","title":"<code>copy_audio(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegAudioCodecCopy)\ndef copy_audio(self, **kwargs) -&gt; Self:\n    self.audio_codec = FFmpegAudioCodecCopy(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.no_audio","title":"<code>no_audio(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegAudioCodecNone)\ndef no_audio(self, **kwargs) -&gt; Self:\n    self.audio_codec = FFmpegAudioCodecNone(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.empty_audio","title":"<code>empty_audio(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegAudioCodecEmpty)\ndef empty_audio(self, **kwargs) -&gt; Self:\n    self.audio_codec = FFmpegAudioCodecEmpty(**kwargs)\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.apply_acodec_str","title":"<code>apply_acodec_str(codec: str) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def apply_acodec_str(self, codec: str) -&gt; Self:\n    codec = codec.lower()\n    if   (codec == \"aac\"   ): self.aac()\n    elif (codec == \"mp3\"   ): self.mp3()\n    elif (codec == \"opus\"  ): self.opus()\n    elif (codec == \"flac\"  ): self.flac()\n    elif (codec == \"copy\"  ): self.copy_audio()\n    elif (codec == \"none\"  ): self.no_audio()\n    elif (codec == \"empty\" ): self.empty_audio()\n    else: raise ValueError(f\"Unknown Audio Codec: {codec}\")\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.scale","title":"<code>scale(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegFilterScale)\ndef scale(self, **kwargs) -&gt; Self:\n    self.filters.append(FFmpegFilterScale(**kwargs))\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.vflip","title":"<code>vflip(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegFilterVerticalFlip)\ndef vflip(self, **kwargs) -&gt; Self:\n    self.filters.append(FFmpegFilterVerticalFlip(**kwargs))\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.filter","title":"<code>filter(**kwargs) -&gt; Self</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@functools.wraps(FFmpegFilterCustom)\ndef filter(self, **kwargs) -&gt; Self:\n    self.filters.append(FFmpegFilterCustom(**kwargs))\n    return self\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.command","title":"<code>command: List[str]</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.run","title":"<code>run(**kwargs) -&gt; subprocess.CompletedProcess</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def run(self, **kwargs) -&gt; subprocess.CompletedProcess:\n    return shell(self.command, **kwargs)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.popen","title":"<code>popen(**kwargs) -&gt; subprocess.Popen</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>def popen(self, **kwargs) -&gt; subprocess.Popen:\n    return shell(self.command, Popen=True, **kwargs)\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.install","title":"<code>install() -&gt; None</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@staticmethod\ndef install() -&gt; None:\n    if all(map(BrokenPath.which, (\"ffmpeg\", \"ffprobe\"))):\n        return\n\n    if not BrokenPlatform.OnMacOS:\n        log.info(\"FFmpeg wasn't found on System Path, will download a BtbN's Build\")\n        BrokenPath.get_external(''.join((\n            \"https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/\",\n            \"ffmpeg-master-latest-\",\n            BrokenPlatform.Name.replace(\"windows\", \"win\"),\n            BrokenPlatform.Architecture.replace(\"amd64\", \"64\"),\n            \"-gpl.zip\" if BrokenPlatform.OnWindows else \"-gpl.tar.xz\"\n        )))\n    else:\n        log.info(\"FFmpeg wasn't found on System Path, will download a EverMeet's Build\")\n        for binary in (\"ffmpeg\", \"ffprobe\"):\n            BrokenPath.get_external(f\"https://evermeet.cx/ffmpeg/getrelease/{binary}/zip\")\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.get_video_resolution","title":"<code>get_video_resolution(path: Path, *, echo: bool = True) -&gt; Optional[Tuple[int, int]]</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Get the resolution of a video in a smart way</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef get_video_resolution(path: Path, *, echo: bool=True) -&gt; Optional[Tuple[int, int]]:\n    \"\"\"Get the resolution of a video in a smart way\"\"\"\n    if not (path := BrokenPath(path, valid=True)):\n        return None\n    BrokenFFmpeg.install()\n    log.minor(f\"Getting Video Resolution of ({path})\", echo=echo)\n    return PIL.Image.open(io.BytesIO(shell(\n        shutil.which(\"ffmpeg\"), \"-hide_banner\", \"-loglevel\", \"error\",\n        \"-i\", path, \"-vframes\", \"1\", \"-f\", \"image2pipe\", \"-\",\n        stdout=PIPE, echo=echo\n    ).stdout), formats=[\"jpeg\"]).size\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.iter_video_frames","title":"<code>iter_video_frames(path: Path, *, skip: int = 0, echo: bool = True) -&gt; Optional[Iterable[numpy.ndarray]]</code>  <code>staticmethod</code>","text":"<p>Generator for every frame of the video as numpy arrays, FAST!</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@staticmethod\ndef iter_video_frames(path: Path, *, skip: int=0, echo: bool=True) -&gt; Optional[Iterable[numpy.ndarray]]:\n    \"\"\"Generator for every frame of the video as numpy arrays, FAST!\"\"\"\n    if not (path := BrokenPath(path, valid=True)):\n        return None\n    BrokenFFmpeg.install()\n    (width, height) = BrokenFFmpeg.get_video_resolution(path)\n    log.minor(f\"Streaming Video Frames from file ({path}) @ ({width}x{height})\", echo=echo)\n    ffmpeg = (BrokenFFmpeg(vsync=\"cfr\")\n        .quiet()\n        .input(path=path)\n        .filter(content=f\"select='gte(n\\\\,{skip})'\")\n        .rawvideo()\n        .no_audio()\n        .pipe_output(format=\"rawvideo\")\n    ).popen(stdout=PIPE, echo=echo)\n\n    # Keep reading frames until we run out, each pixel is 3 bytes !\n    while (raw := ffmpeg.stdout.read(width * height * 3)):\n        yield numpy.frombuffer(raw, dtype=numpy.uint8).reshape((height, width, 3))\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.get_video_total_frames","title":"<code>get_video_total_frames(path: Path, *, echo: bool = True) -&gt; Optional[int]</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Count the total frames of a video by decode voiding and parsing stats output</p> Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef get_video_total_frames(path: Path, *, echo: bool=True) -&gt; Optional[int]:\n    \"\"\"Count the total frames of a video by decode voiding and parsing stats output\"\"\"\n    if not (path := BrokenPath(path, valid=True)):\n        return None\n    BrokenFFmpeg.install()\n    with BrokenSpinner(log.minor(f\"Getting total frames of video ({path}) by decoding every frame, might take a while..\")):\n        return int(re.compile(r\"frame=\\s*(\\d+)\").findall((\n            BrokenFFmpeg(vsync=\"cfr\")\n            .input(path=path)\n            .pipe_output(format=\"null\")\n        ).run(stderr=PIPE, echo=echo).stderr.decode())[-1])\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.get_video_duration","title":"<code>get_video_duration(path: Path, *, echo: bool = True) -&gt; Optional[float]</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef get_video_duration(path: Path, *, echo: bool=True) -&gt; Optional[float]:\n    if not (path := BrokenPath(path, valid=True)):\n        return None\n    BrokenFFmpeg.install()\n    log.minor(f\"Getting Video Duration of file ({path})\", echo=echo)\n    return float(shell(\n        BrokenPath.which(\"ffprobe\"),\n        \"-i\", path,\n        \"-show_entries\", \"format=duration\",\n        \"-v\", \"quiet\", \"-of\", \"csv=p=0\",\n        output=True, echo=echo\n    ))\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.get_video_framerate","title":"<code>get_video_framerate(path: Path, *, precise: bool = False, echo: bool = True) -&gt; Optional[float]</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef get_video_framerate(path: Path, *, precise: bool=False, echo: bool=True) -&gt; Optional[float]:\n    if not (path := BrokenPath(path, valid=True)):\n        return None\n    BrokenFFmpeg.install()\n    log.minor(f\"Getting Video Framerate of file ({path})\", echo=echo)\n    if precise:\n        A = BrokenFFmpeg.get_video_total_frames(path, echo=False)\n        B = BrokenFFmpeg.get_video_duration(path, echo=False)\n        return (A/B)\n    else:\n        return float(flatten(eval(shell(\n            BrokenPath.which(\"ffprobe\"),\n            \"-i\", path,\n            \"-show_entries\", \"stream=r_frame_rate\",\n            \"-v\", \"quiet\", \"-of\", \"csv=p=0\",\n            output=True, echo=echo\n        ).splitlines()[0]))[0])\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.get_audio_samplerate","title":"<code>get_audio_samplerate(path: Path, *, stream: int = 0, echo: bool = True) -&gt; Optional[float]</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef get_audio_samplerate(path: Path, *, stream: int=0, echo: bool=True) -&gt; Optional[float]:\n    if not (path := BrokenPath(path, valid=True)):\n        return None\n    BrokenFFmpeg.install()\n    log.minor(f\"Getting Audio Samplerate of file ({path})\", echo=echo)\n    return int(shell(\n        BrokenPath.which(\"ffprobe\"),\n        \"-i\", path,\n        \"-show_entries\", \"stream=sample_rate\",\n        \"-v\", \"quiet\", \"-of\", \"csv=p=0\",\n        output=True, echo=echo\n    ).strip().splitlines()[stream])\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.get_audio_channels","title":"<code>get_audio_channels(path: Path, *, stream: int = 0, echo: bool = True) -&gt; Optional[int]</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef get_audio_channels(path: Path, *, stream: int=0, echo: bool=True) -&gt; Optional[int]:\n    if not (path := BrokenPath(path, valid=True)):\n        return None\n    BrokenFFmpeg.install()\n    log.minor(f\"Getting Audio Channels of file ({path})\", echo=echo)\n    return int(shell(\n        BrokenPath.which(\"ffprobe\"),\n        \"-i\", path,\n        \"-show_entries\", \"stream=channels\",\n        \"-v\", \"quiet\", \"-of\", \"csv=p=0\",\n        output=True, echo=echo\n    ).strip().splitlines()[stream])\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenFFmpeg.get_audio_duration","title":"<code>get_audio_duration(path: Path, *, echo: bool = True) -&gt; Optional[float]</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@staticmethod\ndef get_audio_duration(path: Path, *, echo: bool=True) -&gt; Optional[float]:\n    if not (path := BrokenPath(path, valid=True)):\n        return\n    try:\n        generator = BrokenAudioReader(path=path, chunk=10).stream\n        while next(generator) is not None: ...\n    except StopIteration as result:\n        return result.value\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader","title":"<code>Externals.FFmpeg.BrokenAudioReader</code>","text":"Source code in <code>Broken/Externals/FFmpeg.py</code> Python<pre><code>@define\nclass BrokenAudioReader:\n    path:        Path\n    chunk:       Seconds     = 0.1\n    format:      FFmpegPCM   = FFmpegPCM.PCM_FLOAT_32_BITS_LITTLE_ENDIAN\n    echo:        bool        = False\n    _read:       Bytes       = 0\n    _channels:   int         = None\n    _samplerate: Hertz       = None\n    _dtype:      numpy.dtype = None\n    _size:       int         = 4\n    _ffmpeg:     Popen       = None\n\n    @property\n    def time(self) -&gt; Seconds: # noqa\n        return self._read / self.bytes_per_second\n\n    @property\n    def channels(self) -&gt; int:\n        return self._channels\n\n    @property\n    def samplerate(self) -&gt; Hertz:\n        return self._samplerate\n\n    @property\n    def dtype(self) -&gt; numpy.dtype:\n        return self._dtype\n\n    @property\n    def size(self) -&gt; int:\n        return self._size\n\n    @property\n    def bytes_per_second(self) -&gt; int:\n        return (self.size * self.channels * self.samplerate)\n\n    @property\n    def bytes_per_sample(self) -&gt; int:\n        return (self.size * self.channels)\n\n    @property\n    def stream(self) -&gt; Generator[numpy.ndarray, None, None]:\n        if not (path := BrokenPath(self.path, valid=True)):\n            return None\n        self.path = path\n\n        # Get audio file attributes\n        self._channels   = BrokenFFmpeg.get_audio_channels(self.path, echo=self.echo)\n        self._samplerate = BrokenFFmpeg.get_audio_samplerate(self.path, echo=self.echo)\n        self.format = FFmpegPCM.get(self.format)\n        self._dtype = self.format.dtype\n        self._size = self.format.size\n        self._read = 0\n\n\n        # Note: Stderr to null as we might not read all the audio, won't log errors\n        self._ffmpeg = (\n            BrokenFFmpeg()\n            .quiet()\n            .input(path=self.path)\n            .pcm(self.format.value)\n            .no_video()\n            .output(\"-\")\n        ).popen(stdout=PIPE)\n\n        \"\"\"\n        One could think the following code is the way, but it is not\n\n        ```python\n        while (data := ffmpeg.stdout.read(chunk*samplerate)):\n            yield (...)\n        ```\n\n        Reason being:\n        \u2022 Small reads yields time imprecision on sample domain vs time domain\n        \u2022 Must keep track of theoretical time and real time of the read\n        \"\"\"\n        target = 0\n\n        while True:\n            target += self.chunk\n\n            # Calculate the length of the next read to best match the target time,\n            # but do not carry over temporal conversion errors\n            length = (target - self.time) * self.bytes_per_second\n            length = nearest(length, self.bytes_per_sample, type=int)\n            length = max(length, self.bytes_per_sample)\n            data   = self._ffmpeg.stdout.read(length)\n            if len(data) == 0: break\n\n            # Increment precise time and read time\n            yield numpy.frombuffer(data, dtype=self.dtype).reshape(-1, self.channels)\n            self._read += len(data)\n\n        return self.time\n</code></pre>"},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.path","title":"<code>path: Path</code>  <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.chunk","title":"<code>chunk: Seconds = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.format","title":"<code>format: FFmpegPCM = FFmpegPCM.PCM_FLOAT_32_BITS_LITTLE_ENDIAN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.echo","title":"<code>echo: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.time","title":"<code>time: Seconds</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.channels","title":"<code>channels: int</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.samplerate","title":"<code>samplerate: Hertz</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.dtype","title":"<code>dtype: numpy.dtype</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.size","title":"<code>size: int</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.bytes_per_second","title":"<code>bytes_per_second: int</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.bytes_per_sample","title":"<code>bytes_per_sample: int</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/ffmpeg/#Externals.FFmpeg.BrokenAudioReader.stream","title":"<code>stream: Generator[numpy.ndarray, None, None]</code>  <code>property</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/","title":"ncnn","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn","title":"<code>Externals.Upscaler.ncnn</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base","title":"<code>Externals.Upscaler.ncnn.UpscalerNCNN_Base</code>","text":"Source code in <code>Broken/Externals/Upscaler/ncnn.py</code> Python<pre><code>class UpscalerNCNN_Base(BrokenUpscaler):\n    denoise: Annotated[int, typer.Option(\"--denoise\", \"-n\", min=0, max=3,\n        help=\"[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Denoiser intensity. Great for digital art, 'fake, uncanny' otherwise\")] = \\\n        Field(default=3, gt=-1)\n\n    tile_size: Annotated[int, typer.Option(\"--tile-size\", \"-t\", min=0,\n        help=\"[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Processing chunk size, increases VRAM and Speed, 0 is auto, must be &gt;= 32\")] = \\\n        Field(default=0, gt=-1)\n\n    tta: Annotated[bool, typer.Option(\"--tta\", \"-x\",\n        help=\"[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Enable test-time augmentation (Similar to SSAA) [red](8x SLOWER)[/red]\")] = \\\n        Field(default=False)\n\n    cpu: Annotated[bool, typer.Option(\"--cpu\", \"-c\",\n        help=\"[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Use CPU for processing instead of the GPU [yellow](SLOW)[/yellow]\")] = \\\n        Field(default=False)\n\n    gpu: Annotated[int, typer.Option(\"--gpu\", \"-g\", min=0,\n        help=\"[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Use the Nth GPU for processing\")] = \\\n        Field(default=0, gt=-1)\n\n    load_threads: Annotated[int, typer.Option(\"--load-threads\", \"-lt\", min=1,\n        help=\"[bold][green](\ud83d\udfe2 Advanced)[/green][/bold] Number of Load Threads\")] \\\n        = Field(default=1, gt=0)\n\n    proc_threads: Annotated[int, typer.Option(\"--proc-threads\", \"-pt\", min=1,\n        help=\"[bold][green](\ud83d\udfe2 Advanced)[/green][/bold] Number of Process Threads\")] \\\n        = Field(default=2, gt=0)\n\n    save_threads: Annotated[int, typer.Option(\"--save-threads\", \"-st\", min=1,\n        help=\"[bold][green](\ud83d\udfe2 Advanced)[/green][/bold] Number of Saving Threads\")] \\\n        = Field(default=2, gt=0)\n\n    @property\n    def _lpc(self) -&gt; str:\n        return f\"{self.load_threads}:{self.proc_threads}:{self.save_threads}\"\n\n    # Make the process only use one random core\n    def preexec_fn(self):\n        import os\n        import random\n        import resource\n        core = random.choice(range(os.cpu_count()))\n        os.sched_setaffinity(0, {core})\n        resource.setrlimit(resource.RLIMIT_CPU, (1, 1))\n\n    @field_validator(\"tile_size\", mode=\"plain\")\n    def _validate_tile_size(cls, value):\n        if not ((value == 0) or (value &gt;= 32)):\n            raise ValueError(\"Tile size must be 0 or &gt;= 32 for NCNN Upscalers\")\n        return value\n\n    # # Metadata for automatic downloads\n\n    @staticmethod\n    @abstractmethod\n    def _base_download() -&gt; str:\n        \"\"\"https://.../stuff-{platform}.zip\"\"\"\n        ...\n\n    @staticmethod\n    @abstractmethod\n    def _binary_name() -&gt; str:\n        ...\n\n    def download(self) -&gt; Path:\n        if (binary := shutil.which(self._binary_name())):\n            return BrokenPath(binary)\n        DOWNLOAD = self._base_download().format(BrokenPlatform.Name.replace(\"linux\", \"ubuntu\"))\n        EXECUTABLE = self._binary_name() + (\".exe\"*BrokenPlatform.OnWindows)\n        return BrokenPath.make_executable(next(BrokenPath.get_external(DOWNLOAD).rglob(EXECUTABLE)))\n</code></pre>"},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.denoise","title":"<code>denoise: Annotated[int, typer.Option(--denoise, -n, min=0, max=3, help=\"[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Denoiser intensity. Great for digital art, 'fake, uncanny' otherwise\")] = Field(default=3, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.tile_size","title":"<code>tile_size: Annotated[int, typer.Option(--tile - size, -t, min=0, help='[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Processing chunk size, increases VRAM and Speed, 0 is auto, must be &gt;= 32')] = Field(default=0, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.tta","title":"<code>tta: Annotated[bool, typer.Option(--tta, -x, help='[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Enable test-time augmentation (Similar to SSAA) [red](8x SLOWER)[/red]')] = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.cpu","title":"<code>cpu: Annotated[bool, typer.Option(--cpu, -c, help='[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Use CPU for processing instead of the GPU [yellow](SLOW)[/yellow]')] = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.gpu","title":"<code>gpu: Annotated[int, typer.Option(--gpu, -g, min=0, help='[bold][yellow](\ud83d\udfe1 Specific)[/yellow][/bold] Use the Nth GPU for processing')] = Field(default=0, gt=-1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.load_threads","title":"<code>load_threads: Annotated[int, typer.Option(--load - threads, -lt, min=1, help='[bold][green](\ud83d\udfe2 Advanced)[/green][/bold] Number of Load Threads')] = Field(default=1, gt=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.proc_threads","title":"<code>proc_threads: Annotated[int, typer.Option(--proc - threads, -pt, min=1, help='[bold][green](\ud83d\udfe2 Advanced)[/green][/bold] Number of Process Threads')] = Field(default=2, gt=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.save_threads","title":"<code>save_threads: Annotated[int, typer.Option(--save - threads, -st, min=1, help='[bold][green](\ud83d\udfe2 Advanced)[/green][/bold] Number of Saving Threads')] = Field(default=2, gt=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.preexec_fn","title":"<code>preexec_fn()</code>","text":"Source code in <code>Broken/Externals/Upscaler/ncnn.py</code> Python<pre><code>def preexec_fn(self):\n    import os\n    import random\n    import resource\n    core = random.choice(range(os.cpu_count()))\n    os.sched_setaffinity(0, {core})\n    resource.setrlimit(resource.RLIMIT_CPU, (1, 1))\n</code></pre>"},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.UpscalerNCNN_Base.download","title":"<code>download() -&gt; Path</code>","text":"Source code in <code>Broken/Externals/Upscaler/ncnn.py</code> Python<pre><code>def download(self) -&gt; Path:\n    if (binary := shutil.which(self._binary_name())):\n        return BrokenPath(binary)\n    DOWNLOAD = self._base_download().format(BrokenPlatform.Name.replace(\"linux\", \"ubuntu\"))\n    EXECUTABLE = self._binary_name() + (\".exe\"*BrokenPlatform.OnWindows)\n    return BrokenPath.make_executable(next(BrokenPath.get_external(DOWNLOAD).rglob(EXECUTABLE)))\n</code></pre>"},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Waifu2x","title":"<code>Externals.Upscaler.ncnn.Waifu2x</code>","text":"<p>Configure and use Waifu2x    green/green(by https://github.com/nihui/waifu2x-ncnn-vulkan)[/dim]</p> Source code in <code>Broken/Externals/Upscaler/ncnn.py</code> Python<pre><code>class Waifu2x(UpscalerNCNN_Base):\n    \"\"\"Configure and use Waifu2x    [green](See 'waifu2x --help' for options)[/green] [dim](by https://github.com/nihui/waifu2x-ncnn-vulkan)[/dim]\"\"\"\n\n    class Model(str, BrokenEnum):\n        models_cunet = \"models_cunet\"\n        models_upconv_7_anime_style_art_rgb = \"models_upconv_7_anime_style_art_rgb\"\n        models_upconv_7_photo = \"models_upconv_7_photo\"\n\n    model: Annotated[Model, typer.Option(\"--model\", \"-m\", hidden=True,\n        help=\"(\ud83d\udd35 Special ) Model to use for Waifu2x\")] = \\\n        Field(default=Model.models_cunet)\n\n    @staticmethod\n    def _base_download() -&gt; str:\n        return \"https://github.com/nihui/waifu2x-ncnn-vulkan/releases/download/20220728/waifu2x-ncnn-vulkan-20220728-{}.zip\"\n\n    @staticmethod\n    def _binary_name() -&gt; str:\n        return \"waifu2x-ncnn-vulkan\"\n\n    @field_validator(\"scale\", mode=\"plain\")\n    def _validate_scale(cls, value):\n        if value not in (allowed := {1, 2, 4, 8, 16, 32}):\n            raise ValueError(f\"Scale must be one of {allowed} for Waifu2x\")\n        return value\n\n    @field_validator(\"denoise\", mode=\"plain\")\n    def _validate_denoise(cls, value):\n        if value not in (allowed := {-1, 0, 1, 2, 3}):\n            raise ValueError(f\"Denoise must be one of {allowed} for Waifu2x\")\n        return value\n\n    def _upscale(self, input: Image, *, echo: bool=True, single_core: bool=False) -&gt; Image:\n        with self.path_image() as output:\n            with self.path_image(input) as input:\n                shell(\n                    self.download(),\n                    \"-i\", input,\n                    \"-o\", output,\n                    every(\"-n\", self.denoise),\n                    every(\"-s\", self.scale),\n                    every(\"-t\", self.tile_size),\n                    \"-g\", self.gpu if not self.cpu else -1,\n                    \"-j\", self._lpc,\n                    \"-x\"*self.tta,\n                    # \"-m\", self.model.value, # Fixme: Doko?\n                    stderr=DEVNULL,\n                    preexec_fn=(self.preexec_fn if single_core else None),\n                    cwd=self.download().parent,\n                    echo=echo,\n                )\n                return PIL.Image.open(output)\n</code></pre>"},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Waifu2x.Model","title":"<code>Model</code>","text":"Source code in <code>Broken/Externals/Upscaler/ncnn.py</code> Python<pre><code>class Model(str, BrokenEnum):\n    models_cunet = \"models_cunet\"\n    models_upconv_7_anime_style_art_rgb = \"models_upconv_7_anime_style_art_rgb\"\n    models_upconv_7_photo = \"models_upconv_7_photo\"\n</code></pre>"},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Waifu2x.Model.models_cunet","title":"<code>models_cunet = 'models_cunet'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Waifu2x.Model.models_upconv_7_anime_style_art_rgb","title":"<code>models_upconv_7_anime_style_art_rgb = 'models_upconv_7_anime_style_art_rgb'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Waifu2x.Model.models_upconv_7_photo","title":"<code>models_upconv_7_photo = 'models_upconv_7_photo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Waifu2x.model","title":"<code>model: Annotated[Model, typer.Option(--model, -m, hidden=True, help='(\ud83d\udd35 Special ) Model to use for Waifu2x')] = Field(default=Model.models_cunet)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Realesr","title":"<code>Externals.Upscaler.ncnn.Realesr</code>","text":"<p>Configure and use RealESRGAN green/green(by https://github.com/xinntao/Real-ESRGAN)[/dim]</p> Source code in <code>Broken/Externals/Upscaler/ncnn.py</code> Python<pre><code>class Realesr(UpscalerNCNN_Base):\n    \"\"\"Configure and use RealESRGAN [green](See 'realesr --help' for options)[/green] [dim](by https://github.com/xinntao/Real-ESRGAN)[/dim]\"\"\"\n\n    class Model(str, BrokenEnum):\n        realesr_animevideov3    = \"realesr_animevideov3\"\n        realesrgan_x4plus       = \"realesrgan_x4plus\"\n        realesrgan_x4plus_anime = \"realesrgan_x4plus_anime\"\n        realesrnet_x4plus       = \"realesrnet_x4plus\"\n\n    model: Annotated[Model, typer.Option(\"--model\", \"-m\", hidden=True,\n        help=\"(\ud83d\udd35 Special ) Model to use for RealESRGAN\")] = \\\n        Field(default=Model.realesr_animevideov3)\n\n    @staticmethod\n    def _base_download() -&gt; str:\n        return \"https://github.com/xinntao/Real-ESRGAN/releases/download/v0.2.5.0/realesrgan-ncnn-vulkan-20220424-{}.zip\"\n\n    @staticmethod\n    def _binary_name() -&gt; str:\n        return \"realesrgan-ncnn-vulkan\"\n\n    @field_validator(\"scale\", mode=\"plain\")\n    def _validate_scale(cls, value):\n        if value not in (allowed := {1, 2, 3, 4}):\n            raise ValueError(f\"Scale must be one of {allowed} for RealESRGAN\")\n        return value\n\n    def _upscale(self, input: Image, *, echo: bool=True, single_core: bool=False) -&gt; Image:\n        with self.path_image() as output:\n            with self.path_image(input) as input:\n                shell(\n                    self.download(),\n                    \"-i\", input,\n                    \"-o\", output,\n                    every(\"-s\", self.scale),\n                    every(\"-t\", self.tile_size),\n                    every(\"-g\", self.gpu if not self.cpu else -1),\n                    every(\"-n\", self.model.name.replace(\"_\", \"-\")),\n                    \"-j\", self._lpc,\n                    \"-x\"*self.tta,\n                    stderr=DEVNULL,\n                    preexec_fn=(self.preexec_fn if single_core else None),\n                    cwd=self.download().parent,\n                    echo=echo,\n                )\n                return PIL.Image.open(output)\n</code></pre>"},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Realesr.Model","title":"<code>Model</code>","text":"Source code in <code>Broken/Externals/Upscaler/ncnn.py</code> Python<pre><code>class Model(str, BrokenEnum):\n    realesr_animevideov3    = \"realesr_animevideov3\"\n    realesrgan_x4plus       = \"realesrgan_x4plus\"\n    realesrgan_x4plus_anime = \"realesrgan_x4plus_anime\"\n    realesrnet_x4plus       = \"realesrnet_x4plus\"\n</code></pre>"},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Realesr.Model.realesr_animevideov3","title":"<code>realesr_animevideov3 = 'realesr_animevideov3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Realesr.Model.realesrgan_x4plus","title":"<code>realesrgan_x4plus = 'realesrgan_x4plus'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Realesr.Model.realesrgan_x4plus_anime","title":"<code>realesrgan_x4plus_anime = 'realesrgan_x4plus_anime'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Realesr.Model.realesrnet_x4plus","title":"<code>realesrnet_x4plus = 'realesrnet_x4plus'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/externals/upscaler/ncnn/#Externals.Upscaler.ncnn.Realesr.model","title":"<code>model: Annotated[Model, typer.Option(--model, -m, hidden=True, help='(\ud83d\udd35 Special ) Model to use for RealESRGAN')] = Field(default=Model.realesr_animevideov3)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"broken/reference/loaders/loaderbytes/","title":"LoaderBytes","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/loaders/loaderbytes/#Loaders.LoaderBytes","title":"<code>Loaders.LoaderBytes</code>","text":""},{"location":"broken/reference/loaders/loaderbytes/#Loaders.LoaderBytes.LoaderBytes","title":"<code>Loaders.LoaderBytes.LoaderBytes</code>","text":"Source code in <code>Broken/Loaders/LoaderBytes.py</code> Python<pre><code>@define\nclass LoaderBytes(BrokenLoader):\n\n    @staticmethod\n    def load(value: Any=None, **kwargs) -&gt; Optional[bytes]:\n        if not value:\n            return b\"\"\n\n        elif isinstance(value, bytes):\n            log.debug(\"Loading Bytes from Bytes\")\n            return value\n\n        elif isinstance(value, str):\n            log.debug(\"Loading Bytes from String\")\n            return value.encode()\n\n        elif (path := BrokenPath(value).valid()):\n            log.debug(f\"Loading Bytes from Path ({path})\")\n            return path.read_bytes()\n\n        return None\n</code></pre>"},{"location":"broken/reference/loaders/loaderbytes/#Loaders.LoaderBytes.LoaderBytes.load","title":"<code>load(value: Any = None, **kwargs) -&gt; Optional[bytes]</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Loaders/LoaderBytes.py</code> Python<pre><code>@staticmethod\ndef load(value: Any=None, **kwargs) -&gt; Optional[bytes]:\n    if not value:\n        return b\"\"\n\n    elif isinstance(value, bytes):\n        log.debug(\"Loading Bytes from Bytes\")\n        return value\n\n    elif isinstance(value, str):\n        log.debug(\"Loading Bytes from String\")\n        return value.encode()\n\n    elif (path := BrokenPath(value).valid()):\n        log.debug(f\"Loading Bytes from Path ({path})\")\n        return path.read_bytes()\n\n    return None\n</code></pre>"},{"location":"broken/reference/loaders/loaderbytes/#Loaders.LoaderBytes.LoadableBytes","title":"<code>Loaders.LoaderBytes.LoadableBytes = Union[bytes, str, Path, None]</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/loaders/loaderimage/","title":"LoaderImage","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/loaders/loaderimage/#Loaders.LoaderImage","title":"<code>Loaders.LoaderImage</code>","text":""},{"location":"broken/reference/loaders/loaderimage/#Loaders.LoaderImage.LoaderImage","title":"<code>Loaders.LoaderImage.LoaderImage</code>","text":"Source code in <code>Broken/Loaders/LoaderImage.py</code> Python<pre><code>@define\nclass LoaderImage(BrokenLoader):\n    _cache = None\n\n    @staticmethod\n    def cache() -&gt; Any:\n        try:\n            import requests_cache\n            if not LoaderImage._cache:\n                LoaderImage._cache = requests_cache.CachedSession(\n                    Broken.BROKEN.DIRECTORIES.CACHE/\"LoaderImage.sqlite\",\n                )\n        except ImportError:\n            return None\n\n        return LoaderImage._cache\n\n    @staticmethod\n    def load(value: Any=None, **kwargs) -&gt; Optional[Image]:\n        if value is None:\n            return None\n\n        elif isinstance(value, Image):\n            log.debug(\"Loading already an Instance of Image\")\n            return value\n\n        elif value is Image:\n            log.debug(\"Loading already an Class of Image\")\n            return value\n\n        elif isinstance(value, numpy.ndarray):\n            log.debug(\"Loading Image from Numpy Array\")\n            return PIL.Image.fromarray(value, **kwargs)\n\n        elif (path := Path(value).expanduser().resolve()).exists():\n            log.debug(f\"Loading Image from Path ({path})\")\n            return PIL.Image.open(path, **kwargs)\n\n        elif validators.url(value):\n            log.debug(f\"Loading Image from URL ({value})\")\n            import requests\n            get = getattr(LoaderImage.cache(), \"get\", requests.get)\n            return PIL.Image.open(io.BytesIO(get(value).content), **kwargs)\n\n        elif isinstance(value, bytes):\n            log.debug(\"Loading Image from Bytes\")\n            return PIL.Image.open(io.BytesIO(value), **kwargs)\n\n        return None\n</code></pre>"},{"location":"broken/reference/loaders/loaderimage/#Loaders.LoaderImage.LoaderImage.cache","title":"<code>cache() -&gt; Any</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Loaders/LoaderImage.py</code> Python<pre><code>@staticmethod\ndef cache() -&gt; Any:\n    try:\n        import requests_cache\n        if not LoaderImage._cache:\n            LoaderImage._cache = requests_cache.CachedSession(\n                Broken.BROKEN.DIRECTORIES.CACHE/\"LoaderImage.sqlite\",\n            )\n    except ImportError:\n        return None\n\n    return LoaderImage._cache\n</code></pre>"},{"location":"broken/reference/loaders/loaderimage/#Loaders.LoaderImage.LoaderImage.load","title":"<code>load(value: Any = None, **kwargs) -&gt; Optional[Image]</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Loaders/LoaderImage.py</code> Python<pre><code>@staticmethod\ndef load(value: Any=None, **kwargs) -&gt; Optional[Image]:\n    if value is None:\n        return None\n\n    elif isinstance(value, Image):\n        log.debug(\"Loading already an Instance of Image\")\n        return value\n\n    elif value is Image:\n        log.debug(\"Loading already an Class of Image\")\n        return value\n\n    elif isinstance(value, numpy.ndarray):\n        log.debug(\"Loading Image from Numpy Array\")\n        return PIL.Image.fromarray(value, **kwargs)\n\n    elif (path := Path(value).expanduser().resolve()).exists():\n        log.debug(f\"Loading Image from Path ({path})\")\n        return PIL.Image.open(path, **kwargs)\n\n    elif validators.url(value):\n        log.debug(f\"Loading Image from URL ({value})\")\n        import requests\n        get = getattr(LoaderImage.cache(), \"get\", requests.get)\n        return PIL.Image.open(io.BytesIO(get(value).content), **kwargs)\n\n    elif isinstance(value, bytes):\n        log.debug(\"Loading Image from Bytes\")\n        return PIL.Image.open(io.BytesIO(value), **kwargs)\n\n    return None\n</code></pre>"},{"location":"broken/reference/loaders/loaderimage/#Loaders.LoaderImage.LoadableImage","title":"<code>Loaders.LoaderImage.LoadableImage = Union[Image, Path, URL, numpy.ndarray, bytes, None]</code>  <code>module-attribute</code>","text":""},{"location":"broken/reference/loaders/loaderstring/","title":"LoaderString","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"broken/reference/loaders/loaderstring/#Loaders.LoaderString","title":"<code>Loaders.LoaderString</code>","text":""},{"location":"broken/reference/loaders/loaderstring/#Loaders.LoaderString.LoaderString","title":"<code>Loaders.LoaderString.LoaderString</code>","text":"Source code in <code>Broken/Loaders/LoaderString.py</code> Python<pre><code>@define\nclass LoaderString(BrokenLoader):\n\n    @staticmethod\n    def load(value: Any=None, **kwargs) -&gt; Optional[str]:\n        if not value:\n            return \"\"\n\n        elif isinstance(value, str):\n            log.debug(f\"Loading String from String {value}\")\n            return value\n\n        elif isinstance(value, bytes):\n            log.debug(\"Loading String from Bytes\")\n            return value.decode(encoding=\"utf-8\")\n\n        elif (path := BrokenPath(value).valid()):\n            log.debug(f\"Loading String from Path ({path})\")\n            return path.read_text(encoding=\"utf-8\")\n\n        return None\n</code></pre>"},{"location":"broken/reference/loaders/loaderstring/#Loaders.LoaderString.LoaderString.load","title":"<code>load(value: Any = None, **kwargs) -&gt; Optional[str]</code>  <code>staticmethod</code>","text":"Source code in <code>Broken/Loaders/LoaderString.py</code> Python<pre><code>@staticmethod\ndef load(value: Any=None, **kwargs) -&gt; Optional[str]:\n    if not value:\n        return \"\"\n\n    elif isinstance(value, str):\n        log.debug(f\"Loading String from String {value}\")\n        return value\n\n    elif isinstance(value, bytes):\n        log.debug(\"Loading String from Bytes\")\n        return value.decode(encoding=\"utf-8\")\n\n    elif (path := BrokenPath(value).valid()):\n        log.debug(f\"Loading String from Path ({path})\")\n        return path.read_text(encoding=\"utf-8\")\n\n    return None\n</code></pre>"},{"location":"broken/reference/loaders/loaderstring/#Loaders.LoaderString.LoadableString","title":"<code>Loaders.LoaderString.LoadableString = Union[str, bytes, Path, None]</code>  <code>module-attribute</code>","text":""},{"location":"depthflow/","title":"Index","text":"<p>Important</p> <p><sub>This repository is part of a monorepo and shouldn't be cloned alone</sub></p> DepthFlow Image to \u2192 2.5D Parallax Effect Video. A Free and Open Source ImmersityAI Alternative    <p></p>"},{"location":"depthflow/#description","title":"\ud83d\udd25 Description","text":"<p>DepthFlow is a heavily customizable steep parallax shader for adding soul to your images.</p> <ul> <li>\ud83d\udee1\ufe0f Open Source, trust and transparency, cross platform, configurable</li> <li>\ud83d\ude80 Fast: heavily optimized shader, render at 8k50 with an RTX 3060</li> <li>\ud83c\udfa8 Post Processing: easy vignette, depth of field, lens distortion</li> <li>\u2699\ufe0f Flexible: multiple parameters to tweak and create movement</li> <li>\ud83c\udfa5 Presets: quality built-in extensively configurable animations <code>(soon)</code></li> <li>\ud83d\udcc8 Upscaler pipeline built-in, powered by RealESR <code>(optional)</code></li> <li>\u267b\ufe0f Seamless loops: perfect for backgrounds, wallpapers, fillers</li> <li>\ud83d\udcd4 Video Codecs: easily export to H264, HEVC, AV1, (+NVENC)</li> <li>\ud83d\udd31 High Quality, any resolution, framerate, bitrate, SSAA</li> <li>\u2b50\ufe0f Smooth borders: no artifacts, petite step size</li> <li>\ud83c\udfa8 No Watermarks, user first experience</li> <li>\ud83c\udf35 Fastest rendering times in the west</li> </ul> <p></p>"},{"location":"depthflow/#showcase","title":"\ud83d\udcf8 Showcase","text":"<p>\ud83d\udc47 Right click and loop me!</p> <p><sup>Note: Yes, the only input to DepthFlow was the Original Image</sup></p> \ud83c\udfa9 Click to see the Original Image  Source: Wallhaven. All images remain property of their original owners. \u2696\ufe0f    \ud83e\ude84 Click to see the Estimated Depth map     The Depth Map was estimated with DepthAnything \ud83d\ude80    <p> </p> \ud83c\udf41 Learn More \ud83c\udf41 \u2728 Check out my Awesome Website instead of a boring Readme \u2728 Installation Guides, Usage, Tips, Code Reference and More!"},{"location":"depthflow/get/","title":"\ud83c\udf0a DepthFlow","text":"<p>\ud83d\udea7 Better Documentation is Work in Progress \ud83d\udea7</p> <p>Unified Installation</p> <p>Follow the main Installation Guide, then continue from here</p>"},{"location":"depthflow/get/#running-depthflow","title":"Running DepthFlow","text":"<p>With PyTorch installed, simply run <code>depthflow</code>, a window will open</p> <ul> <li>Models will be Downloaded on the first run</li> </ul>"},{"location":"depthflow/get/#rendering-options","title":"Rendering Options","text":"<ul> <li>Run <code>depthflow --help</code> for all Options and Exporting to a Video File</li> </ul>"},{"location":"depthflow/get/#selecting-the-input-image","title":"Selecting the input image","text":"<ul> <li>Run <code>depthflow input --help</code>. The exported Video File Image is the one defined here</li> <li>Drag and drop an Image File or URL From your Browser to the Window in Realtime Mode</li> </ul> <p>Note: This resizes<sup>*1</sup> the Window to the image resolution, there's options:</p> <ul> <li>Only sending <code>--width</code> or <code>--height</code> adjusts the other to Aspect Ratio</li> <li>Sending Both will force the resolution (can also be set on <code>main -w -h</code>)</li> <li>Sending None will use the Image's resolution (default)</li> <li>Use <code>--scale</code> to post-multiply the new resolution</li> </ul> <p><sup>*1 The Resolution is limited by the <code>MONITOR=0</code> Flag (0=Primary), only on Realtime mode</sup></p>"},{"location":"depthflow/get/#animation-presets","title":"Animation Presets","text":"<p>There's currently no mechanism for presets, but it is planned</p> <ul> <li>For now, manually change the <code>.update()</code> function on <code>DepthFlow/DepthFlow.py</code></li> </ul>"},{"location":"depthflow/get/#full-examples","title":"Full Examples","text":"<ul> <li><code>depthflow main (--render | -r)</code></li> <li><code>depthflow main -r -f 30</code></li> <li><code>depthflow main -r -o ./video_name --format mkv</code></li> <li><code>depthflow input --image (url | path) main --render -s 2</code></li> <li><code>depthflow main -r -t 2 --open</code></li> <li><code>depthflow input -i (image) -d (depth) main</code></li> <li><code>depthflow input -i (image) -w 600 --scale 2 main -r</code></li> </ul> <p>Note: A high SSAA <code>-s 1.5</code> is recommended for antialiasing due the Steep Parallax</p>"},{"location":"depthflow/reference/animation/","title":"Animation","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"depthflow/reference/animation/#Animation","title":"<code>Animation</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target","title":"<code>Animation.Target</code>","text":"Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>class Target(BrokenEnum):\n    Height    = \"height\"\n    Static    = \"static\"\n    Focus     = \"focus\"\n    Zoom      = \"zoom\"\n    Isometric = \"isometric\"\n    Dolly     = \"dolly\"\n    Invert    = \"invert\"\n    Mirror    = \"mirror\"\n    CenterX   = \"center_x\"\n    CenterY   = \"center_y\"\n    OriginX   = \"origin_x\"\n    OriginY   = \"origin_y\"\n    OffsetX   = \"offset_x\"\n    OffsetY   = \"offset_y\"\n    Dof_Enable     = \"dof.enable\"\n    Dof_Start      = \"dof.start\"\n    Dof_End        = \"dof.end\"\n    Dof_Exponent   = \"dof.exponent\"\n    Dof_Intensity  = \"dof.intensity\"\n    Dof_Quality    = \"dof.quality\"\n    Dof_Directions = \"dof.directions\"\n    Vignette_Enable    = \"vignette.enable\"\n    Vignette_Intensity = \"vignette.intensity\"\n    Vignette_Decay     = \"vignette.decay\"\n</code></pre>"},{"location":"depthflow/reference/animation/#Animation.Target.Height","title":"<code>Height = 'height'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Static","title":"<code>Static = 'static'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Focus","title":"<code>Focus = 'focus'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Zoom","title":"<code>Zoom = 'zoom'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Isometric","title":"<code>Isometric = 'isometric'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Dolly","title":"<code>Dolly = 'dolly'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Invert","title":"<code>Invert = 'invert'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Mirror","title":"<code>Mirror = 'mirror'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.CenterX","title":"<code>CenterX = 'center_x'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.CenterY","title":"<code>CenterY = 'center_y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.OriginX","title":"<code>OriginX = 'origin_x'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.OriginY","title":"<code>OriginY = 'origin_y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.OffsetX","title":"<code>OffsetX = 'offset_x'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.OffsetY","title":"<code>OffsetY = 'offset_y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Dof_Enable","title":"<code>Dof_Enable = 'dof.enable'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Dof_Start","title":"<code>Dof_Start = 'dof.start'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Dof_End","title":"<code>Dof_End = 'dof.end'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Dof_Exponent","title":"<code>Dof_Exponent = 'dof.exponent'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Dof_Intensity","title":"<code>Dof_Intensity = 'dof.intensity'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Dof_Quality","title":"<code>Dof_Quality = 'dof.quality'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Dof_Directions","title":"<code>Dof_Directions = 'dof.directions'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Vignette_Enable","title":"<code>Vignette_Enable = 'vignette.enable'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Vignette_Intensity","title":"<code>Vignette_Intensity = 'vignette.intensity'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Target.Vignette_Decay","title":"<code>Vignette_Decay = 'vignette.decay'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.DepthAnimation","title":"<code>Animation.DepthAnimation</code>","text":"Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>class DepthAnimation(_DepthAnimation):\n    target: Annotated[Target, Option(\"-t\", \"--target\",\n        help=\"[bold][red](\ud83d\udd34 Common )[/red][/bold] Target animation component to modulate\")] = None\n\n    def set(self, scene: DepthScene, value: float) -&gt; None:\n        exec(f\"scene.state.{self.target.value} += {value}\")\n</code></pre>"},{"location":"depthflow/reference/animation/#Animation.DepthAnimation.target","title":"<code>target: Annotated[Target, Option('-t', '--target', help='[bold][red](\ud83d\udd34 Common )[/red][/bold] Target animation component to modulate')] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.DepthAnimation.set","title":"<code>set(scene: DepthScene, value: float) -&gt; None</code>","text":"Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>def set(self, scene: DepthScene, value: float) -&gt; None:\n    exec(f\"scene.state.{self.target.value} += {value}\")\n</code></pre>"},{"location":"depthflow/reference/animation/#Animation.DepthPreset","title":"<code>Animation.DepthPreset</code>","text":"Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>class DepthPreset(_DepthAnimation):\n    ...\n</code></pre>"},{"location":"depthflow/reference/animation/#Animation.Constant","title":"<code>Animation.Constant</code>","text":"<p>Add a Constant value to some component's animation         green[/green]</p> Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>class Constant(DepthAnimation):\n    \"\"\"Add a Constant value to some component's animation         [green](See 'constant --help' for options)[/green]\"\"\"\n    value: Annotated[float, typer.Option(\"-v\", \"--value\")] = Field(default=0.0)\n\n    def update(self, scene: DepthScene) -&gt; None:\n        self.set(scene, self.value)\n</code></pre>"},{"location":"depthflow/reference/animation/#Animation.Constant.value","title":"<code>value: Annotated[float, typer.Option('-v', '--value')] = Field(default=0.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Constant.update","title":"<code>update(scene: DepthScene) -&gt; None</code>","text":"Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>def update(self, scene: DepthScene) -&gt; None:\n    self.set(scene, self.value)\n</code></pre>"},{"location":"depthflow/reference/animation/#Animation.Linear","title":"<code>Animation.Linear</code>","text":"<p>Add a Linear interpolation to some component's animation   green[/green]</p> Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>class Linear(DepthAnimation):\n    \"\"\"Add a Linear interpolation to some component's animation   [green](See 'linear --help' for options)[/green]\"\"\"\n    t0: Annotated[float, typer.Option(\"-t0\",\n        help=\"[green](\ud83d\udfe2 Basic  )[/green] Normalized start time\")] = \\\n        Field(default=0.0, min=0, max=1)\n    t1: Annotated[float, typer.Option(\"-t1\",\n        help=\"[green](\ud83d\udfe2 Basic  )[/green] Normalized end time\")] = \\\n        Field(default=1.0, min=0, max=1)\n    y0: Annotated[float, typer.Option(\"-y0\",\n        help=\"[green](\ud83d\udfe2 Basic  )[/green] Value at t=t0\")] = \\\n        Field(default=0.0)\n    y1: Annotated[float, typer.Option(\"-y1\",\n        help=\"[green](\ud83d\udfe2 Basic  )[/green] Value at t=t1\")] = \\\n        Field(default=1.0)\n    clamp: Annotated[bool, typer.Option(\"-c\", \"--clamp\",\n        help=\"[green](\ud83d\udfe2 Basic  )[/green] Clamp parametric value to [0, 1]\")] = \\\n        Field(default=True)\n    exponent: Annotated[float, typer.Option(\"-e\", \"--exponent\",\n        help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Interpolation exponent\")] = \\\n        Field(default=1.0)\n\n    def update(self, scene: DepthScene) -&gt; None:\n        parametric = (scene.tau - self.t0)/(self.t1 - self.t0)\n        parametric = (clamp(parametric, 0, 1) if self.clamp else parametric)\n        parametric = math.pow(parametric, self.exponent)\n        self.set(scene, value=self.y0 + (self.y1 - self.y0)*parametric)\n</code></pre>"},{"location":"depthflow/reference/animation/#Animation.Linear.t0","title":"<code>t0: Annotated[float, typer.Option('-t0', help='[green](\ud83d\udfe2 Basic  )[/green] Normalized start time')] = Field(default=0.0, min=0, max=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Linear.t1","title":"<code>t1: Annotated[float, typer.Option('-t1', help='[green](\ud83d\udfe2 Basic  )[/green] Normalized end time')] = Field(default=1.0, min=0, max=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Linear.y0","title":"<code>y0: Annotated[float, typer.Option('-y0', help='[green](\ud83d\udfe2 Basic  )[/green] Value at t=t0')] = Field(default=0.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Linear.y1","title":"<code>y1: Annotated[float, typer.Option('-y1', help='[green](\ud83d\udfe2 Basic  )[/green] Value at t=t1')] = Field(default=1.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Linear.clamp","title":"<code>clamp: Annotated[bool, typer.Option('-c', '--clamp', help='[green](\ud83d\udfe2 Basic  )[/green] Clamp parametric value to [0, 1]')] = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Linear.exponent","title":"<code>exponent: Annotated[float, typer.Option('-e', '--exponent', help='[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Interpolation exponent')] = Field(default=1.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Linear.update","title":"<code>update(scene: DepthScene) -&gt; None</code>","text":"Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>def update(self, scene: DepthScene) -&gt; None:\n    parametric = (scene.tau - self.t0)/(self.t1 - self.t0)\n    parametric = (clamp(parametric, 0, 1) if self.clamp else parametric)\n    parametric = math.pow(parametric, self.exponent)\n    self.set(scene, value=self.y0 + (self.y1 - self.y0)*parametric)\n</code></pre>"},{"location":"depthflow/reference/animation/#Animation.Sine","title":"<code>Animation.Sine</code>","text":"<p>Add a Sine wave to some component's animation              green[/green]</p> Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>class Sine(DepthAnimation):\n    \"\"\"Add a Sine wave to some component's animation              [green](See 'sine --help' for options)[/green]\"\"\"\n    amplitude: Annotated[float, typer.Option(\"-a\", \"--amplitude\",\n        help=\"[green](\ud83d\udfe2 Basic  )[/green] Amplitude of the Sine wave\")] = \\\n        Field(default=1.0)\n\n    cycles: Annotated[float, typer.Option(\"-c\", \"--cycles\",\n        help=\"[green](\ud83d\udfe2 Basic  )[/green] Number of cycles until the end of the Scene\")] = \\\n        Field(default=1.0)\n\n    phi: Annotated[float, typer.Option(\"-p\", \"--phi\", min=-1, max=1,\n        help=\"[green](\ud83d\udfe2 Basic  )[/green] Phase offset of the wave (normalized)\")] = \\\n        Field(default=0.0)\n\n    bias: Annotated[float, typer.Option(\"-b\", \"--bias\",\n        help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Constant value added to the function\")] = \\\n        Field(default=0.0)\n\n    cosine: Annotated[bool, typer.Option(\"-C\", \"--cosine\",\n        help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Use a cosine instead of a sine (Adds PI/2)\")] = \\\n        Field(default=False)\n\n    def update(self, scene: DepthScene) -&gt; None:\n        trig = (math.cos if self.cosine else math.sin)\n        self.set(scene, value=self.amplitude*trig(scene.cycle + 2*math.pi*self.phi) + self.bias)\n</code></pre>"},{"location":"depthflow/reference/animation/#Animation.Sine.amplitude","title":"<code>amplitude: Annotated[float, typer.Option('-a', '--amplitude', help='[green](\ud83d\udfe2 Basic  )[/green] Amplitude of the Sine wave')] = Field(default=1.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Sine.cycles","title":"<code>cycles: Annotated[float, typer.Option('-c', '--cycles', help='[green](\ud83d\udfe2 Basic  )[/green] Number of cycles until the end of the Scene')] = Field(default=1.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Sine.phi","title":"<code>phi: Annotated[float, typer.Option('-p', '--phi', min=-1, max=1, help='[green](\ud83d\udfe2 Basic  )[/green] Phase offset of the wave (normalized)')] = Field(default=0.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Sine.bias","title":"<code>bias: Annotated[float, typer.Option('-b', '--bias', help='[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Constant value added to the function')] = Field(default=0.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Sine.cosine","title":"<code>cosine: Annotated[bool, typer.Option('-C', '--cosine', help='[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Use a cosine instead of a sine (Adds PI/2)')] = Field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/animation/#Animation.Sine.update","title":"<code>update(scene: DepthScene) -&gt; None</code>","text":"Source code in <code>Projects/DepthFlow/DepthFlow/Animation.py</code> Python<pre><code>def update(self, scene: DepthScene) -&gt; None:\n    trig = (math.cos if self.cosine else math.sin)\n    self.set(scene, value=self.amplitude*trig(scene.cycle + 2*math.pi*self.phi) + self.bias)\n</code></pre>"},{"location":"depthflow/reference/scene/","title":"Scene","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"depthflow/reference/scene/#Scene","title":"<code>Scene</code>","text":""},{"location":"depthflow/reference/scene/#Scene.WindowBackend","title":"<code>Scene.WindowBackend</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>class WindowBackend(BrokenEnum):\n    Headless = \"headless\"\n    GLFW     = \"glfw\"\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.WindowBackend.Headless","title":"<code>Headless = 'headless'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.WindowBackend.GLFW","title":"<code>GLFW = 'glfw'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene","title":"<code>Scene.ShaderScene</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>@define\nclass ShaderScene(ShaderModule):\n    __name__ = \"Scene\"\n\n    # # Base modules\n\n    modules: Deque[ShaderModule] = Factory(deque)\n    \"\"\"Deque of all Modules on the Scene, not a set for order preservation\"\"\"\n\n    # Scheduling\n    scheduler: BrokenScheduler = Factory(BrokenScheduler)\n    vsync: BrokenTask = None\n\n    # ShaderFlow modules\n    frametimer: ShaderFrametimer = None\n    keyboard: ShaderKeyboard = None\n    camera: ShaderCamera = None\n    ffmpeg: BrokenFFmpeg = None\n\n    # # Fractional SSAA\n\n    shader: ShaderObject = None\n    \"\"\"The main ShaderObject of the Scene, the visible content of the Window\"\"\"\n\n    _final: ShaderObject = None\n    \"\"\"Internal ShaderObject used for a Fractional Super-Sampling Anti-Aliasing (SSAA). This shader\n    samples the texture from the user's final self.shader, which is rendered at SSAA resolution\"\"\"\n\n    alpha: bool = False\n    \"\"\"Makes the final texture have an alpha channel, useful for transparent windows. Exporting\n    videos might fail, perhaps output a Chroma Key compatible video - add this to the shader:\n    - `fragColor.rgb = mix(vec3(0, 1, 0), fragColor.rgb, fragColor.a);`\"\"\"\n\n    quality: float = field(default=50, converter=lambda x: clamp(x, 0, 100))\n    \"\"\"Rendering Quality, if implemented - either on the GPU Shader or CPU Python side\"\"\"\n\n    typer: BrokenTyper = Factory(lambda: BrokenTyper(chain=True))\n    \"\"\"This Scene's BrokenTyper instance for the CLI. Commands are added by any module in the\n    `self.commands` method. The `self.main` is always added to it\"\"\"\n\n    def __post__(self):\n        self.typer.description = (self.typer.description or self.__class__.__doc__)\n        self.typer._panel = \"\ud83d\udd25 Scene commands\"\n        self.typer.command(self.main, context=True)\n        self.build()\n\n    def cli(self, *args: List[Union[Any, str]]):\n        \"\"\"Interpret a list of arguments as actions, defined by the Scene's `self.commands` plus\n        the `main` method. Must not start with `sys.executable`, so send `sys.argv[1:]` or direct\"\"\"\n        self.typer(flatten(args))\n\n    @OnceTracker.decorator\n    def build(self):\n        imgui.create_context()\n        self.imguio = imgui.get_io()\n        self.imguio.font_global_scale = 1\n        self.imguio.fonts.add_font_from_file_ttf(\n            str(Broken.BROKEN.RESOURCES.FONTS/\"DejaVuSans.ttf\"),\n            16*self.imguio.font_global_scale,\n        )\n\n        # Default modules\n        self.init_window()\n        self.frametimer = ShaderFrametimer(scene=self)\n        self.keyboard = ShaderKeyboard(scene=self)\n        self.camera = ShaderCamera(scene=self)\n\n        # Create the SSAA Workaround engines\n        self._final = ShaderObject(scene=self, name=\"iFinal\")\n        self._final.texture.components = 3 + int(self.alpha)\n        self._final.texture.dtype = \"f1\"\n        self._final.texture.final = True\n        self._final.texture.track = True\n        self._final.fragment = (SHADERFLOW.RESOURCES.FRAGMENT/\"Final.glsl\")\n        self.shader = ShaderObject(scene=self, name=\"iScreen\")\n        self.shader.texture.track = True\n        self.shader.texture.repeat(False)\n\n    # ---------------------------------------------------------------------------------------------|\n    # Temporal\n\n    time: Seconds = field(default=0.0, converter=float)\n    \"\"\"Current time in seconds. Ideally, everything should depend on time, for flexibility\"\"\"\n\n    tempo: float = Factory(lambda: DynamicNumber(value=1, frequency=3))\n    \"\"\"Time scale factor, used for `dt`, which integrates to `time`\"\"\"\n\n    runtime: Seconds = field(default=10.0, converter=float)\n    \"\"\"The longest module duration; overriden by the user; or default length of 10s\"\"\"\n\n    fps: Hertz = field(default=60.0, converter=lambda x: max(float(x), 1.0))\n    \"\"\"Target frames per second rendering speed\"\"\"\n\n    dt: Seconds = field(default=0.0, converter=float)\n    \"\"\"Virtual delta time since last frame, time scaled by `tempo`. Use `self.rdt` for real delta\"\"\"\n\n    rdt: Seconds = field(default=0.0, converter=float)\n    \"\"\"Real life, physical delta time since last frame. Use `self.dt` for time scaled version\"\"\"\n\n    @property\n    def tau(self) -&gt; float:\n        \"\"\"Normalized time value relative to runtime between 0 and 1\"\"\"\n        return (self.time / self.runtime)\n\n    @property\n    def cycle(self) -&gt; float:\n        \"\"\"A number from 0 to 2pi that ends on the runtime ('normalized angular time')\"\"\"\n        return (2 * math.pi * self.tau)\n\n    @property\n    def frametime(self) -&gt; Seconds:\n        \"\"\"Ideal time between two frames. This value is coupled with `fps`\"\"\"\n        return (1 / self.fps)\n\n    @frametime.setter\n    def frametime(self, value: Seconds):\n        self.fps = (1 / value)\n\n    @property\n    def frame(self) -&gt; int:\n        \"\"\"Current frame being rendered. This value is coupled with 'time' and 'fps'\"\"\"\n        return round(self.time * self.fps)\n\n    @frame.setter\n    def frame(self, value: int):\n        self.time = (value / self.fps)\n\n    # Total Duration\n\n    @property\n    def duration(self) -&gt; Seconds:\n        \"\"\"Alias to self.runtime. Set both with `.set_duration()`\"\"\"\n        return self.runtime\n\n    def set_duration(self, override: Seconds=None, *, minimum: Seconds=10) -&gt; Seconds:\n        \"\"\"Either force the runtime to be 'override' or find the longest module lower bounded\"\"\"\n        self.runtime = (override or minimum)\n        for module in (not bool(override)) * self.modules:\n            self.runtime = max(self.runtime, module.duration)\n        self.runtime /= self.tempo.value\n        return self.runtime\n\n    @property\n    def total_frames(self) -&gt; int:\n        \"\"\"The total frames this scene should render when exporting, if 'runtime' isn't changed\"\"\"\n        return round(self.runtime * self.fps)\n\n    # ---------------------------------------------------------------------------------------------|\n    # Window synchronized properties\n\n    # # Title\n\n    _title: str = \"ShaderFlow\"\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Realtime window 'title' property\"\"\"\n        return self._title\n\n    @title.setter\n    def title(self, value: str):\n        log.debug(f\"{self.who} Changing Window Title to ({value})\")\n        self.window.title = value\n        self._title = value\n\n    # # Resizable\n\n    _resizable: bool = True\n\n    @property\n    def resizable(self) -&gt; bool:\n        \"\"\"Realtime window 'is resizable' property\"\"\"\n        return self._resizable\n\n    @resizable.setter\n    def resizable(self, value: bool):\n        log.debug(f\"{self.who} Changing Window Resizable to ({value})\")\n        self.window.resizable = value\n        self._resizable = value\n\n    # # Visible\n\n    _visible: bool = False\n\n    @property\n    def visible(self) -&gt; bool:\n        \"\"\"Realtime window 'is visible' property\"\"\"\n        return self._visible\n\n    @visible.setter\n    def visible(self, value: bool):\n        log.debug(f\"{self.who} Changing Window Visibility to ({value})\")\n        self.window.visible = value\n        self._visible = value\n\n    # # Window Fullscreen\n\n    _fullscreen: bool = False\n\n    @property\n    def fullscreen(self) -&gt; bool:\n        \"\"\"Window 'is fullscreen' property\"\"\"\n        return self._fullscreen\n\n    @fullscreen.setter\n    def fullscreen(self, value: bool):\n        log.debug(f\"{self.who} Changing Window Fullscreen to ({value})\")\n        self._fullscreen = value\n        try:\n            self.window.fullscreen = value\n        except AttributeError:\n            pass\n\n    # # Window Exclusive\n\n    _exclusive: bool = False\n\n    @property\n    def exclusive(self) -&gt; bool:\n        \"\"\"Window 'mouse exclusivity' property: Is the mouse cursor be locked to the window\"\"\"\n        return self._exclusive\n\n    @exclusive.setter\n    def exclusive(self, value: bool):\n        log.debug(f\"{self.who} Changing Window Exclusive to ({value})\")\n        self.window.mouse_exclusivity = value\n        self._exclusive = value\n\n    # # Video modes and monitor\n\n    monitor: int = os.getenv(\"MONITOR\", 0)\n\n    @property\n    def glfw_monitor(self) -&gt; Optional[glfw._GLFWmonitor]:\n        if (monitors := glfw.get_monitors()):\n            return monitors[self.monitor]\n\n    @property\n    def glfw_video_mode(self) -&gt; Optional[Dict]:\n        if (monitor := self.glfw_monitor):\n            return glfw.get_video_mode(monitor)\n\n    @property\n    def monitor_framerate(self) -&gt; float:\n        \"\"\"Note: Defaults to 60 if no monitor is found\"\"\"\n        if (mode := self.glfw_video_mode):\n            return mode.refresh_rate or 60.0\n        return 60.0\n\n    @property\n    def monitor_size(self) -&gt; Optional[Tuple[int, int]]:\n        if self.exporting:\n            return None\n        if (mode := self.glfw_video_mode):\n            return (mode.size.width, mode.size.height)\n\n    @property\n    def monitor_width(self) -&gt; Optional[int]:\n        if (resolution := self.monitor_size):\n            return resolution[0]\n\n    @property\n    def monitor_height(self) -&gt; Optional[int]:\n        if (resolution := self.monitor_size):\n            return resolution[1]\n\n    # ---------------------------------------------------------------------------------------------|\n    # Resolution\n\n    # # Scale\n\n    _scale: float = field(default=1.0, converter=lambda x: max(0.01, x))\n\n    @property\n    def scale(self) -&gt; float:\n        \"\"\"Resolution scale factor, the `self.width` and `self.height` are multiplied by this\"\"\"\n        return self._scale\n\n    @scale.setter\n    def scale(self, value: float):\n        log.debug(f\"{self.who} Changing Resolution Scale to ({value})\")\n        self.resize(scale=value)\n\n    # # Width\n\n    _width: int = field(default=1920, converter=lambda x: int(max(1, x)))\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Rendering width (horizontal size) of the Scene in pixels\"\"\"\n        return round(self._width * self._scale)\n\n    @width.setter\n    def width(self, value: int):\n        self.resize(width=value)\n\n    # # Height\n\n    _height: int = field(default=1080, converter=lambda x: int(max(1, x)))\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"Rendering height (vertical size) of the Scene in pixels\"\"\"\n        return round(self._height * self._scale)\n\n    @height.setter\n    def height(self, value: int):\n        self.resize(height=value)\n\n    # # SSAA\n\n    _ssaa: float = field(default=1.0,  converter=lambda x: max(0.01, x))\n\n    @property\n    def ssaa(self) -&gt; float:\n        \"\"\"Fractional Super Sampling Anti-Aliasing (SSAA) factor. Improves the image quality (&gt;1) by\n        rendering at a higher resolution and then downsampling, resulting in smoother edges at a\n        significant GPU computational cost of O(N^2). Values lower than 1 (yield worse quality, but)\n        are useful when the GPU can't keep up: when the resolution is too high or FPS is too low\"\"\"\n        return self._ssaa\n\n    @ssaa.setter\n    def ssaa(self, value: float):\n        log.debug(f\"{self.who} Changing Fractional SSAA to {value}\")\n        self._ssaa = value\n        self.relay(ShaderMessage.Shader.RecreateTextures)\n\n    # # Resolution (With, Height)\n\n    @property\n    def resolution(self) -&gt; Tuple[int, int]:\n        \"\"\"The resolution the Scene is rendering in pixels\"\"\"\n        return (self.width, self.height)\n\n    @resolution.setter\n    def resolution(self, value: Tuple[int, int]):\n        self.resize(*value)\n\n    @property\n    def render_resolution(self) -&gt; Tuple[int, int]:\n        \"\"\"Internal 'true' rendering resolution for SSAA. Same as `self.resolution*self.ssaa`\"\"\"\n        return (round(self.width*self.ssaa), round(self.height*self.ssaa))\n\n    # # Aspect Ratio\n\n    _aspect_ratio: float = None\n\n    @property\n    def aspect_ratio(self) -&gt; float:\n        \"\"\"Either the forced `self._aspect_ratio` or dynamic from `self.width/self.height`. When set\n        and resizing, the logic of `BrokenResolution.fit` is applied to enforce ratios\"\"\"\n        return self._aspect_ratio or (self._width/self._height)\n\n    @aspect_ratio.setter\n    def aspect_ratio(self, value: Union[float, str]):\n        log.debug(f\"{self.who} Changing Aspect Ratio to {value}\")\n\n        # The aspect ratio can be sent as a fraction or \"none\", \"false\"\n        if isinstance(value, str):\n            value = eval(value.replace(\":\", \"/\").capitalize())\n\n        # Optimization: Only change if different\n        if (self._aspect_ratio == value):\n            return\n\n        self._aspect_ratio = value\n\n        if (self.backend == WindowBackend.GLFW):\n            num, den = limited_integer_ratio(self._aspect_ratio, limit=2**20) or (glfw.DONT_CARE, glfw.DONT_CARE)\n            glfw.set_window_aspect_ratio(self.window._window, num, den)\n\n    def resize(self,\n        width: Union[int, float]=Unchanged,\n        height: Union[int, float]=Unchanged,\n        *,\n        aspect_ratio: Union[Unchanged, float, str]=Unchanged,\n        scale: float=Unchanged\n    ) -&gt; Tuple[int, int]:\n        \"\"\"\n        Resize the true final rendering resolution of the Scene. Rounded to nearest multiple of 2,\n        so FFmpeg is happy, and limited by the monitor resolution if realtime\n\n        Args:\n            width:  New width of the Scene, None to not change\n            height: New height of the Scene, None to not change\n\n        Returns:\n            Self: Fluent interface\n        \"\"\"\n\n        # Maybe update auxiliary properties\n        self.aspect_ratio = (aspect_ratio or self._aspect_ratio)\n        self._scale = (scale or self._scale)\n\n        # The parameters aren't trivial. The idea is to fit resolution from the scale-less components,\n        # so scaling isn't carried over, then to apply scaling (self.resolution)\n        resolution = BrokenResolution.fit(\n            old=(self._width, self._height),\n            new=(width, height),\n            max=(self.monitor_size),\n            ar=self._aspect_ratio\n        )\n\n        # Optimization: Only resize when resolution changes\n        if (resolution != (self.width, self.height)):\n            self._width, self._height = resolution\n            self.window.size = self.resolution\n            self.relay(ShaderMessage.Shader.RecreateTextures)\n            log.info(f\"{self.who} Resized Window to {self.resolution}\")\n\n        return self.resolution\n\n    # ---------------------------------------------------------------------------------------------|\n    # Window, OpenGL, Backend\n\n    backend: WindowBackend = WindowBackend.get(os.getenv(\"WINDOW_BACKEND\", WindowBackend.GLFW))\n    \"\"\"The ModernGL Window Backend. **Cannot be changed after creation**. Can also be set with the\n    environment variable `WINDOW_BACKEND=&lt;backend&gt;`, where `backend = {glfw, headless}`\"\"\"\n\n    opengl: moderngl.Context = None\n    \"\"\"ModernGL Context of this Scene. The thread accessing this MUST own or ENTER its context for\n    creating, changing, deleting objects; more often than not, it's the Main thread\"\"\"\n\n    window: ModernglWindow = None\n    \"\"\"ModernGL Window instance at `site-packages/moderngl_window.context.&lt;self.backend&gt;.Window`\"\"\"\n\n    imgui: ModernglImgui = None\n    \"\"\"ModernGL Imgui integration class bound to the Window\"\"\"\n\n    imguio: Any = None\n    \"\"\"Imgui IO object\"\"\"\n\n    def init_window(self) -&gt; None:\n        \"\"\"Create the window and the OpenGL context\"\"\"\n        if self.window:\n            raise RuntimeError(\"Window backend cannot be changed after creation\")\n\n        # Use EGL for creating a OpenGL context, allows true headless with GPU acceleration\n        # Comments 2 and 6: (https://forums.developer.nvidia.com/t/81412)\n        # Note: For the cloud, see (https://brokensrc.dev/get/docker/)\n        backend = \"egl\" if (os.getenv(\"WINDOW_EGL\", \"1\") == \"1\") else None\n\n        # Dynamically import the ModernGL Window Backend and instantiate it. Vsync is on our side \ud83d\ude09\n        module = f\"moderngl_window.context.{denum(self.backend).lower()}\"\n        self.window = importlib.import_module(module).Window(\n            size=self.resolution,\n            title=self.title,\n            resizable=self.resizable,\n            visible=self.visible,\n            fullscreen=self.fullscreen,\n            vsync=False,\n            backend=backend\n        )\n        ShaderKeyboard.set_keymap(self.window.keys)\n        self.imgui  = ModernglImgui(self.window)\n        self.opengl = self.window.ctx\n\n        # Bind window events to relay\n        self.window.resize_func               = self.__window_resize__\n        self.window.close_func                = self.__window_close__\n        self.window.iconify_func              = self.__window_iconify__\n        self.window.key_event_func            = self.__window_key_event__\n        self.window.mouse_position_event_func = self.__window_mouse_position_event__\n        self.window.mouse_press_event_func    = self.__window_mouse_press_event__\n        self.window.mouse_release_event_func  = self.__window_mouse_release_event__\n        self.window.mouse_drag_event_func     = self.__window_mouse_drag_event__\n        self.window.mouse_scroll_event_func   = self.__window_mouse_scroll_event__\n        self.window.unicode_char_entered_func = self.__window_unicode_char_entered__\n        self.window.files_dropped_event_func  = self.__window_files_dropped_event__\n\n        if (self.backend == WindowBackend.GLFW):\n            BrokenThread.new(target=self.window.set_icon, icon_path=Broken.PROJECT.RESOURCES.ICON, daemon=True)\n            glfw.set_cursor_enter_callback(self.window._window, lambda _, enter: self.__window_mouse_enter_event__(inside=enter))\n            glfw.set_drop_callback(self.window._window, self.__window_files_dropped_event__)\n            ShaderKeyboard.Keys.LEFT_SHIFT = glfw.KEY_LEFT_SHIFT\n            ShaderKeyboard.Keys.LEFT_CTRL  = glfw.KEY_LEFT_CONTROL\n            ShaderKeyboard.Keys.LEFT_ALT   = glfw.KEY_LEFT_ALT\n\n        log.info(f\"OpenGL Renderer: {self.opengl.info['GL_RENDERER']}\")\n\n    def read_screen(self) -&gt; bytes:\n        \"\"\"Take a screenshot of the screen and return raw bytes. Length `width*height*components`\"\"\"\n        return self.window.fbo.read(viewport=(0, 0, self.width, self.height))\n\n    # ---------------------------------------------------------------------------------------------|\n    # User actions\n\n    @property\n    def directory(self) -&gt; Path:\n        \"\"\"Path of the current Scene file Python script. This works by searching up the call stack\n        for the first context whose filename isn't the local __file__ (of ShaderFlow.Scene)\"\"\"\n        # Idea: Maybe `type(self).mro()[0]` could help\n        for frame in inspect.stack():\n            if (frame.filename != __file__):\n                return Path(frame.filename).parent\n\n    def read_file(self, file: Path, bytes: bool=False) -&gt; Union[str, bytes]:\n        \"\"\"\n        Read a file relative to the current Scene Python script\n\n        Args:\n            file:  File to read, relative to the current Scene script directory\n            bytes: Whether to read the file as bytes, defaults to text\n\n        Returns:\n            File contents as text or bytes\n        \"\"\"\n        file = (self.directory/file)\n        log.info(f\"{self.who} Reading file ({file})\")\n        return LoaderBytes(file) if bytes else LoaderString(file)\n\n    # ---------------------------------------------------------------------------------------------|\n    # Main event loop\n\n    quit: PlainTracker = Factory(lambda: PlainTracker(False))\n    \"\"\"Should the scene end the main event loop? Use as `if scene.quit():`\"\"\"\n\n    def next(self, dt: float) -&gt; Self:\n        \"\"\"Integrate time, update all modules and render the next frame\"\"\"\n\n        # Fixme: Windows: https://github.com/glfw/glfw/pull/1426\n        # Immediately swap the buffer with previous frame for vsync\n        self.window.swap_buffers()\n\n        # Temporal logic\n        dt = min(dt, 1)\n        self.tempo.next(dt=abs(dt))\n        self.vsync.fps = self.fps\n        self.dt    = dt * self.tempo\n        self.rdt   = dt\n        self.time += self.dt\n\n        # Note: Updates in reverse order of addition (child -&gt; parent)\n        # Note: Update non-engine first, as the pipeline might change\n        for module in self.modules:\n            if not isinstance(module, ShaderObject):\n                module.update()\n        for module in reversed(self.modules):\n            if isinstance(module, ShaderObject):\n                module.update()\n\n        self._render_ui()\n        return self\n\n    exporting: bool = True\n    \"\"\"Is this Scene exporting to a video file?\"\"\"\n\n    rendering: bool = False\n    \"\"\"Either Exporting, Rendering or Benchmarking. 'Not Realtime' mode\"\"\"\n\n    realtime: bool = False\n    \"\"\"Running with a window and user interaction\"\"\"\n\n    headless: bool = False\n    \"\"\"Running Headlessly, without a window and user interaction\"\"\"\n\n    benchmark: bool = False\n    \"\"\"Stress test the rendering speed of the Scene\"\"\"\n\n    repeat: int = field(default=1, converter=int)\n    \"\"\"Number of times to loop the exported video. One '1' is no repeat, two '2' doubles the length.\n    Ideally have seamless transitions on the shader based on self.tau and/or/no audio input\"\"\"\n\n    # Batch exporting\n\n    export_batch: Iterable[int] = field(factory=lambda: [0], converter=lambda x: list(x) or [0])\n    \"\"\"Batch indices iterable to export\"\"\"\n\n    export_index: int = 0\n    \"\"\"Current Batch exporting video index\"\"\"\n\n    export_format: str = field(default=\"mp4\", converter=lambda x: str(denum(x)))\n    \"\"\"The last (or only) video export format (extension) to use\"\"\"\n\n    export_base: Path = field(default=Broken.PROJECT.DIRECTORIES.DATA, converter=lambda x: Path(x))\n    \"\"\"The last (or only) video export base directory. Videos should render to ($base/$name) if $name\n    is plain, that is, the path isn't absolute\"\"\"\n\n    @abstractmethod\n    def export_name(self, path: Path) -&gt; Path:\n        \"\"\"Change the video file name being exported based on the current batch index. By default,\n        the name is unchanged in single export, else the stem is appended with the batch index\"\"\"\n        if (len(self.export_batch) &gt; 1):\n            return path.with_stem(f\"{path.stem}_{self.export_index}\")\n        return path\n\n    def main(self,\n        width:      Annotated[int,   Option(\"--width\",      \"-w\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Width  of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1920 on init)[/dim]\")]=None,\n        height:     Annotated[int,   Option(\"--height\",     \"-h\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Height of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1080 on init)[/dim]\")]=None,\n        scale:      Annotated[float, Option(\"--scale\",      \"-x\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Post-multiply width and height by a scale factor [medium_purple3](None to keep)[/medium_purple3] [dim](1.0 on init)[dim]\")]=None,\n        aspect:     Annotated[str,   Option(\"--ar\",         \"-R\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Force resolution aspect ratio [green](Examples: '16:9', '16/9', '1.777')[/green] [medium_purple3](None for dynamic)[/medium_purple3]\")]=None,\n        fps:        Annotated[float, Option(\"--fps\",        \"-f\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Target frames per second [medium_purple3](Defaults to the monitor framerate on realtime else 60)[/medium_purple3]\")]=None,\n        fullscreen: Annotated[bool,  Option(\"--fullscreen\",       help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in fullscreen mode [medium_purple3](Toggle with F11)[/medium_purple3]\")]=False,\n        maximize:   Annotated[bool,  Option(\"--maximize\",   \"-M\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in maximized mode\")]=False,\n        quality:    Annotated[float, Option(\"--quality\",    \"-q\", help=\"[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Shader quality level [green](0-100%)[/green] [yellow](If supported by the shader)[/yellow] [medium_purple3](None to keep, default 50%)[/medium_purple3]\")]=None,\n        ssaa:       Annotated[float, Option(\"--ssaa\",       \"-s\", help=\"[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Fractional super sampling anti aliasing factor [yellow](O(N^2) GPU cost)[/yellow] [medium_purple3](None to keep, default 1.0)[/medium_purple3]\")]=None,\n        render:     Annotated[bool,  Option(\"--render\",     \"-r\", help=\"[green](\ud83d\udfe2 Export )[/green] Export the Scene to a video file [medium_purple3](defined on --output, and implicit if so)[/medium_purple3]\")]=False,\n        output:     Annotated[str,   Option(\"--output\",     \"-o\", help=\"[green](\ud83d\udfe2 Export )[/green] Output file name [green]('Absolute', 'Relative path', 'Plain Name')[/green] [dim]($base/$(plain_name or $scene-$date))[/dim]\")]=None,\n        time:       Annotated[float, Option(\"--time\",       \"-t\", help=\"[green](\ud83d\udfe2 Export )[/green] The duration of exported videos [dim](Loop duration)[/dim] [medium_purple3](defaults to 10 or longest module's duration)[/medium_purple3]\")]=None,\n        tempo:      Annotated[float, Option(\"--tempo\",      \"-T\", help=\"[green](\ud83d\udfe2 Export )[/green] Set the time speed factor of the Scene [yellow](Final duration is stretched by [italic]1/tempo[/italic])[/yellow] [dim](1 on init)[/dim]\")]=None,\n        repeat:     Annotated[int,   Option(\"--repeat\",           help=\"[green](\ud83d\udfe2 Export )[/green] Number of exported videos loop copies [yellow](Final duration is stretched by [italic]repeat[/italic])[/yellow] [dim](1 on init)[/dim]\")]=None,\n        format:     Annotated[str,   Option(\"--format\",     \"-F\", help=\"[green](\ud83d\udfe2 Export )[/green] Output video container [green]('mp4', 'mkv', 'webm', 'avi, '...')[/green] [yellow](Overrides --output one)[/yellow]\")]=\"mp4\",\n        base:       Annotated[Path,  Option(\"--base\",       \"-D\", help=\"[green](\ud83d\udfe2 Export )[/green] Output file base directory\")]=Broken.PROJECT.DIRECTORIES.DATA,\n        vcodec:     Annotated[str,   Option(\"--vcodec\",     \"-c\", help=\"[green](\ud83d\udfe2 Export )[/green] Video codec [green]('h264', 'h264-nvenc', 'h265, 'hevc-nvenc', 'vp9', 'av1-{aom,svt,nvenc,rav1e}')[/green]\")]=\"h264\",\n        acodec:     Annotated[str,   Option(\"--acodec\",     \"-a\", help=\"[green](\ud83d\udfe2 Export )[/green] Audio codec [green]('aac', 'mp3', 'flac', 'wav', 'opus', 'ogg', 'copy', 'none', 'empty')[/green]\")]=\"copy\",\n        batch:      Annotated[str,   Option(\"--batch\",      \"-b\", help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] [dim][WIP] Hyphenated indices range to export multiple videos, if implemented. (1,5-7,10)[/dim]\")]=\"0\",\n        benchmark:  Annotated[bool,  Option(\"--benchmark\",  \"-B\", help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Benchmark the Scene's speed on raw rendering [medium_purple3](Use SKIP_GPU=1 for CPU only benchmark)[/medium_purple3]\")]=False,\n        raw:        Annotated[bool,  Option(\"--raw\",              help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Send raw OpenGL frames before GPU SSAA to FFmpeg [medium_purple3](Enabled if SSAA &lt; 1)[/medium_purple3] [dim](CPU Downsampling)[/dim]\")]=False,\n        open:       Annotated[bool,  Option(\"--open\",             help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Open the directory of video exports after all rendering finishes\")]=False,\n    ) -&gt; Optional[List[Path]]:\n        \"\"\"\n        Main event loop of this ShaderFlow Scene. Start a realtime window, exports to video, stress test speeds\n\n        \u2022 Note: For advanced video or audio codec configuration, modify it on 'self.ffmpeg' maybe inheriting this base class\n        \"\"\"\n        outputs: List[Path] = []\n\n        from arrow import now as arrow_now\n        export_started = arrow_now().format(\"YYYY-MM-DD HH-mm-ss\")\n\n        # Maybe update indices of exporting videos\n        self.export_batch  = hyphen_range(batch) or self.export_batch\n        self.export_format = format\n        self.export_base   = base\n\n        for index in self.export_batch:\n            self.export_index = index\n            self.exporting  = (render or bool(output))\n            self.rendering  = (self.exporting or benchmark)\n            self.realtime   = (not self.rendering)\n            self.benchmark  = benchmark\n            self.headless   = (self.rendering)\n            self.fps        = (fps or self.monitor_framerate)\n            self.title      = f\"ShaderFlow | {self.__name__}\"\n            self.quality    = quality or self.quality\n            self.repeat     = repeat or self.repeat\n            self.ssaa       = ssaa or self.ssaa\n            self.fullscreen = fullscreen\n            self.time       = 0\n            self.tempo.set(tempo or self.tempo.value)\n\n            for module in self.modules:\n                module.setup()\n\n            self.relay(ShaderMessage.Shader.Compile)\n            self.set_duration(time)\n\n            # Maybe keep or force aspect ratio, and find best resolution\n            width, height = self.resize(width=width, height=height, scale=scale, aspect_ratio=aspect)\n\n            # Optimization: Save bandwidth by piping native frames on ssaa &lt; 1\n            if self.rendering and (raw or self.ssaa &lt; 1):\n                self.resolution = self.render_resolution\n                self.ssaa = 1\n\n            # Configure FFmpeg and Popen it\n            if (self.rendering):\n                export = Path(output or f\"({export_started}) {self.__name__}\")\n                export = export if export.is_absolute() else (self.export_base/export)\n                export = export.with_suffix(\".\" + (self.export_format or export.suffix).replace(\".\", \"\"))\n                export = self.export_name(export)\n\n                self.ffmpeg = (BrokenFFmpeg(time=self.runtime).quiet()\n                    .pipe_input(pixel_format=(\"rgba\" if self.alpha else \"rgb24\"),\n                        width=self.width, height=self.height, framerate=self.fps)\n                    .scale(width=width, height=height)\n                    .output(path=export)\n                )\n\n                # Apply default good codec options on the video\n                self.ffmpeg.apply_vcodec_str(vcodec)\n                self.ffmpeg.apply_acodec_str(acodec)\n\n                for module in self.modules:\n                    if module is self: continue\n                    module.ffmpeg(self.ffmpeg)\n\n                if self.exporting:\n                    buffer = self.opengl.buffer(reserve=self._final.texture.size_t)\n                    self.ffmpeg = self.ffmpeg.popen(stdin=PIPE)\n\n                # Status tracker\n                status = DotMap(\n                    start=perf_counter(),\n                    bar=tqdm.tqdm(\n                        total=self.total_frames,\n                        desc=f\"Scene #{self.export_index} ({type(self).__name__}) \u2192 Video\",\n                        dynamic_ncols=True,\n                        colour=\"#43BFEF\",\n                        leave=False,\n                        unit=\" frames\",\n                        mininterval=1/30,\n                        maxinterval=0.1,\n                        smoothing=0.1,\n                    )\n                )\n\n            # Some scenes might take a while to setup\n            self.visible = not self.headless\n\n            if (self.backend == WindowBackend.GLFW and maximize):\n                glfw.maximize_window(self.window._window)\n\n            # Add self.next to the event loop\n            self.vsync = self.scheduler.new(\n                task=self.next,\n                frequency=self.fps,\n                freewheel=self.rendering,\n                precise=True,\n            )\n\n            # Main rendering loop\n            while (self.rendering) or (not self.quit()):\n                task = self.scheduler.next()\n\n                # Only continue if exporting\n                if (task.output is not self):\n                    continue\n                if self.realtime:\n                    continue\n                status.bar.update(1)\n\n                # Write a new frame to FFmpeg\n                if self.exporting:\n                    self._final.texture.fbo().read_into(buffer)\n                    turbopipe.pipe(buffer, self.ffmpeg.stdin.fileno())\n\n                # Finish exporting condition\n                if (status.bar.n &lt; self.total_frames):\n                    continue\n                status.bar.close()\n\n                if self.exporting:\n                    log.info(\"Waiting for FFmpeg process to finish (Queued writes, codecs lookahead, buffers, etc)\")\n                    turbopipe.close()\n                    self.ffmpeg.stdin.close()\n                    outputs.append(export)\n\n                # Repeat the video N times\n                if (self.repeat &gt; 1):\n                    log.info(f\"Repeating video ({self.repeat-1} times)\")\n                    export.rename(temporary := export.with_stem(f\"{export.stem}-repeat\"))\n                    (BrokenFFmpeg(stream_loop=(self.repeat-1)).quiet().copy_audio().copy_video()\n                        .input(temporary).output(export, pixel_format=None).run())\n                    temporary.unlink()\n\n                # Log stats\n                status.took = (perf_counter() - status.start)\n                log.info(f\"Finished rendering ({export})\", echo=not self.benchmark)\n                log.info((\n                    f\"\u2022 Stats: \"\n                    f\"(Took {status.took:.2f} s) at \"\n                    f\"({self.frame/status.took:.2f} FPS | \"\n                    f\"{self.runtime/status.took:.2f} x Realtime) with \"\n                    f\"({status.bar.n} Total Frames)\"\n                ))\n\n                if self.benchmark:\n                    return None\n                break\n\n        BrokenPath.open_in_file_explorer(outputs[0].parent) if open else None\n        return outputs\n\n    # ---------------------------------------------------------------------------------------------|\n    # Module\n\n    def handle(self, message: ShaderMessage) -&gt; None:\n\n        if isinstance(message, ShaderMessage.Window.Close):\n            log.info(f\"{self.who} Received Window Close Event\")\n            self.quit(True)\n\n        elif isinstance(message, ShaderMessage.Keyboard.KeyDown):\n            if message.key == ShaderKeyboard.Keys.O:\n                log.info(f\"{self.who} (O  ) Resetting the Scene\")\n                for module in self.modules:\n                    module.setup()\n                self.time = 0\n\n            elif message.key == ShaderKeyboard.Keys.R:\n                log.info(f\"{self.who} (R  ) Reloading Shaders\")\n                for module in self.modules:\n                    if isinstance(module, ShaderObject):\n                        module.compile()\n\n            elif message.key == ShaderKeyboard.Keys.TAB:\n                log.info(f\"{self.who} (TAB) Toggling Menu\")\n                self.render_ui = not self.render_ui\n\n            elif message.key == ShaderKeyboard.Keys.F1:\n                log.info(f\"{self.who} (F1 ) Toggling Exclusive Mode\")\n                self.exclusive = not self.exclusive\n\n            elif message.key == ShaderKeyboard.Keys.F2:\n                import arrow\n                time  = arrow.now().format(\"YYYY-MM-DD_HH-mm-ss\")\n                image = PIL.Image.frombytes(\"RGB\", self.resolution, self.read_screen())\n                image = image.transpose(PIL.Image.FLIP_TOP_BOTTOM)\n                path  = Broken.PROJECT.DIRECTORIES.SCREENSHOTS/f\"({time}) {self.__name__}.png\"\n                log.minor(f\"{self.who} (F2 ) Saving Screenshot to ({path})\")\n                BrokenThread.new(target=image.save, fp=path)\n\n            elif message.key == ShaderKeyboard.Keys.F11:\n                log.info(f\"{self.who} (F11) Toggling Fullscreen\")\n                self.fullscreen = not self.fullscreen\n\n        elif isinstance(message, (ShaderMessage.Mouse.Drag, ShaderMessage.Mouse.Position)):\n            self.mouse_gluv = (message.u, message.v)\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        yield ShaderVariable(\"uniform\", \"float\", \"iTime\",        self.time)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDuration\",    self.duration)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDeltaTime\",   self.dt)\n        yield ShaderVariable(\"uniform\", \"vec2\",  \"iResolution\",  self.resolution)\n        yield ShaderVariable(\"uniform\", \"float\", \"iWantAspect\",  self.aspect_ratio)\n        yield ShaderVariable(\"uniform\", \"float\", \"iQuality\",     self.quality/100)\n        yield ShaderVariable(\"uniform\", \"float\", \"iSSAA\",        self.ssaa)\n        yield ShaderVariable(\"uniform\", \"float\", \"iFrameRate\",   self.fps)\n        yield ShaderVariable(\"uniform\", \"int\",   \"iFrame\",       self.frame)\n        yield ShaderVariable(\"uniform\", \"bool\",  \"iRealtime\",    self.realtime)\n        yield ShaderVariable(\"uniform\", \"vec2\",  \"iMouse\",       self.mouse_gluv)\n        yield ShaderVariable(\"uniform\", \"bool\",  \"iMouseInside\", self.mouse_inside)\n        for i in range(1, 6):\n            yield ShaderVariable(\"uniform\", \"bool\", f\"iMouse{i}\", self.mouse_buttons[i])\n\n    # ---------------------------------------------------------------------------------------------|\n    # Internal window events\n\n    def __window_resize__(self, width: int, height: int) -&gt; None:\n\n        # Don't listen to resizes when exporting, as the final resolution might be\n        # greater than the monitor and the window will resize down to fit\n        if self.exporting:\n            return\n        self.imgui.resize(width, height)\n        self._width, self._height = width, height\n        self.relay(ShaderMessage.Shader.RecreateTextures)\n\n    def __window_close__(self) -&gt; None:\n        self.relay(ShaderMessage.Window.Close())\n\n    def __window_iconify__(self, state: bool) -&gt; None:\n        self.relay(ShaderMessage.Window.Iconify(state=state))\n\n    def __window_files_dropped_event__(self, *stuff: list[str]) -&gt; None:\n        self.relay(ShaderMessage.Window.FileDrop(files=stuff[1]))\n\n    # # Keyboard related events\n\n    def __window_key_event__(self, key: int, action: int, modifiers: int) -&gt; None:\n        self.imgui.key_event(key, action, modifiers)\n        if self.imguio.want_capture_keyboard and self.render_ui:\n            return\n        if action == ShaderKeyboard.Keys.ACTION_PRESS:\n            self.relay(ShaderMessage.Keyboard.KeyDown(key=key, modifiers=modifiers))\n        elif action == ShaderKeyboard.Keys.ACTION_RELEASE:\n            self.relay(ShaderMessage.Keyboard.KeyUp(key=key, modifiers=modifiers))\n        self.relay(ShaderMessage.Keyboard.Press(key=key, action=action, modifiers=modifiers))\n\n    def __window_unicode_char_entered__(self, char: str) -&gt; None:\n        if self.imguio.want_capture_keyboard and self.render_ui:\n            return\n        self.relay(ShaderMessage.Keyboard.Unicode(char=char))\n\n    # # Mouse related events\n\n    mouse_gluv: Tuple[float, float] = Factory(lambda: (0, 0))\n\n    def __xy2uv__(self, x: int=0, y: int=0) -&gt; dict[str, float]:\n        \"\"\"Convert a XY pixel coordinate into a Center-UV normalized coordinate\"\"\"\n        return dict(\n            u=2*(x/self.width  - 0.5),\n            v=2*(y/self.height - 0.5)*(-1),\n            x=x, y=y,\n        )\n\n    def __dxdy2dudv__(self, dx: int=0, dy: int=0) -&gt; dict[str, float]:\n        \"\"\"Convert a dx dy pixel coordinate into a Center-UV normalized coordinate\"\"\"\n        return dict(\n            du=2*(dx/self.width)*(self.width/self.height),\n            dv=2*(dy/self.height)*(-1),\n            dx=dx, dy=dy,\n        )\n\n    mouse_buttons: Dict[int, bool] = Factory(lambda: {k: False for k in range(1, 6)})\n\n    def __window_mouse_press_event__(self, x: int, y: int, button: int) -&gt; None:\n        self.imgui.mouse_press_event(x, y, button)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n        self.mouse_buttons[button] = True\n        self.relay(ShaderMessage.Mouse.Press(\n            **self.__xy2uv__(x, y),\n            button=button\n        ))\n\n    def __window_mouse_release_event__(self, x: int, y: int, button: int) -&gt; None:\n        self.imgui.mouse_release_event(x, y, button)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n        self.mouse_buttons[button] = False\n        self.relay(ShaderMessage.Mouse.Release(\n            **self.__xy2uv__(x, y),\n            button=button\n        ))\n\n    mouse_inside: bool = False\n\n    def __window_mouse_enter_event__(self, inside: bool) -&gt; None:\n        self.mouse_inside = inside\n        self.relay(ShaderMessage.Mouse.Enter(state=inside))\n\n    def __window_mouse_scroll_event__(self, dx: int, dy: int) -&gt; None:\n        self.imgui.mouse_scroll_event(dx, dy)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n        elif self.keyboard(ShaderKeyboard.Keys.LEFT_ALT):\n            self.tempo.target += (dy)*0.2\n            return\n        self.relay(ShaderMessage.Mouse.Scroll(\n            **self.__dxdy2dudv__(dx=dx, dy=dy)\n        ))\n\n    def __window_mouse_position_event__(self, x: int, y: int, dx: int, dy: int) -&gt; None:\n        self.imgui.mouse_position_event(x, y, dx, dy)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n        self.relay(ShaderMessage.Mouse.Position(\n            **self.__dxdy2dudv__(dx=dx, dy=dy),\n            **self.__xy2uv__(x=x, y=y)\n        ))\n\n    _mouse_drag_time_factor: float = 4\n    \"\"\"How much seconds to scroll in time when the mouse moves the full window height\"\"\"\n\n    def __window_mouse_drag_event__(self, x: int, y: int, dx: int, dy: int) -&gt; None:\n        self.imgui.mouse_drag_event(x, y, dx, dy)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n\n        # Rotate the camera on Shift\n        if self.keyboard(ShaderKeyboard.Keys.LEFT_CTRL):\n            cx, cy = (x-self.width/2), (y-self.height/2)\n            angle = math.atan2(cy+dy, cx+dx) - math.atan2(cy, cx)\n            if (abs(angle) &gt; math.pi): angle -= 2*math.pi\n            self.camera.rotate(self.camera.base_z, angle=math.degrees(angle))\n            return\n\n        elif self.exclusive:\n            self.camera.apply_zoom(-dy/500)\n            self.camera.rotate(self.camera.base_z, angle=-dx/10)\n            return\n\n        # Time Travel on Alt\n        elif self.keyboard(ShaderKeyboard.Keys.LEFT_ALT):\n            self.time -= self._mouse_drag_time_factor * (dy/self.height)\n            return\n\n        self.relay(ShaderMessage.Mouse.Drag(\n            **self.__dxdy2dudv__(dx=dx, dy=dy),\n            **self.__xy2uv__(x=x, y=y)\n        ))\n\n    # ---------------------------------------------------------------------------------------------|\n    # Todo: Move UI to own class: For main menu, settings, exporting, etc\n\n    render_ui: bool = False\n    \"\"\"Whether to render the Main UI\"\"\"\n\n    # Fixme: Move to somewhere better\n    def _render_ui(self):\n        if not self.render_ui:\n            return\n\n        self._final.texture.fbo().use()\n        imgui.push_style_var(imgui.STYLE_WINDOW_BORDERSIZE, 0.0)\n        imgui.push_style_var(imgui.STYLE_WINDOW_ROUNDING, 8)\n        imgui.push_style_var(imgui.STYLE_TAB_ROUNDING, 8)\n        imgui.push_style_var(imgui.STYLE_GRAB_ROUNDING, 8)\n        imgui.push_style_var(imgui.STYLE_FRAME_ROUNDING, 8)\n        imgui.push_style_var(imgui.STYLE_CHILD_ROUNDING, 8)\n        imgui.push_style_color(imgui.COLOR_FRAME_BACKGROUND, 0.1, 0.1, 0.1, 0.5)\n        imgui.new_frame()\n        imgui.set_next_window_position(0, 0)\n        imgui.set_next_window_bg_alpha(0.6)\n        imgui.begin(f\"{self.__name__}\", False, imgui.WINDOW_NO_MOVE | imgui.WINDOW_NO_RESIZE | imgui.WINDOW_NO_COLLAPSE  | imgui.WINDOW_ALWAYS_AUTO_RESIZE)\n\n        # Render every module\n        for module in self.modules:\n            if imgui.tree_node(f\"{module.uuid:&gt;2} - {type(module).__name__.replace('ShaderFlow', '')}\", imgui.TREE_NODE_BULLET | imgui.TREE_NODE_DEFAULT_OPEN):\n                module.__shaderflow_ui__()\n                imgui.spacing()\n                imgui.tree_pop()\n\n        imgui.end()\n        imgui.pop_style_color()\n        imgui.pop_style_var(6)\n        imgui.render()\n        self.imgui.render(imgui.get_draw_data())\n\n    def __ui__(self) -&gt; None:\n\n        # Render status\n        imgui.text(f\"Resolution: {self.render_resolution} -&gt; {self.resolution} @ {self.ssaa:.2f}x SSAA\")\n\n        # Framerate\n        imgui.spacing()\n        if (state := imgui.slider_float(\"Framerate\", self.fps, 10, 240, \"%.0f\"))[0]:\n            self.fps = round(state[1])\n        for fps in (options := [24, 30, 60, 120, 144, 240]):\n            if (state := imgui.button(f\"{fps} Hz\")):\n                self.fps = fps\n            if fps != options[-1]:\n                imgui.same_line()\n\n        # Temporal\n        imgui.spacing()\n        if (state := imgui.slider_float(\"Time Scale\", self.tempo.target, -2, 2, \"%.2f\"))[0]:\n            self.tempo.target = state[1]\n        for scale in (options := [-10, -5, -2, -1, 0, 1, 2, 5, 10]):\n            if (state := imgui.button(f\"{scale}x\")):\n                self.tempo.target = scale\n            if scale != options[-1]:\n                imgui.same_line()\n\n        # SSAA\n        imgui.spacing()\n        if (state := imgui.slider_float(\"SSAA\", self.ssaa, 0.01, 2, \"%.2f\"))[0]:\n            self.ssaa = state[1]\n        for ssaa in (options := [0.1, 0.25, 0.5, 1.0, 1.25, 1.5, 2.0]):\n            if (state := imgui.button(f\"{ssaa}x\")):\n                self.ssaa = ssaa\n            if ssaa != options[-1]:\n                imgui.same_line()\n\n        # Quality\n        imgui.spacing()\n        if (state := imgui.slider_float(\"Quality\", self.quality, 0, 100, \"%.0f%%\"))[0]:\n            self.quality = state[1]\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__name__","title":"<code>__name__ = 'Scene'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.modules","title":"<code>modules: Deque[ShaderModule] = Factory(deque)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Deque of all Modules on the Scene, not a set for order preservation</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.scheduler","title":"<code>scheduler: BrokenScheduler = Factory(BrokenScheduler)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.vsync","title":"<code>vsync: BrokenTask = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.frametimer","title":"<code>frametimer: ShaderFrametimer = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.keyboard","title":"<code>keyboard: ShaderKeyboard = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.camera","title":"<code>camera: ShaderCamera = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.ffmpeg","title":"<code>ffmpeg: BrokenFFmpeg = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.shader","title":"<code>shader: ShaderObject = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The main ShaderObject of the Scene, the visible content of the Window</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.alpha","title":"<code>alpha: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Makes the final texture have an alpha channel, useful for transparent windows. Exporting videos might fail, perhaps output a Chroma Key compatible video - add this to the shader: - <code>fragColor.rgb = mix(vec3(0, 1, 0), fragColor.rgb, fragColor.a);</code></p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.quality","title":"<code>quality: float = field(default=50, converter=lambda x: clamp(x, 0, 100))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rendering Quality, if implemented - either on the GPU Shader or CPU Python side</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.typer","title":"<code>typer: BrokenTyper = Factory(lambda: BrokenTyper(chain=True))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>This Scene's BrokenTyper instance for the CLI. Commands are added by any module in the <code>self.commands</code> method. The <code>self.main</code> is always added to it</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __post__(self):\n    self.typer.description = (self.typer.description or self.__class__.__doc__)\n    self.typer._panel = \"\ud83d\udd25 Scene commands\"\n    self.typer.command(self.main, context=True)\n    self.build()\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.cli","title":"<code>cli(*args: List[Union[Any, str]])</code>","text":"<p>Interpret a list of arguments as actions, defined by the Scene's <code>self.commands</code> plus the <code>main</code> method. Must not start with <code>sys.executable</code>, so send <code>sys.argv[1:]</code> or direct</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def cli(self, *args: List[Union[Any, str]]):\n    \"\"\"Interpret a list of arguments as actions, defined by the Scene's `self.commands` plus\n    the `main` method. Must not start with `sys.executable`, so send `sys.argv[1:]` or direct\"\"\"\n    self.typer(flatten(args))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.build","title":"<code>build()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>@OnceTracker.decorator\ndef build(self):\n    imgui.create_context()\n    self.imguio = imgui.get_io()\n    self.imguio.font_global_scale = 1\n    self.imguio.fonts.add_font_from_file_ttf(\n        str(Broken.BROKEN.RESOURCES.FONTS/\"DejaVuSans.ttf\"),\n        16*self.imguio.font_global_scale,\n    )\n\n    # Default modules\n    self.init_window()\n    self.frametimer = ShaderFrametimer(scene=self)\n    self.keyboard = ShaderKeyboard(scene=self)\n    self.camera = ShaderCamera(scene=self)\n\n    # Create the SSAA Workaround engines\n    self._final = ShaderObject(scene=self, name=\"iFinal\")\n    self._final.texture.components = 3 + int(self.alpha)\n    self._final.texture.dtype = \"f1\"\n    self._final.texture.final = True\n    self._final.texture.track = True\n    self._final.fragment = (SHADERFLOW.RESOURCES.FRAGMENT/\"Final.glsl\")\n    self.shader = ShaderObject(scene=self, name=\"iScreen\")\n    self.shader.texture.track = True\n    self.shader.texture.repeat(False)\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.time","title":"<code>time: Seconds = field(default=0.0, converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current time in seconds. Ideally, everything should depend on time, for flexibility</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.tempo","title":"<code>tempo: float = Factory(lambda: DynamicNumber(value=1, frequency=3))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Time scale factor, used for <code>dt</code>, which integrates to <code>time</code></p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.runtime","title":"<code>runtime: Seconds = field(default=10.0, converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The longest module duration; overriden by the user; or default length of 10s</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.fps","title":"<code>fps: Hertz = field(default=60.0, converter=lambda x: max(float(x), 1.0))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target frames per second rendering speed</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.dt","title":"<code>dt: Seconds = field(default=0.0, converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Virtual delta time since last frame, time scaled by <code>tempo</code>. Use <code>self.rdt</code> for real delta</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.rdt","title":"<code>rdt: Seconds = field(default=0.0, converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Real life, physical delta time since last frame. Use <code>self.dt</code> for time scaled version</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.tau","title":"<code>tau: float</code>  <code>property</code>","text":"<p>Normalized time value relative to runtime between 0 and 1</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.cycle","title":"<code>cycle: float</code>  <code>property</code>","text":"<p>A number from 0 to 2pi that ends on the runtime ('normalized angular time')</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.frametime","title":"<code>frametime: Seconds</code>  <code>property</code> <code>writable</code>","text":"<p>Ideal time between two frames. This value is coupled with <code>fps</code></p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.frame","title":"<code>frame: int</code>  <code>property</code> <code>writable</code>","text":"<p>Current frame being rendered. This value is coupled with 'time' and 'fps'</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.duration","title":"<code>duration: Seconds</code>  <code>property</code>","text":"<p>Alias to self.runtime. Set both with <code>.set_duration()</code></p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.set_duration","title":"<code>set_duration(override: Seconds = None, *, minimum: Seconds = 10) -&gt; Seconds</code>","text":"<p>Either force the runtime to be 'override' or find the longest module lower bounded</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def set_duration(self, override: Seconds=None, *, minimum: Seconds=10) -&gt; Seconds:\n    \"\"\"Either force the runtime to be 'override' or find the longest module lower bounded\"\"\"\n    self.runtime = (override or minimum)\n    for module in (not bool(override)) * self.modules:\n        self.runtime = max(self.runtime, module.duration)\n    self.runtime /= self.tempo.value\n    return self.runtime\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.total_frames","title":"<code>total_frames: int</code>  <code>property</code>","text":"<p>The total frames this scene should render when exporting, if 'runtime' isn't changed</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.title","title":"<code>title: str</code>  <code>property</code> <code>writable</code>","text":"<p>Realtime window 'title' property</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.resizable","title":"<code>resizable: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Realtime window 'is resizable' property</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.visible","title":"<code>visible: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Realtime window 'is visible' property</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.fullscreen","title":"<code>fullscreen: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Window 'is fullscreen' property</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.exclusive","title":"<code>exclusive: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Window 'mouse exclusivity' property: Is the mouse cursor be locked to the window</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.monitor","title":"<code>monitor: int = os.getenv('MONITOR', 0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.glfw_monitor","title":"<code>glfw_monitor: Optional[glfw._GLFWmonitor]</code>  <code>property</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.glfw_video_mode","title":"<code>glfw_video_mode: Optional[Dict]</code>  <code>property</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.monitor_framerate","title":"<code>monitor_framerate: float</code>  <code>property</code>","text":"<p>Note: Defaults to 60 if no monitor is found</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.monitor_size","title":"<code>monitor_size: Optional[Tuple[int, int]]</code>  <code>property</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.monitor_width","title":"<code>monitor_width: Optional[int]</code>  <code>property</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.monitor_height","title":"<code>monitor_height: Optional[int]</code>  <code>property</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.scale","title":"<code>scale: float</code>  <code>property</code> <code>writable</code>","text":"<p>Resolution scale factor, the <code>self.width</code> and <code>self.height</code> are multiplied by this</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.width","title":"<code>width: int</code>  <code>property</code> <code>writable</code>","text":"<p>Rendering width (horizontal size) of the Scene in pixels</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.height","title":"<code>height: int</code>  <code>property</code> <code>writable</code>","text":"<p>Rendering height (vertical size) of the Scene in pixels</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.ssaa","title":"<code>ssaa: float</code>  <code>property</code> <code>writable</code>","text":"<p>Fractional Super Sampling Anti-Aliasing (SSAA) factor. Improves the image quality (&gt;1) by rendering at a higher resolution and then downsampling, resulting in smoother edges at a significant GPU computational cost of O(N^2). Values lower than 1 (yield worse quality, but) are useful when the GPU can't keep up: when the resolution is too high or FPS is too low</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.resolution","title":"<code>resolution: Tuple[int, int]</code>  <code>property</code> <code>writable</code>","text":"<p>The resolution the Scene is rendering in pixels</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.render_resolution","title":"<code>render_resolution: Tuple[int, int]</code>  <code>property</code>","text":"<p>Internal 'true' rendering resolution for SSAA. Same as <code>self.resolution*self.ssaa</code></p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.aspect_ratio","title":"<code>aspect_ratio: float</code>  <code>property</code> <code>writable</code>","text":"<p>Either the forced <code>self._aspect_ratio</code> or dynamic from <code>self.width/self.height</code>. When set and resizing, the logic of <code>BrokenResolution.fit</code> is applied to enforce ratios</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.resize","title":"<code>resize(width: Union[int, float] = Unchanged, height: Union[int, float] = Unchanged, *, aspect_ratio: Union[Unchanged, float, str] = Unchanged, scale: float = Unchanged) -&gt; Tuple[int, int]</code>","text":"<p>Resize the true final rendering resolution of the Scene. Rounded to nearest multiple of 2, so FFmpeg is happy, and limited by the monitor resolution if realtime</p> <p>Parameters:</p> <ul> <li> <code>width</code>             (<code>Union[int, float]</code>, default:                 <code>Unchanged</code> )         \u2013          <p>New width of the Scene, None to not change</p> </li> <li> <code>height</code>             (<code>Union[int, float]</code>, default:                 <code>Unchanged</code> )         \u2013          <p>New height of the Scene, None to not change</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (            <code>Tuple[int, int]</code> )        \u2013          <p>Fluent interface</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def resize(self,\n    width: Union[int, float]=Unchanged,\n    height: Union[int, float]=Unchanged,\n    *,\n    aspect_ratio: Union[Unchanged, float, str]=Unchanged,\n    scale: float=Unchanged\n) -&gt; Tuple[int, int]:\n    \"\"\"\n    Resize the true final rendering resolution of the Scene. Rounded to nearest multiple of 2,\n    so FFmpeg is happy, and limited by the monitor resolution if realtime\n\n    Args:\n        width:  New width of the Scene, None to not change\n        height: New height of the Scene, None to not change\n\n    Returns:\n        Self: Fluent interface\n    \"\"\"\n\n    # Maybe update auxiliary properties\n    self.aspect_ratio = (aspect_ratio or self._aspect_ratio)\n    self._scale = (scale or self._scale)\n\n    # The parameters aren't trivial. The idea is to fit resolution from the scale-less components,\n    # so scaling isn't carried over, then to apply scaling (self.resolution)\n    resolution = BrokenResolution.fit(\n        old=(self._width, self._height),\n        new=(width, height),\n        max=(self.monitor_size),\n        ar=self._aspect_ratio\n    )\n\n    # Optimization: Only resize when resolution changes\n    if (resolution != (self.width, self.height)):\n        self._width, self._height = resolution\n        self.window.size = self.resolution\n        self.relay(ShaderMessage.Shader.RecreateTextures)\n        log.info(f\"{self.who} Resized Window to {self.resolution}\")\n\n    return self.resolution\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.backend","title":"<code>backend: WindowBackend = WindowBackend.get(os.getenv('WINDOW_BACKEND', WindowBackend.GLFW))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The ModernGL Window Backend. Cannot be changed after creation. Can also be set with the environment variable <code>WINDOW_BACKEND=&lt;backend&gt;</code>, where <code>backend = {glfw, headless}</code></p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.opengl","title":"<code>opengl: moderngl.Context = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ModernGL Context of this Scene. The thread accessing this MUST own or ENTER its context for creating, changing, deleting objects; more often than not, it's the Main thread</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.window","title":"<code>window: ModernglWindow = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ModernGL Window instance at <code>site-packages/moderngl_window.context.&lt;self.backend&gt;.Window</code></p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.imgui","title":"<code>imgui: ModernglImgui = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ModernGL Imgui integration class bound to the Window</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.imguio","title":"<code>imguio: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Imgui IO object</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.init_window","title":"<code>init_window() -&gt; None</code>","text":"<p>Create the window and the OpenGL context</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def init_window(self) -&gt; None:\n    \"\"\"Create the window and the OpenGL context\"\"\"\n    if self.window:\n        raise RuntimeError(\"Window backend cannot be changed after creation\")\n\n    # Use EGL for creating a OpenGL context, allows true headless with GPU acceleration\n    # Comments 2 and 6: (https://forums.developer.nvidia.com/t/81412)\n    # Note: For the cloud, see (https://brokensrc.dev/get/docker/)\n    backend = \"egl\" if (os.getenv(\"WINDOW_EGL\", \"1\") == \"1\") else None\n\n    # Dynamically import the ModernGL Window Backend and instantiate it. Vsync is on our side \ud83d\ude09\n    module = f\"moderngl_window.context.{denum(self.backend).lower()}\"\n    self.window = importlib.import_module(module).Window(\n        size=self.resolution,\n        title=self.title,\n        resizable=self.resizable,\n        visible=self.visible,\n        fullscreen=self.fullscreen,\n        vsync=False,\n        backend=backend\n    )\n    ShaderKeyboard.set_keymap(self.window.keys)\n    self.imgui  = ModernglImgui(self.window)\n    self.opengl = self.window.ctx\n\n    # Bind window events to relay\n    self.window.resize_func               = self.__window_resize__\n    self.window.close_func                = self.__window_close__\n    self.window.iconify_func              = self.__window_iconify__\n    self.window.key_event_func            = self.__window_key_event__\n    self.window.mouse_position_event_func = self.__window_mouse_position_event__\n    self.window.mouse_press_event_func    = self.__window_mouse_press_event__\n    self.window.mouse_release_event_func  = self.__window_mouse_release_event__\n    self.window.mouse_drag_event_func     = self.__window_mouse_drag_event__\n    self.window.mouse_scroll_event_func   = self.__window_mouse_scroll_event__\n    self.window.unicode_char_entered_func = self.__window_unicode_char_entered__\n    self.window.files_dropped_event_func  = self.__window_files_dropped_event__\n\n    if (self.backend == WindowBackend.GLFW):\n        BrokenThread.new(target=self.window.set_icon, icon_path=Broken.PROJECT.RESOURCES.ICON, daemon=True)\n        glfw.set_cursor_enter_callback(self.window._window, lambda _, enter: self.__window_mouse_enter_event__(inside=enter))\n        glfw.set_drop_callback(self.window._window, self.__window_files_dropped_event__)\n        ShaderKeyboard.Keys.LEFT_SHIFT = glfw.KEY_LEFT_SHIFT\n        ShaderKeyboard.Keys.LEFT_CTRL  = glfw.KEY_LEFT_CONTROL\n        ShaderKeyboard.Keys.LEFT_ALT   = glfw.KEY_LEFT_ALT\n\n    log.info(f\"OpenGL Renderer: {self.opengl.info['GL_RENDERER']}\")\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.read_screen","title":"<code>read_screen() -&gt; bytes</code>","text":"<p>Take a screenshot of the screen and return raw bytes. Length <code>width*height*components</code></p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def read_screen(self) -&gt; bytes:\n    \"\"\"Take a screenshot of the screen and return raw bytes. Length `width*height*components`\"\"\"\n    return self.window.fbo.read(viewport=(0, 0, self.width, self.height))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.directory","title":"<code>directory: Path</code>  <code>property</code>","text":"<p>Path of the current Scene file Python script. This works by searching up the call stack for the first context whose filename isn't the local file (of ShaderFlow.Scene)</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.read_file","title":"<code>read_file(file: Path, bytes: bool = False) -&gt; Union[str, bytes]</code>","text":"<p>Read a file relative to the current Scene Python script</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>Path</code>)         \u2013          <p>File to read, relative to the current Scene script directory</p> </li> <li> <code>bytes</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to read the file as bytes, defaults to text</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[str, bytes]</code>         \u2013          <p>File contents as text or bytes</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def read_file(self, file: Path, bytes: bool=False) -&gt; Union[str, bytes]:\n    \"\"\"\n    Read a file relative to the current Scene Python script\n\n    Args:\n        file:  File to read, relative to the current Scene script directory\n        bytes: Whether to read the file as bytes, defaults to text\n\n    Returns:\n        File contents as text or bytes\n    \"\"\"\n    file = (self.directory/file)\n    log.info(f\"{self.who} Reading file ({file})\")\n    return LoaderBytes(file) if bytes else LoaderString(file)\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.quit","title":"<code>quit: PlainTracker = Factory(lambda: PlainTracker(False))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Should the scene end the main event loop? Use as <code>if scene.quit():</code></p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.next","title":"<code>next(dt: float) -&gt; Self</code>","text":"<p>Integrate time, update all modules and render the next frame</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def next(self, dt: float) -&gt; Self:\n    \"\"\"Integrate time, update all modules and render the next frame\"\"\"\n\n    # Fixme: Windows: https://github.com/glfw/glfw/pull/1426\n    # Immediately swap the buffer with previous frame for vsync\n    self.window.swap_buffers()\n\n    # Temporal logic\n    dt = min(dt, 1)\n    self.tempo.next(dt=abs(dt))\n    self.vsync.fps = self.fps\n    self.dt    = dt * self.tempo\n    self.rdt   = dt\n    self.time += self.dt\n\n    # Note: Updates in reverse order of addition (child -&gt; parent)\n    # Note: Update non-engine first, as the pipeline might change\n    for module in self.modules:\n        if not isinstance(module, ShaderObject):\n            module.update()\n    for module in reversed(self.modules):\n        if isinstance(module, ShaderObject):\n            module.update()\n\n    self._render_ui()\n    return self\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.exporting","title":"<code>exporting: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Is this Scene exporting to a video file?</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.rendering","title":"<code>rendering: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Either Exporting, Rendering or Benchmarking. 'Not Realtime' mode</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.realtime","title":"<code>realtime: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Running with a window and user interaction</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.headless","title":"<code>headless: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Running Headlessly, without a window and user interaction</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.benchmark","title":"<code>benchmark: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Stress test the rendering speed of the Scene</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.repeat","title":"<code>repeat: int = field(default=1, converter=int)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of times to loop the exported video. One '1' is no repeat, two '2' doubles the length. Ideally have seamless transitions on the shader based on self.tau and/or/no audio input</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.export_batch","title":"<code>export_batch: Iterable[int] = field(factory=lambda: [0], converter=lambda x: list(x) or [0])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Batch indices iterable to export</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.export_index","title":"<code>export_index: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current Batch exporting video index</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.export_format","title":"<code>export_format: str = field(default='mp4', converter=lambda x: str(denum(x)))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The last (or only) video export format (extension) to use</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.export_base","title":"<code>export_base: Path = field(default=Broken.PROJECT.DIRECTORIES.DATA, converter=lambda x: Path(x))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The last (or only) video export base directory. Videos should render to (base/name) if $name is plain, that is, the path isn't absolute</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.export_name","title":"<code>export_name(path: Path) -&gt; Path</code>  <code>abstractmethod</code>","text":"<p>Change the video file name being exported based on the current batch index. By default, the name is unchanged in single export, else the stem is appended with the batch index</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>@abstractmethod\ndef export_name(self, path: Path) -&gt; Path:\n    \"\"\"Change the video file name being exported based on the current batch index. By default,\n    the name is unchanged in single export, else the stem is appended with the batch index\"\"\"\n    if (len(self.export_batch) &gt; 1):\n        return path.with_stem(f\"{path.stem}_{self.export_index}\")\n    return path\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.main","title":"<code>main(width: Annotated[int, Option(--width, -w, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Width  of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1920 on init)[/dim]')] = None, height: Annotated[int, Option(--height, -h, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Height of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1080 on init)[/dim]')] = None, scale: Annotated[float, Option(--scale, -x, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Post-multiply width and height by a scale factor [medium_purple3](None to keep)[/medium_purple3] [dim](1.0 on init)[dim]')] = None, aspect: Annotated[str, Option(--ar, -R, help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Force resolution aspect ratio [green](Examples: '16:9', '16/9', '1.777')[/green] [medium_purple3](None for dynamic)[/medium_purple3]\")] = None, fps: Annotated[float, Option(--fps, -f, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Target frames per second [medium_purple3](Defaults to the monitor framerate on realtime else 60)[/medium_purple3]')] = None, fullscreen: Annotated[bool, Option(--fullscreen, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in fullscreen mode [medium_purple3](Toggle with F11)[/medium_purple3]')] = False, maximize: Annotated[bool, Option(--maximize, -M, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in maximized mode')] = False, quality: Annotated[float, Option(--quality, -q, help='[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Shader quality level [green](0-100%)[/green] [yellow](If supported by the shader)[/yellow] [medium_purple3](None to keep, default 50%)[/medium_purple3]')] = None, ssaa: Annotated[float, Option(--ssaa, -s, help='[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Fractional super sampling anti aliasing factor [yellow](O(N^2) GPU cost)[/yellow] [medium_purple3](None to keep, default 1.0)[/medium_purple3]')] = None, render: Annotated[bool, Option(--render, -r, help='[green](\ud83d\udfe2 Export )[/green] Export the Scene to a video file [medium_purple3](defined on --output, and implicit if so)[/medium_purple3]')] = False, output: Annotated[str, Option(--output, -o, help=\"[green](\ud83d\udfe2 Export )[/green] Output file name [green]('Absolute', 'Relative path', 'Plain Name')[/green] [dim]($base/$(plain_name or $scene-$date))[/dim]\")] = None, time: Annotated[float, Option(--time, -t, help=\"[green](\ud83d\udfe2 Export )[/green] The duration of exported videos [dim](Loop duration)[/dim] [medium_purple3](defaults to 10 or longest module's duration)[/medium_purple3]\")] = None, tempo: Annotated[float, Option(--tempo, -T, help='[green](\ud83d\udfe2 Export )[/green] Set the time speed factor of the Scene [yellow](Final duration is stretched by [italic]1/tempo[/italic])[/yellow] [dim](1 on init)[/dim]')] = None, repeat: Annotated[int, Option(--repeat, help='[green](\ud83d\udfe2 Export )[/green] Number of exported videos loop copies [yellow](Final duration is stretched by [italic]repeat[/italic])[/yellow] [dim](1 on init)[/dim]')] = None, format: Annotated[str, Option(--format, -F, help=\"[green](\ud83d\udfe2 Export )[/green] Output video container [green]('mp4', 'mkv', 'webm', 'avi, '...')[/green] [yellow](Overrides --output one)[/yellow]\")] = 'mp4', base: Annotated[Path, Option(--base, -D, help='[green](\ud83d\udfe2 Export )[/green] Output file base directory')] = Broken.PROJECT.DIRECTORIES.DATA, vcodec: Annotated[str, Option(--vcodec, -c, help=\"[green](\ud83d\udfe2 Export )[/green] Video codec [green]('h264', 'h264-nvenc', 'h265, 'hevc-nvenc', 'vp9', 'av1-{aom,svt,nvenc,rav1e}')[/green]\")] = 'h264', acodec: Annotated[str, Option(--acodec, -a, help=\"[green](\ud83d\udfe2 Export )[/green] Audio codec [green]('aac', 'mp3', 'flac', 'wav', 'opus', 'ogg', 'copy', 'none', 'empty')[/green]\")] = 'copy', batch: Annotated[str, Option(--batch, -b, help='[bold][blue](\ud83d\udd35 Special)[/blue][/bold] [dim][WIP] Hyphenated indices range to export multiple videos, if implemented. (1,5-7,10)[/dim]')] = '0', benchmark: Annotated[bool, Option(--benchmark, -B, help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Benchmark the Scene's speed on raw rendering [medium_purple3](Use SKIP_GPU=1 for CPU only benchmark)[/medium_purple3]\")] = False, raw: Annotated[bool, Option(--raw, help='[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Send raw OpenGL frames before GPU SSAA to FFmpeg [medium_purple3](Enabled if SSAA &lt; 1)[/medium_purple3] [dim](CPU Downsampling)[/dim]')] = False, open: Annotated[bool, Option(--open, help='[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Open the directory of video exports after all rendering finishes')] = False) -&gt; Optional[List[Path]]</code>","text":"<p>Main event loop of this ShaderFlow Scene. Start a realtime window, exports to video, stress test speeds</p> <p>\u2022 Note: For advanced video or audio codec configuration, modify it on 'self.ffmpeg' maybe inheriting this base class</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def main(self,\n    width:      Annotated[int,   Option(\"--width\",      \"-w\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Width  of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1920 on init)[/dim]\")]=None,\n    height:     Annotated[int,   Option(\"--height\",     \"-h\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Height of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1080 on init)[/dim]\")]=None,\n    scale:      Annotated[float, Option(\"--scale\",      \"-x\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Post-multiply width and height by a scale factor [medium_purple3](None to keep)[/medium_purple3] [dim](1.0 on init)[dim]\")]=None,\n    aspect:     Annotated[str,   Option(\"--ar\",         \"-R\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Force resolution aspect ratio [green](Examples: '16:9', '16/9', '1.777')[/green] [medium_purple3](None for dynamic)[/medium_purple3]\")]=None,\n    fps:        Annotated[float, Option(\"--fps\",        \"-f\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Target frames per second [medium_purple3](Defaults to the monitor framerate on realtime else 60)[/medium_purple3]\")]=None,\n    fullscreen: Annotated[bool,  Option(\"--fullscreen\",       help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in fullscreen mode [medium_purple3](Toggle with F11)[/medium_purple3]\")]=False,\n    maximize:   Annotated[bool,  Option(\"--maximize\",   \"-M\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in maximized mode\")]=False,\n    quality:    Annotated[float, Option(\"--quality\",    \"-q\", help=\"[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Shader quality level [green](0-100%)[/green] [yellow](If supported by the shader)[/yellow] [medium_purple3](None to keep, default 50%)[/medium_purple3]\")]=None,\n    ssaa:       Annotated[float, Option(\"--ssaa\",       \"-s\", help=\"[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Fractional super sampling anti aliasing factor [yellow](O(N^2) GPU cost)[/yellow] [medium_purple3](None to keep, default 1.0)[/medium_purple3]\")]=None,\n    render:     Annotated[bool,  Option(\"--render\",     \"-r\", help=\"[green](\ud83d\udfe2 Export )[/green] Export the Scene to a video file [medium_purple3](defined on --output, and implicit if so)[/medium_purple3]\")]=False,\n    output:     Annotated[str,   Option(\"--output\",     \"-o\", help=\"[green](\ud83d\udfe2 Export )[/green] Output file name [green]('Absolute', 'Relative path', 'Plain Name')[/green] [dim]($base/$(plain_name or $scene-$date))[/dim]\")]=None,\n    time:       Annotated[float, Option(\"--time\",       \"-t\", help=\"[green](\ud83d\udfe2 Export )[/green] The duration of exported videos [dim](Loop duration)[/dim] [medium_purple3](defaults to 10 or longest module's duration)[/medium_purple3]\")]=None,\n    tempo:      Annotated[float, Option(\"--tempo\",      \"-T\", help=\"[green](\ud83d\udfe2 Export )[/green] Set the time speed factor of the Scene [yellow](Final duration is stretched by [italic]1/tempo[/italic])[/yellow] [dim](1 on init)[/dim]\")]=None,\n    repeat:     Annotated[int,   Option(\"--repeat\",           help=\"[green](\ud83d\udfe2 Export )[/green] Number of exported videos loop copies [yellow](Final duration is stretched by [italic]repeat[/italic])[/yellow] [dim](1 on init)[/dim]\")]=None,\n    format:     Annotated[str,   Option(\"--format\",     \"-F\", help=\"[green](\ud83d\udfe2 Export )[/green] Output video container [green]('mp4', 'mkv', 'webm', 'avi, '...')[/green] [yellow](Overrides --output one)[/yellow]\")]=\"mp4\",\n    base:       Annotated[Path,  Option(\"--base\",       \"-D\", help=\"[green](\ud83d\udfe2 Export )[/green] Output file base directory\")]=Broken.PROJECT.DIRECTORIES.DATA,\n    vcodec:     Annotated[str,   Option(\"--vcodec\",     \"-c\", help=\"[green](\ud83d\udfe2 Export )[/green] Video codec [green]('h264', 'h264-nvenc', 'h265, 'hevc-nvenc', 'vp9', 'av1-{aom,svt,nvenc,rav1e}')[/green]\")]=\"h264\",\n    acodec:     Annotated[str,   Option(\"--acodec\",     \"-a\", help=\"[green](\ud83d\udfe2 Export )[/green] Audio codec [green]('aac', 'mp3', 'flac', 'wav', 'opus', 'ogg', 'copy', 'none', 'empty')[/green]\")]=\"copy\",\n    batch:      Annotated[str,   Option(\"--batch\",      \"-b\", help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] [dim][WIP] Hyphenated indices range to export multiple videos, if implemented. (1,5-7,10)[/dim]\")]=\"0\",\n    benchmark:  Annotated[bool,  Option(\"--benchmark\",  \"-B\", help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Benchmark the Scene's speed on raw rendering [medium_purple3](Use SKIP_GPU=1 for CPU only benchmark)[/medium_purple3]\")]=False,\n    raw:        Annotated[bool,  Option(\"--raw\",              help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Send raw OpenGL frames before GPU SSAA to FFmpeg [medium_purple3](Enabled if SSAA &lt; 1)[/medium_purple3] [dim](CPU Downsampling)[/dim]\")]=False,\n    open:       Annotated[bool,  Option(\"--open\",             help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Open the directory of video exports after all rendering finishes\")]=False,\n) -&gt; Optional[List[Path]]:\n    \"\"\"\n    Main event loop of this ShaderFlow Scene. Start a realtime window, exports to video, stress test speeds\n\n    \u2022 Note: For advanced video or audio codec configuration, modify it on 'self.ffmpeg' maybe inheriting this base class\n    \"\"\"\n    outputs: List[Path] = []\n\n    from arrow import now as arrow_now\n    export_started = arrow_now().format(\"YYYY-MM-DD HH-mm-ss\")\n\n    # Maybe update indices of exporting videos\n    self.export_batch  = hyphen_range(batch) or self.export_batch\n    self.export_format = format\n    self.export_base   = base\n\n    for index in self.export_batch:\n        self.export_index = index\n        self.exporting  = (render or bool(output))\n        self.rendering  = (self.exporting or benchmark)\n        self.realtime   = (not self.rendering)\n        self.benchmark  = benchmark\n        self.headless   = (self.rendering)\n        self.fps        = (fps or self.monitor_framerate)\n        self.title      = f\"ShaderFlow | {self.__name__}\"\n        self.quality    = quality or self.quality\n        self.repeat     = repeat or self.repeat\n        self.ssaa       = ssaa or self.ssaa\n        self.fullscreen = fullscreen\n        self.time       = 0\n        self.tempo.set(tempo or self.tempo.value)\n\n        for module in self.modules:\n            module.setup()\n\n        self.relay(ShaderMessage.Shader.Compile)\n        self.set_duration(time)\n\n        # Maybe keep or force aspect ratio, and find best resolution\n        width, height = self.resize(width=width, height=height, scale=scale, aspect_ratio=aspect)\n\n        # Optimization: Save bandwidth by piping native frames on ssaa &lt; 1\n        if self.rendering and (raw or self.ssaa &lt; 1):\n            self.resolution = self.render_resolution\n            self.ssaa = 1\n\n        # Configure FFmpeg and Popen it\n        if (self.rendering):\n            export = Path(output or f\"({export_started}) {self.__name__}\")\n            export = export if export.is_absolute() else (self.export_base/export)\n            export = export.with_suffix(\".\" + (self.export_format or export.suffix).replace(\".\", \"\"))\n            export = self.export_name(export)\n\n            self.ffmpeg = (BrokenFFmpeg(time=self.runtime).quiet()\n                .pipe_input(pixel_format=(\"rgba\" if self.alpha else \"rgb24\"),\n                    width=self.width, height=self.height, framerate=self.fps)\n                .scale(width=width, height=height)\n                .output(path=export)\n            )\n\n            # Apply default good codec options on the video\n            self.ffmpeg.apply_vcodec_str(vcodec)\n            self.ffmpeg.apply_acodec_str(acodec)\n\n            for module in self.modules:\n                if module is self: continue\n                module.ffmpeg(self.ffmpeg)\n\n            if self.exporting:\n                buffer = self.opengl.buffer(reserve=self._final.texture.size_t)\n                self.ffmpeg = self.ffmpeg.popen(stdin=PIPE)\n\n            # Status tracker\n            status = DotMap(\n                start=perf_counter(),\n                bar=tqdm.tqdm(\n                    total=self.total_frames,\n                    desc=f\"Scene #{self.export_index} ({type(self).__name__}) \u2192 Video\",\n                    dynamic_ncols=True,\n                    colour=\"#43BFEF\",\n                    leave=False,\n                    unit=\" frames\",\n                    mininterval=1/30,\n                    maxinterval=0.1,\n                    smoothing=0.1,\n                )\n            )\n\n        # Some scenes might take a while to setup\n        self.visible = not self.headless\n\n        if (self.backend == WindowBackend.GLFW and maximize):\n            glfw.maximize_window(self.window._window)\n\n        # Add self.next to the event loop\n        self.vsync = self.scheduler.new(\n            task=self.next,\n            frequency=self.fps,\n            freewheel=self.rendering,\n            precise=True,\n        )\n\n        # Main rendering loop\n        while (self.rendering) or (not self.quit()):\n            task = self.scheduler.next()\n\n            # Only continue if exporting\n            if (task.output is not self):\n                continue\n            if self.realtime:\n                continue\n            status.bar.update(1)\n\n            # Write a new frame to FFmpeg\n            if self.exporting:\n                self._final.texture.fbo().read_into(buffer)\n                turbopipe.pipe(buffer, self.ffmpeg.stdin.fileno())\n\n            # Finish exporting condition\n            if (status.bar.n &lt; self.total_frames):\n                continue\n            status.bar.close()\n\n            if self.exporting:\n                log.info(\"Waiting for FFmpeg process to finish (Queued writes, codecs lookahead, buffers, etc)\")\n                turbopipe.close()\n                self.ffmpeg.stdin.close()\n                outputs.append(export)\n\n            # Repeat the video N times\n            if (self.repeat &gt; 1):\n                log.info(f\"Repeating video ({self.repeat-1} times)\")\n                export.rename(temporary := export.with_stem(f\"{export.stem}-repeat\"))\n                (BrokenFFmpeg(stream_loop=(self.repeat-1)).quiet().copy_audio().copy_video()\n                    .input(temporary).output(export, pixel_format=None).run())\n                temporary.unlink()\n\n            # Log stats\n            status.took = (perf_counter() - status.start)\n            log.info(f\"Finished rendering ({export})\", echo=not self.benchmark)\n            log.info((\n                f\"\u2022 Stats: \"\n                f\"(Took {status.took:.2f} s) at \"\n                f\"({self.frame/status.took:.2f} FPS | \"\n                f\"{self.runtime/status.took:.2f} x Realtime) with \"\n                f\"({status.bar.n} Total Frames)\"\n            ))\n\n            if self.benchmark:\n                return None\n            break\n\n    BrokenPath.open_in_file_explorer(outputs[0].parent) if open else None\n    return outputs\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.handle","title":"<code>handle(message: ShaderMessage) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def handle(self, message: ShaderMessage) -&gt; None:\n\n    if isinstance(message, ShaderMessage.Window.Close):\n        log.info(f\"{self.who} Received Window Close Event\")\n        self.quit(True)\n\n    elif isinstance(message, ShaderMessage.Keyboard.KeyDown):\n        if message.key == ShaderKeyboard.Keys.O:\n            log.info(f\"{self.who} (O  ) Resetting the Scene\")\n            for module in self.modules:\n                module.setup()\n            self.time = 0\n\n        elif message.key == ShaderKeyboard.Keys.R:\n            log.info(f\"{self.who} (R  ) Reloading Shaders\")\n            for module in self.modules:\n                if isinstance(module, ShaderObject):\n                    module.compile()\n\n        elif message.key == ShaderKeyboard.Keys.TAB:\n            log.info(f\"{self.who} (TAB) Toggling Menu\")\n            self.render_ui = not self.render_ui\n\n        elif message.key == ShaderKeyboard.Keys.F1:\n            log.info(f\"{self.who} (F1 ) Toggling Exclusive Mode\")\n            self.exclusive = not self.exclusive\n\n        elif message.key == ShaderKeyboard.Keys.F2:\n            import arrow\n            time  = arrow.now().format(\"YYYY-MM-DD_HH-mm-ss\")\n            image = PIL.Image.frombytes(\"RGB\", self.resolution, self.read_screen())\n            image = image.transpose(PIL.Image.FLIP_TOP_BOTTOM)\n            path  = Broken.PROJECT.DIRECTORIES.SCREENSHOTS/f\"({time}) {self.__name__}.png\"\n            log.minor(f\"{self.who} (F2 ) Saving Screenshot to ({path})\")\n            BrokenThread.new(target=image.save, fp=path)\n\n        elif message.key == ShaderKeyboard.Keys.F11:\n            log.info(f\"{self.who} (F11) Toggling Fullscreen\")\n            self.fullscreen = not self.fullscreen\n\n    elif isinstance(message, (ShaderMessage.Mouse.Drag, ShaderMessage.Mouse.Position)):\n        self.mouse_gluv = (message.u, message.v)\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    yield ShaderVariable(\"uniform\", \"float\", \"iTime\",        self.time)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDuration\",    self.duration)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDeltaTime\",   self.dt)\n    yield ShaderVariable(\"uniform\", \"vec2\",  \"iResolution\",  self.resolution)\n    yield ShaderVariable(\"uniform\", \"float\", \"iWantAspect\",  self.aspect_ratio)\n    yield ShaderVariable(\"uniform\", \"float\", \"iQuality\",     self.quality/100)\n    yield ShaderVariable(\"uniform\", \"float\", \"iSSAA\",        self.ssaa)\n    yield ShaderVariable(\"uniform\", \"float\", \"iFrameRate\",   self.fps)\n    yield ShaderVariable(\"uniform\", \"int\",   \"iFrame\",       self.frame)\n    yield ShaderVariable(\"uniform\", \"bool\",  \"iRealtime\",    self.realtime)\n    yield ShaderVariable(\"uniform\", \"vec2\",  \"iMouse\",       self.mouse_gluv)\n    yield ShaderVariable(\"uniform\", \"bool\",  \"iMouseInside\", self.mouse_inside)\n    for i in range(1, 6):\n        yield ShaderVariable(\"uniform\", \"bool\", f\"iMouse{i}\", self.mouse_buttons[i])\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_resize__","title":"<code>__window_resize__(width: int, height: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_resize__(self, width: int, height: int) -&gt; None:\n\n    # Don't listen to resizes when exporting, as the final resolution might be\n    # greater than the monitor and the window will resize down to fit\n    if self.exporting:\n        return\n    self.imgui.resize(width, height)\n    self._width, self._height = width, height\n    self.relay(ShaderMessage.Shader.RecreateTextures)\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_close__","title":"<code>__window_close__() -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_close__(self) -&gt; None:\n    self.relay(ShaderMessage.Window.Close())\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_iconify__","title":"<code>__window_iconify__(state: bool) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_iconify__(self, state: bool) -&gt; None:\n    self.relay(ShaderMessage.Window.Iconify(state=state))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_files_dropped_event__","title":"<code>__window_files_dropped_event__(*stuff: list[str]) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_files_dropped_event__(self, *stuff: list[str]) -&gt; None:\n    self.relay(ShaderMessage.Window.FileDrop(files=stuff[1]))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_key_event__","title":"<code>__window_key_event__(key: int, action: int, modifiers: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_key_event__(self, key: int, action: int, modifiers: int) -&gt; None:\n    self.imgui.key_event(key, action, modifiers)\n    if self.imguio.want_capture_keyboard and self.render_ui:\n        return\n    if action == ShaderKeyboard.Keys.ACTION_PRESS:\n        self.relay(ShaderMessage.Keyboard.KeyDown(key=key, modifiers=modifiers))\n    elif action == ShaderKeyboard.Keys.ACTION_RELEASE:\n        self.relay(ShaderMessage.Keyboard.KeyUp(key=key, modifiers=modifiers))\n    self.relay(ShaderMessage.Keyboard.Press(key=key, action=action, modifiers=modifiers))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_unicode_char_entered__","title":"<code>__window_unicode_char_entered__(char: str) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_unicode_char_entered__(self, char: str) -&gt; None:\n    if self.imguio.want_capture_keyboard and self.render_ui:\n        return\n    self.relay(ShaderMessage.Keyboard.Unicode(char=char))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.mouse_gluv","title":"<code>mouse_gluv: Tuple[float, float] = Factory(lambda: (0, 0))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__xy2uv__","title":"<code>__xy2uv__(x: int = 0, y: int = 0) -&gt; dict[str, float]</code>","text":"<p>Convert a XY pixel coordinate into a Center-UV normalized coordinate</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __xy2uv__(self, x: int=0, y: int=0) -&gt; dict[str, float]:\n    \"\"\"Convert a XY pixel coordinate into a Center-UV normalized coordinate\"\"\"\n    return dict(\n        u=2*(x/self.width  - 0.5),\n        v=2*(y/self.height - 0.5)*(-1),\n        x=x, y=y,\n    )\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__dxdy2dudv__","title":"<code>__dxdy2dudv__(dx: int = 0, dy: int = 0) -&gt; dict[str, float]</code>","text":"<p>Convert a dx dy pixel coordinate into a Center-UV normalized coordinate</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __dxdy2dudv__(self, dx: int=0, dy: int=0) -&gt; dict[str, float]:\n    \"\"\"Convert a dx dy pixel coordinate into a Center-UV normalized coordinate\"\"\"\n    return dict(\n        du=2*(dx/self.width)*(self.width/self.height),\n        dv=2*(dy/self.height)*(-1),\n        dx=dx, dy=dy,\n    )\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.mouse_buttons","title":"<code>mouse_buttons: Dict[int, bool] = Factory(lambda: {k: Falsefor k in range(1, 6)})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_mouse_press_event__","title":"<code>__window_mouse_press_event__(x: int, y: int, button: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_press_event__(self, x: int, y: int, button: int) -&gt; None:\n    self.imgui.mouse_press_event(x, y, button)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n    self.mouse_buttons[button] = True\n    self.relay(ShaderMessage.Mouse.Press(\n        **self.__xy2uv__(x, y),\n        button=button\n    ))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_mouse_release_event__","title":"<code>__window_mouse_release_event__(x: int, y: int, button: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_release_event__(self, x: int, y: int, button: int) -&gt; None:\n    self.imgui.mouse_release_event(x, y, button)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n    self.mouse_buttons[button] = False\n    self.relay(ShaderMessage.Mouse.Release(\n        **self.__xy2uv__(x, y),\n        button=button\n    ))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.mouse_inside","title":"<code>mouse_inside: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_mouse_enter_event__","title":"<code>__window_mouse_enter_event__(inside: bool) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_enter_event__(self, inside: bool) -&gt; None:\n    self.mouse_inside = inside\n    self.relay(ShaderMessage.Mouse.Enter(state=inside))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_mouse_scroll_event__","title":"<code>__window_mouse_scroll_event__(dx: int, dy: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_scroll_event__(self, dx: int, dy: int) -&gt; None:\n    self.imgui.mouse_scroll_event(dx, dy)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n    elif self.keyboard(ShaderKeyboard.Keys.LEFT_ALT):\n        self.tempo.target += (dy)*0.2\n        return\n    self.relay(ShaderMessage.Mouse.Scroll(\n        **self.__dxdy2dudv__(dx=dx, dy=dy)\n    ))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_mouse_position_event__","title":"<code>__window_mouse_position_event__(x: int, y: int, dx: int, dy: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_position_event__(self, x: int, y: int, dx: int, dy: int) -&gt; None:\n    self.imgui.mouse_position_event(x, y, dx, dy)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n    self.relay(ShaderMessage.Mouse.Position(\n        **self.__dxdy2dudv__(dx=dx, dy=dy),\n        **self.__xy2uv__(x=x, y=y)\n    ))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__window_mouse_drag_event__","title":"<code>__window_mouse_drag_event__(x: int, y: int, dx: int, dy: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_drag_event__(self, x: int, y: int, dx: int, dy: int) -&gt; None:\n    self.imgui.mouse_drag_event(x, y, dx, dy)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n\n    # Rotate the camera on Shift\n    if self.keyboard(ShaderKeyboard.Keys.LEFT_CTRL):\n        cx, cy = (x-self.width/2), (y-self.height/2)\n        angle = math.atan2(cy+dy, cx+dx) - math.atan2(cy, cx)\n        if (abs(angle) &gt; math.pi): angle -= 2*math.pi\n        self.camera.rotate(self.camera.base_z, angle=math.degrees(angle))\n        return\n\n    elif self.exclusive:\n        self.camera.apply_zoom(-dy/500)\n        self.camera.rotate(self.camera.base_z, angle=-dx/10)\n        return\n\n    # Time Travel on Alt\n    elif self.keyboard(ShaderKeyboard.Keys.LEFT_ALT):\n        self.time -= self._mouse_drag_time_factor * (dy/self.height)\n        return\n\n    self.relay(ShaderMessage.Mouse.Drag(\n        **self.__dxdy2dudv__(dx=dx, dy=dy),\n        **self.__xy2uv__(x=x, y=y)\n    ))\n</code></pre>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.render_ui","title":"<code>render_ui: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to render the Main UI</p>"},{"location":"depthflow/reference/scene/#Scene.ShaderScene.__ui__","title":"<code>__ui__() -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __ui__(self) -&gt; None:\n\n    # Render status\n    imgui.text(f\"Resolution: {self.render_resolution} -&gt; {self.resolution} @ {self.ssaa:.2f}x SSAA\")\n\n    # Framerate\n    imgui.spacing()\n    if (state := imgui.slider_float(\"Framerate\", self.fps, 10, 240, \"%.0f\"))[0]:\n        self.fps = round(state[1])\n    for fps in (options := [24, 30, 60, 120, 144, 240]):\n        if (state := imgui.button(f\"{fps} Hz\")):\n            self.fps = fps\n        if fps != options[-1]:\n            imgui.same_line()\n\n    # Temporal\n    imgui.spacing()\n    if (state := imgui.slider_float(\"Time Scale\", self.tempo.target, -2, 2, \"%.2f\"))[0]:\n        self.tempo.target = state[1]\n    for scale in (options := [-10, -5, -2, -1, 0, 1, 2, 5, 10]):\n        if (state := imgui.button(f\"{scale}x\")):\n            self.tempo.target = scale\n        if scale != options[-1]:\n            imgui.same_line()\n\n    # SSAA\n    imgui.spacing()\n    if (state := imgui.slider_float(\"SSAA\", self.ssaa, 0.01, 2, \"%.2f\"))[0]:\n        self.ssaa = state[1]\n    for ssaa in (options := [0.1, 0.25, 0.5, 1.0, 1.25, 1.5, 2.0]):\n        if (state := imgui.button(f\"{ssaa}x\")):\n            self.ssaa = ssaa\n        if ssaa != options[-1]:\n            imgui.same_line()\n\n    # Quality\n    imgui.spacing()\n    if (state := imgui.slider_float(\"Quality\", self.quality, 0, 100, \"%.0f%%\"))[0]:\n        self.quality = state[1]\n</code></pre>"},{"location":"depthflow/reference/state/","title":"State","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"depthflow/reference/state/#State","title":"<code>State</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState","title":"<code>State.DepthState</code>","text":"<p>Set parallax parameter values on the state green[/green]</p> Source code in <code>Projects/DepthFlow/DepthFlow/State.py</code> Python<pre><code>class DepthState(BaseModel):\n    \"\"\"Set parallax parameter values on the state [green](See 'config --help' for options)[/green]\"\"\"\n\n    height: Annotated[float, Option(\"--height\", \"-h\", min=0, max=1,\n        help=\"[bold][red](\ud83d\udd34 Basic   )[/red][/bold] Depthmap's peak value, the effect [bold][cyan]intensity[/cyan][/bold] [medium_purple3](The camera is 1 distance away from depth=0 at the z=1 plane)[/medium_purple3]\")] = \\\n        Field(default=0.35)\n\n    static: Annotated[float, Option(\"--static\", \"-s\", min=0, max=1,\n        help=\"[bold][red](\ud83d\udd34 Basic   )[/red][/bold] Focal depth plane of [bold][cyan]offsets[/cyan][/bold] [medium_purple3](A value of 0 makes the background stationary; and 1 for the foreground)[/medium_purple3]\")] = \\\n        Field(default=0.0)\n\n    focus: Annotated[float, Option(\"--focus\", \"-f\", min=0, max=1,\n        help=\"[bold][red](\ud83d\udd34 Basic   )[/red][/bold] Focal depth plane of [bold][cyan]perspective[/cyan][/bold] [medium_purple3](A value of 0 makes the background stationary; and 1 for the foreground)[/medium_purple3]\")] = \\\n        Field(default=0.5)\n\n    zoom: Annotated[float, Option(\"--zoom\", \"-z\", min=0,\n        help=\"[bold][red](\ud83d\udd34 Basic   )[/red][/bold] Camera [bold][cyan]zoom factor[/cyan][/bold] [medium_purple3](2 means a quarter of the image is visible)[/medium_purple3]\")] = \\\n        Field(default=1.0)\n\n    isometric: Annotated[float, Option(\"--isometric\", \"-iso\", min=0, max=1,\n        help=\"[bold][yellow](\ud83d\udfe1 Medium  )[/yellow][/bold] Isometric factor of [bold][cyan]camera projections[/cyan][/bold] [medium_purple3](Zero is fully perspective, 1 is orthographic)[/medium_purple3]\")] = \\\n        Field(default=0.0)\n\n    dolly: Annotated[float, Option(\"--dolly\", \"-d\", min=0, max=1,\n        help=\"[bold][yellow](\ud83d\udfe1 Medium  )[/yellow][/bold] Same effect as --isometric, dolly zoom [medium_purple3](Move back ray projection origins by this amount)[/medium_purple3]\")] = \\\n        Field(default=0.0)\n\n    invert: Annotated[float, Option(\"--invert\", \"-inv\", min=0, max=1,\n        help=\"[bold][yellow](\ud83d\udfe1 Medium  )[/yellow][/bold] Interpolate depth values between (0=far, 1=near) and vice-versa, as in [bold][cyan]mix(height, 1-height, invert)[/bold][/cyan]\")] = \\\n        Field(default=0.0)\n\n    mirror: Annotated[bool, Option(\"--mirror\", \"-m\", \" /-n\",\n        help=\"[bold][yellow](\ud83d\udfe1 Medium  )[/yellow][/bold] Apply [bold][cyan]GL_MIRRORED_REPEAT[/cyan][/bold] to the image [medium_purple3](The image is mirrored out of bounds on the respective edge)[/medium_purple3]\")] = \\\n        Field(default=True)\n\n    # # Center\n\n    center_x: Annotated[float, Option(\"--center-x\", \"-cex\", min=0, max=1,\n        help=\"[green](\ud83d\udfe2 Advanced)[/green] Horizontal 'true' offset of the camera [medium_purple3](The camera *is* above this point)[/medium_purple3]\")] = \\\n        Field(default=0)\n\n    center_y: Annotated[float, Option(\"--center-y\", \"-cey\", min=0, max=1,\n        help=\"[green](\ud83d\udfe2 Advanced)[/green] Vertical   'true' offset of the camera [medium_purple3](The camera *is* above this point)[/medium_purple3]\")] = \\\n        Field(default=0)\n\n    @property\n    def center(self) -&gt; Tuple[float, float]:\n        \"\"\"'True' offset of the camera, the camera *is* above this point\"\"\"\n        return (self.center_x, self.center_y)\n\n    @center.setter\n    def center(self, value: Tuple[float, float]):\n        self.center_x, self.center_y = value\n\n    # # Origin\n\n    origin_x: float = Field(default=0)\n    \"\"\"Hozirontal focal point of the offsets, *as if* the camera was above this point\"\"\"\n\n    origin_x: Annotated[float, Option(\"--origin-x\", \"-orx\",\n        help=\"[green](\ud83d\udfe2 Advanced)[/green] Horizontal focal point of the offsets [medium_purple3](*As if* the camera was above this point)[/medium_purple3]\")] = \\\n        Field(default=0)\n\n    origin_y: Annotated[float, Option(\"--origin-y\", \"-ory\", min=0, max=1,\n        help=\"[green](\ud83d\udfe2 Advanced)[/green] Vertical   focal point of the offsets [medium_purple3](*As if* the camera was above this point)[/medium_purple3]\")] = \\\n        Field(default=0)\n\n    @property\n    def origin(self) -&gt; Tuple[float, float]:\n        \"\"\"Focal point of the offsets, *as if* the camera was above this point\"\"\"\n        return (self.origin_x, self.origin_y)\n\n    @origin.setter\n    def origin(self, value: Tuple[float, float]):\n        self.origin_x, self.origin_y = value\n\n    # # Parallax\n\n    offset_x: Annotated[float, Option(\"--offset-x\", \"-ofx\",\n        help=\"[green](\ud83d\udfe2 Advanced)[/green] Horizontal parallax displacement [medium_purple3](Change this over time for the 3D effect)[/medium_purple3]\")] = \\\n        Field(default=0)\n\n    offset_y: Annotated[float, Option(\"--offset-y\", \"-ofy\",\n        help=\"[green](\ud83d\udfe2 Advanced)[/green] Vertical   parallax displacement [medium_purple3](Change this over time for the 3D effect)[/medium_purple3]\")] = \\\n        Field(default=0)\n\n    @property\n    def offset(self) -&gt; Tuple[float, float]:\n        \"\"\"Parallax displacement, change this over time for the 3D effect\"\"\"\n        return (self.offset_x, self.offset_y)\n\n    @offset.setter\n    def offset(self, value: Tuple[float, float]):\n        self.offset_x, self.offset_y = value\n\n    # # Special\n\n    def reset(self) -&gt; None:\n        for object in (self, self._dof, self._vignette):\n            for name, field in object.model_fields.items(): # noqa\n                setattr(object, name, field.default)\n\n    # ---------------------------------------------------------------------------------------------|\n\n    class _PFX_DOF(BaseModel):\n        \"\"\"Set depth of field parameters [green](See 'dof --help' for options)[/green]\"\"\"\n        enable: Annotated[bool, Option(\"--enable\", \"-e\",\n            help=\"[bold][blue](\ud83d\udd35 Special )[/blue][/bold] Enable the Depth of field effect\")] = \\\n            Field(default=False)\n\n        start: Annotated[float, Option(\"--start\", \"-a\",\n            help=\"[green](\ud83d\udfe2 Advanced)[/green] Effect starts at this depth distance\")] = \\\n            Field(default=0.6)\n\n        end: Annotated[float, Option(\"--end\", \"-b\",\n            help=\"[green](\ud83d\udfe2 Advanced)[/green] Effect ends at this depth distance\")] = \\\n            Field(default=1.0)\n\n        exponent: Annotated[float, Option(\"--exponent\", \"-t\", min=0, max=10,\n            help=\"[green](\ud83d\udfe2 Advanced)[/green] Effect depth exponent\")] = \\\n            Field(default=2.0)\n\n        intensity: Annotated[float, Option(\"--intensity\", \"-i\", min=0, max=2,\n            help=\"[green](\ud83d\udfe2 Advanced)[/green] Effect blur intensity\")] = \\\n            Field(default=1.0)\n\n        quality: Annotated[int, Option(\"--quality\", \"-q\", min=1, max=16,\n            help=\"[green](\ud83d\udfe2 Advanced)[/green] Effect blur quality (radial steps)\")] = \\\n            Field(default=4)\n\n        directions: Annotated[int, Option(\"--directions\", \"-d\",\n            help=\"[green](\ud83d\udfe2 Advanced)[/green] Effect blur quality (directions)\")] = \\\n            Field(default=16)\n\n        def pipeline(self) -&gt; Iterable[ShaderVariable]:\n            yield ShaderVariable(\"uniform\", \"bool\",  \"iDofEnable\",     bool(self.enable))\n            yield ShaderVariable(\"uniform\", \"float\", \"iDofStart\",      self.start)\n            yield ShaderVariable(\"uniform\", \"float\", \"iDofEnd\",        self.end)\n            yield ShaderVariable(\"uniform\", \"float\", \"iDofExponent\",   self.exponent)\n            yield ShaderVariable(\"uniform\", \"float\", \"iDofIntensity\",  self.intensity/100)\n            yield ShaderVariable(\"uniform\", \"int\",   \"iDofQuality\",    self.quality)\n            yield ShaderVariable(\"uniform\", \"int\",   \"iDofDirections\", self.directions)\n\n    _dof: _PFX_DOF = PrivateAttr(default_factory=_PFX_DOF)\n    \"\"\"Depth of Field Post-Processing configuration\"\"\"\n\n    @property\n    def dof(self) -&gt; _PFX_DOF:\n        return self._dof\n\n    # ---------------------------------------------------------------------------------------------|\n\n    class _PFX_Vignette(BaseModel):\n        \"\"\"Set vignette parameters [green](See 'vignette --help' for options)[/green]\"\"\"\n        enable: Annotated[bool, Option(\"--enable\", \"-e\",\n            help=\"[bold][blue](\ud83d\udd35 Special )[/blue][/bold] Enable the Vignette effect\")] = \\\n            Field(default=False)\n\n        intensity: Annotated[float, Option(\"--intensity\", \"-i\", min=0, max=100,\n            help=\"[green](\ud83d\udfe2 Advanced)[/green] Intensity of the Vignette effect\")] = \\\n            Field(default=30)\n\n        decay: Annotated[float, Option(\"--decay\", \"-d\", min=0, max=1,\n            help=\"[green](\ud83d\udfe2 Advanced)[/green] Decay of the Vignette effect\")] = \\\n            Field(default=0.1)\n\n        def pipeline(self) -&gt; Iterable[ShaderVariable]:\n            yield ShaderVariable(\"uniform\", \"bool\",  \"iVignetteEnable\",    self.enable)\n            yield ShaderVariable(\"uniform\", \"float\", \"iVignetteIntensity\", self.intensity)\n            yield ShaderVariable(\"uniform\", \"float\", \"iVignetteDecay\",     self.decay)\n\n    _vignette: _PFX_Vignette = PrivateAttr(default_factory=_PFX_Vignette)\n    \"\"\"Vignette Post-Processing configuration\"\"\"\n\n    @property\n    def vignette(self) -&gt; _PFX_Vignette:\n        return self._vignette\n\n    # ---------------------------------------------------------------------------------------------|\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        yield ShaderVariable(\"uniform\", \"float\", \"iDepthHeight\",    self.height)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDepthStatic\",    self.static)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDepthFocus\",     self.focus)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDepthInvert\",    self.invert)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDepthZoom\",      self.zoom)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDepthIsometric\", self.isometric)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDepthDolly\",     self.dolly)\n        yield ShaderVariable(\"uniform\", \"vec2\",  \"iDepthCenter\",    self.center)\n        yield ShaderVariable(\"uniform\", \"vec2\",  \"iDepthOrigin\",    self.origin)\n        yield ShaderVariable(\"uniform\", \"vec2\",  \"iDepthOffset\",    self.offset)\n        yield ShaderVariable(\"uniform\", \"bool\",  \"iDepthMirror\",    bool(self.mirror))\n        yield from self._dof.pipeline()\n        yield from self._vignette.pipeline()\n</code></pre>"},{"location":"depthflow/reference/state/#State.DepthState.height","title":"<code>height: Annotated[float, Option('--height', '-h', min=0, max=1, help=\"[bold][red](\ud83d\udd34 Basic   )[/red][/bold] Depthmap's peak value, the effect [bold][cyan]intensity[/cyan][/bold] [medium_purple3](The camera is 1 distance away from depth=0 at the z=1 plane)[/medium_purple3]\")] = Field(default=0.35)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.static","title":"<code>static: Annotated[float, Option('--static', '-s', min=0, max=1, help='[bold][red](\ud83d\udd34 Basic   )[/red][/bold] Focal depth plane of [bold][cyan]offsets[/cyan][/bold] [medium_purple3](A value of 0 makes the background stationary; and 1 for the foreground)[/medium_purple3]')] = Field(default=0.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.focus","title":"<code>focus: Annotated[float, Option('--focus', '-f', min=0, max=1, help='[bold][red](\ud83d\udd34 Basic   )[/red][/bold] Focal depth plane of [bold][cyan]perspective[/cyan][/bold] [medium_purple3](A value of 0 makes the background stationary; and 1 for the foreground)[/medium_purple3]')] = Field(default=0.5)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.zoom","title":"<code>zoom: Annotated[float, Option('--zoom', '-z', min=0, help='[bold][red](\ud83d\udd34 Basic   )[/red][/bold] Camera [bold][cyan]zoom factor[/cyan][/bold] [medium_purple3](2 means a quarter of the image is visible)[/medium_purple3]')] = Field(default=1.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.isometric","title":"<code>isometric: Annotated[float, Option('--isometric', '-iso', min=0, max=1, help='[bold][yellow](\ud83d\udfe1 Medium  )[/yellow][/bold] Isometric factor of [bold][cyan]camera projections[/cyan][/bold] [medium_purple3](Zero is fully perspective, 1 is orthographic)[/medium_purple3]')] = Field(default=0.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.dolly","title":"<code>dolly: Annotated[float, Option('--dolly', '-d', min=0, max=1, help='[bold][yellow](\ud83d\udfe1 Medium  )[/yellow][/bold] Same effect as --isometric, dolly zoom [medium_purple3](Move back ray projection origins by this amount)[/medium_purple3]')] = Field(default=0.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.invert","title":"<code>invert: Annotated[float, Option('--invert', '-inv', min=0, max=1, help='[bold][yellow](\ud83d\udfe1 Medium  )[/yellow][/bold] Interpolate depth values between (0=far, 1=near) and vice-versa, as in [bold][cyan]mix(height, 1-height, invert)[/bold][/cyan]')] = Field(default=0.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.mirror","title":"<code>mirror: Annotated[bool, Option('--mirror', '-m', ' /-n', help='[bold][yellow](\ud83d\udfe1 Medium  )[/yellow][/bold] Apply [bold][cyan]GL_MIRRORED_REPEAT[/cyan][/bold] to the image [medium_purple3](The image is mirrored out of bounds on the respective edge)[/medium_purple3]')] = Field(default=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.center_x","title":"<code>center_x: Annotated[float, Option('--center-x', '-cex', min=0, max=1, help=\"[green](\ud83d\udfe2 Advanced)[/green] Horizontal 'true' offset of the camera [medium_purple3](The camera *is* above this point)[/medium_purple3]\")] = Field(default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.center_y","title":"<code>center_y: Annotated[float, Option('--center-y', '-cey', min=0, max=1, help=\"[green](\ud83d\udfe2 Advanced)[/green] Vertical   'true' offset of the camera [medium_purple3](The camera *is* above this point)[/medium_purple3]\")] = Field(default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.center","title":"<code>center: Tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>'True' offset of the camera, the camera is above this point</p>"},{"location":"depthflow/reference/state/#State.DepthState.origin_x","title":"<code>origin_x: Annotated[float, Option('--origin-x', '-orx', help='[green](\ud83d\udfe2 Advanced)[/green] Horizontal focal point of the offsets [medium_purple3](*As if* the camera was above this point)[/medium_purple3]')] = Field(default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hozirontal focal point of the offsets, as if the camera was above this point</p>"},{"location":"depthflow/reference/state/#State.DepthState.origin_y","title":"<code>origin_y: Annotated[float, Option('--origin-y', '-ory', min=0, max=1, help='[green](\ud83d\udfe2 Advanced)[/green] Vertical   focal point of the offsets [medium_purple3](*As if* the camera was above this point)[/medium_purple3]')] = Field(default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.origin","title":"<code>origin: Tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Focal point of the offsets, as if the camera was above this point</p>"},{"location":"depthflow/reference/state/#State.DepthState.offset_x","title":"<code>offset_x: Annotated[float, Option('--offset-x', '-ofx', help='[green](\ud83d\udfe2 Advanced)[/green] Horizontal parallax displacement [medium_purple3](Change this over time for the 3D effect)[/medium_purple3]')] = Field(default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.offset_y","title":"<code>offset_y: Annotated[float, Option('--offset-y', '-ofy', help='[green](\ud83d\udfe2 Advanced)[/green] Vertical   parallax displacement [medium_purple3](Change this over time for the 3D effect)[/medium_purple3]')] = Field(default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.offset","title":"<code>offset: Tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Parallax displacement, change this over time for the 3D effect</p>"},{"location":"depthflow/reference/state/#State.DepthState.reset","title":"<code>reset() -&gt; None</code>","text":"Source code in <code>Projects/DepthFlow/DepthFlow/State.py</code> Python<pre><code>def reset(self) -&gt; None:\n    for object in (self, self._dof, self._vignette):\n        for name, field in object.model_fields.items(): # noqa\n            setattr(object, name, field.default)\n</code></pre>"},{"location":"depthflow/reference/state/#State.DepthState.dof","title":"<code>dof: _PFX_DOF</code>  <code>property</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.vignette","title":"<code>vignette: _PFX_Vignette</code>  <code>property</code>","text":""},{"location":"depthflow/reference/state/#State.DepthState.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/DepthFlow/DepthFlow/State.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    yield ShaderVariable(\"uniform\", \"float\", \"iDepthHeight\",    self.height)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDepthStatic\",    self.static)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDepthFocus\",     self.focus)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDepthInvert\",    self.invert)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDepthZoom\",      self.zoom)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDepthIsometric\", self.isometric)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDepthDolly\",     self.dolly)\n    yield ShaderVariable(\"uniform\", \"vec2\",  \"iDepthCenter\",    self.center)\n    yield ShaderVariable(\"uniform\", \"vec2\",  \"iDepthOrigin\",    self.origin)\n    yield ShaderVariable(\"uniform\", \"vec2\",  \"iDepthOffset\",    self.offset)\n    yield ShaderVariable(\"uniform\", \"bool\",  \"iDepthMirror\",    bool(self.mirror))\n    yield from self._dof.pipeline()\n    yield from self._vignette.pipeline()\n</code></pre>"},{"location":"get/","title":"\u2705 Installation","text":"<ul> <li>There are three ways to get started with the Projects:</li> </ul>"},{"location":"get/#from-pypi","title":"\ud83e\uddc0 From PyPI","text":"<p>The most reliable way to use the Projects</p> <ul> <li>Requires basic Python knowledge (and lurking)</li> <li>Direct Module CLI or as a dependency</li> </ul> <p><sup>Recommended for: Basic users, Advanced users, Developers</sup></p>"},{"location":"get/#from-source","title":"\ud83d\udd25 From Source","text":"<p>The most flexible way to use the Projects</p> <ul> <li>Automatic install scripts, spend more time using the projects</li> <li>Latest features, bugs, fixes, highly configurable</li> </ul> <p><sup>Recommended for: Advanced users, Contributors, Developers</sup></p>"},{"location":"get/#from-releases","title":"\ud83d\udce6 From Releases","text":"<p>The most convenient way to use the Projects</p> <ul> <li>Self-installing portable executable files</li> <li>Not as much configurable at the moment</li> </ul> <p><sup>Recommended for: Basic users</sup></p>"},{"location":"get/docker/","title":"Get/Docker","text":"<p>Docker is an platform for containerization of software, easy deployment and scalability</p> <p>Docker can't open native GUIs on the Host OS \u2022 The intended usage are:</p> <ul> <li>Implementing a backend e.g. with FastAPI</li> <li>Serving and acessing a Gradio web page</li> <li>Isolation, security or Headless usage</li> </ul> <p></p> <p>There are quite a lot of combinations in hardware<sup>1</sup>, platform and intention to use Docker</p> <ul> <li> <p>As this isn't an \"recommended\" method unless you know what you're doing, the instructions below are written for Developers and Advanced Users</p> </li> <li> <p>I don't use and know Docker best practices. Consider improving anything here!</p> </li> </ul>"},{"location":"get/docker/#installing","title":"\u26a1\ufe0f Installing","text":"<ul> <li>(Windows) Install WSL2, default Ubuntu 22.04 distro is fine     PowerShell<pre><code>wsl --install\n</code></pre><ul> <li>Preferably add an user with <code>sudo adduser &lt;username&gt;</code> (inside <code>wsl</code>)</li> <li>And make it default <code>ubuntu config --default-user &lt;username&gt;</code></li> </ul> </li> </ul> <ul> <li>Install Docker Desktop for your platform or Package Manager<ul> <li>Linux users might only want Docker Engine, per bloat and licensing model</li> <li>Windows: Enable <code>Settings &gt; Resources &gt; WSL Integration &gt; Default distro</code></li> </ul> </li> </ul> <ul> <li>(Linux) You might need to install Docker Compose if you distro splits it</li> </ul> <ul> <li>(NVIDIA) Install the NVIDIA Container Toolkit for your Distro<ul> <li>I don't have to say \"Have NVIDIA Drivers installed\", on the host system, do I?</li> <li>Windows: Follow the <code>apt</code> instructions on the link above, inside WSL</li> </ul> </li> </ul> <p>DO NOT INSTALL NVIDIA OR DISPLAY DRIVERS (MESA) ON THE WSL DISTRO PER NVIDIA DOCS</p> <p>Restart the Docker Engine:</p> <ul> <li>(Linux) Run <code>sudo systemctl restart docker</code> on the Terminal</li> <li>(Others) Close and open Docker Desktop on the System Tray</li> </ul> <p>(Windows) It may be a good idea to reboot the whole system</p> <ul> <li>Clone the Monorepo following the \ud83d\udd25 From Source/Manual page, until <code>rye sync</code></li> </ul>"},{"location":"get/docker/#context","title":"\ud83d\ude80 Context","text":"<p>Per Monorepo structure, I've configured a <code>.docker-compose.yml</code> file that builds a <code>base.dockerfile</code> with common dependencies, and hopefully OpenGL Acceleration. The other dockerfiles starts of at the end of this base image for the specific project</p> Have enough RAM and don't want to hurt your SSD's TBW? <p>Edit or create the file <code>sudo nano /etc/docker/daemon.json</code> and add: JSON<pre><code>{\n    \"data-root\": \"/tmp/docker\",\n    // ...\n}\n</code></pre></p> <p>Most Projects uses ModernGL for interfacing with OpenGL, that renders the Shaders. The Context creation is handled by glcontext, which selects the proper platform's API to use</p> What to avoid <p>Long story short, we want to avoid at maximum using x11 inside Docker and even on native Linux !. The code is feature-frozen but with many technical debts, requires a real \"Display\" for Graphics APIs (OpenGL, Vulkan) to even work, and there is no headless mode</p> <ul> <li>One might think that prepending the commands with xvfb-run could work, but this will always use Software Rendering, which happens entirely on the CPU - a fraction of the speed of a GPU. So, we want to avoid xvfb at all costs</li> </ul> <p>This isn't an issue per se when running natively, as OpenGL Contexts created on a live Desktop Environment WILL have GPU Acceleration via GLX, provided by the current driver. Or EGL itself, if we're running Wayland</p> Why we want EGL <p>Luckily, Khronos Group developed EGL, and NVIDIA the libglvnd libraries. Together, EGL provides context creation directly on OpenGL without relying on WGL/CGL/GLX, so we can have true GPU accelerated headless contexts, and libglvnd a vender-neutral dispatch for so</p> <p>Well, not so fast. That is, if the available devices are GPUs themselves. It is well known that NVIDIA provides their own Proprietary Drivers and firmware for their GPUs, with shared libraries (`.so` files on Linux, `.dll` on Windows) pointing to their driver's libraries; while AMD and Intel GPUs on Linux runs the Godly Mesa Project. Mesa always at least provides <code>llvmpipe</code> device, which is a Software Rendering fallback device</p> Native Linux vs WSL <p>Now, here's where it gets tricky. Docker is running a virtualized Linux machine always, but inside a pseudo-native Linux in WSL (three layers lol). The previously installed NVIDIA Container Toolkit deals with both cases slightly differently:</p> <ul> <li> <p>On Windows, the NVIDIA drivers used are from the Host (Windows itself), \"redirected\" to WSL. The wrapped binaries are found at <code>/usr/lib/wsl</code> on the WSL distro, provided by the container toolkit This is why no drivers should be installed on WSL. The <code>llvmpipe</code> device can be a pointer to <code>d3d12.so</code> file with actual GPU Acceleration</p> </li> <li> <p>On Linux, the NVIDIA drivers used are from the Host (Linux itself), directly. The files are found on regular <code>/usr/lib</code> location, provided by the container toolkit wrapping the host's drivers. No sketchy, <code>llvmpipe</code> is always software and a GPU device shows up</p> </li> </ul> But why is this important? <p>If anything goes wrong in this complicated soup of shared libraries, your rendering speeds won't be 290 fps, but 40, 20, 5 fps at maximum, without utilizing GPU</p> <ul> <li> <p>The fun thing is that <code>/usr/lib/wsl</code> isn't mapped automatically to Docker on WSL \ud83e\udd21</p> </li> <li> <p>Getting EGL to work on Cloud Providers can be tricky \ud83c\udf88</p> </li> </ul> Talk is cheap, show me the code <p>Thankfully, we have <code>nvidia/opengl:1.2-glvnd-runtime-ubuntu22.04</code> image to start with</p> <p>We absolutely need to set those env vars:</p> Docker<pre><code>ENV NVIDIA_VISIBLE_DEVICES=\"all\"\nENV NVIDIA_DRIVER_CAPABILITIES=\"all\"\n</code></pre> <p>Additionally, for ShaderFlow to use EGL, and not GLFW, set</p> Docker<pre><code># Can disable with WINDOW_EGL=0 (sends backend=None to Window class)\nENV WINDOW_BACKEND=\"headless\"\n\n# Alternatively, use shaderflow scene class args\nscene = ShaderScene(backend=\"headless\")\n</code></pre> <p>For pure ModernGL users:</p> <p>Sending <code>backend=\"headless\"</code> is the same as using the <code>moderngl_window.context.headless.Window</code> class, alongside sending a <code>backend=\"egl\"</code> kwarg to that Window class initialization if <code>$WINDOW_EGL</code> is <code>\"1\"</code></p> <p>Almost done, but there's some CLI args to go:</p> <ul> <li> <p>On Any platform, we must add <code>--gpus all</code> to the Docker Engine's CLI for finding GPUs If running from the configured `docker-compose.yml`, this is already configured</p> </li> <li> <p>On Windows, due the <code>d3d12.so</code> lib hack, we must add <code>-v /usr/lib/wsl:/usr/lib/wsl</code> to the Docker Engine's CLI Already configured on `docker-compose.yml`. That makes so we map the WSL's libraries of the Host OS's Drivers to Docker virtualized OS</p> </li> </ul> Checking stuff is working <p>I've configured a Dockerfile for you to test your setup. Check its output messages:</p> Terminal<pre><code>docker-compose run --build glinfo\n</code></pre> <p>If everything is nominal until now, you've probably got a healthy setup \ud83c\udf89</p> <p>For reference, here's the final Base Dockerfile and docker-compose.yml files</p>"},{"location":"get/docker/#usage","title":"\u2b50\ufe0f Usage","text":"<p>Before you start, now that I've got your attention</p> <p>If you're making a Software as a Service (SaaS) backend of any Project, consider getting in touch with me, so we can make both sides grow together and help each other \ud83d\udc4d</p> <p>This page helped you?</p> <p>Consider Joining my Sponsors and helping me continue everything !</p> All of that.. <p>..was just for saying I've suffered and automated enough, so you can simply run:</p> Terminal<pre><code># Torch CPU already managed \ud83d\ude09\ndocker-compose run --build depthflow\n\n# Somehow, faster than native linux?\ndocker-compose run --build shaderflow\n</code></pre> <p>Funcionality is limited</p> <p>You're expeceted to upload your own <code>.py</code> files in a separate Dockerfile (recommended), or edit the ones currently at <code>Docker/Scripts/*.py</code> for your current intentions (anti-pattern)</p> <p>In the future, there will be <code>$project-gradio</code> runnable images</p> Your own Dockerfile <p>You can also build the <code>Docker/base.dockerfile</code> as <code>-t broken-base</code> and base off of it in yours dockerfiles with <code>FROM broken-base:latest</code> locally</p> <ul> <li>Not much different from how it works now:</li> </ul> Docker<pre><code>FROM broken-base:latest\nCMD [\"python3\", \"Docker/Scripts/depthflow.py\"]\n</code></pre> <p>This way, no reinstall is required, and you have everything available right away</p> <p></p> <ol> <li> <p>Untested on AMD Radeon, Intel iGPU, Intel ARC. Your mileage may vary, here be dragons !\u00a0\u21a9</p> </li> </ol>"},{"location":"get/pypi/","title":"Get/PyPI","text":"<p>The most reliable way to use the Projects \u2022 As a dependency or direct module CLI</p> <p>Recommended for: Basic users, Advanced users, Developers</p>"},{"location":"get/pypi/#installing","title":"\u26a1\ufe0f Installing","text":"<p>All Projects have their own independent package</p> <p>Install the Package</p>  Pip Poetry Rye PDM Command<pre><code>python -m pip install {package}\n</code></pre> Command<pre><code>python -m poetry add {package}\n</code></pre> Command<pre><code>rye add {package}\n</code></pre> Command<pre><code>pdm add {package}\n</code></pre> <p>...where <code>{package}</code> is the name of the project you want to install:</p> <ul> <li><code>depthflow</code>, <code>shaderflow</code>, <code>broken-source</code>, <code>pianola</code>, <code>spectronote</code>, <code>turbopipe</code></li> </ul>"},{"location":"get/pypi/#usage","title":"\u2b50\ufe0f Usage","text":"<p>After Installing the Package, you can simply import it in your Code</p> Example with DepthFlow<pre><code>from DepthFlow import DepthScene\n\ndepthflow = DepthScene()\ndepthflow.input(image=\"./background.png\")\ndepthflow.main(output=\"./video.mp4\", ...)\n</code></pre> <p>.. or run its command line interface:</p> Terminal<pre><code># You can also use 'depthflow' instead of 'python -m DepthFlow'\npython -m DepthFlow input -i ./background.png main -o ./video.mp4\n</code></pre> <ul> <li>For more, go to the project tab of your interest above and see its usage</li> </ul>"},{"location":"get/pypi/#upgrading","title":"\ud83d\ude80 Upgrading","text":"<p>Simply upgrade the dependency on your Python project</p>  Pip Poetry Rye PDM Command<pre><code>python -m pip install --upgrade {package}\n</code></pre> Command<pre><code>python -m poetry update {package}\n</code></pre> Command<pre><code>rye add {package}\n</code></pre> Command<pre><code>pdm update {package}\n</code></pre> <p>Consider staying on a fixed version if you need stability</p> <p>Small or breaking parts of the code can be changed on any new release</p> <ul> <li>Define <code>{package}==X.Y.Z</code> in <code>pyproject.toml</code> to pin it</li> </ul>"},{"location":"get/pypi/#uninstalling","title":"\u267b\ufe0f Uninstalling","text":"<p>See the Uninstalling page</p>"},{"location":"get/pytorch/","title":"Get/PyTorch","text":"<p>Some projects have Optional or Total Dependency on PyTorch</p>"},{"location":"get/pytorch/#from-source","title":"\ud83d\udd25 From Source","text":"<p>When a project requires PyTorch, a Prompt will pop up to install a flavor automatically</p> <ul> <li>Alternatively, when inside the Virtual Environment, choose one below and run:</li> </ul> <p>1. Select your Platform</p>  Windows Linux MacOS <p></p>  NVIDIA (CUDA) Radeon (ROCm) Arc (OneAPI) Any (CPU) Command<pre><code>poe cuda\n</code></pre> <p>Have the NVIDIA Drivers installed</p> <p>AMD doesn't support ROCm on Windows yet</p> <p>It is supported on Linux, consider trying it there!</p> <p>Please use CPU installation for now</p> <p>Help needed, I don't have the Hardware to test</p> <p>Please use CPU installation for now</p> Command<pre><code>poe cpu\n</code></pre> <p>Slow option, but works on any System</p> <p></p>  NVIDIA (CUDA) Radeon (ROCm) Arc (OneAPI) Any (CPU) Command<pre><code>poe cuda\n</code></pre> <p>Have the NVIDIA Proprietary Drivers packages installed in your Distro</p> Command<pre><code>poe rocm\n</code></pre> <p>Have the Mesa Drivers and ROCm packages installed in your Distro</p> <p>Requires RX 5000 series or Newer. Set <code>HSA_OVERRIDE_GFX_VERSION=10.3.0</code> for (&gt;= RX 5000)</p> <p>Help needed, I don't have the Hardware to test</p> <p>Please use CPU installation for now</p> Command<pre><code>poe cpu\n</code></pre> <p>Slow option, but works on any System</p> <p> Command<pre><code>poe base\n</code></pre></p> <p>Should work, but I don't have the Hardware to test</p>"},{"location":"get/pytorch/#from-pypi","title":"\ud83e\uddc0 From PyPI","text":"<p>Specify a PyTorch version in <code>pyproject.toml</code> on the Python package manager that you use. Or do what I do: use poethepoet for the user's choice (or automate it)</p> <ul> <li>PyTorch is hard to deal with, I can't write exhaustively</li> </ul>"},{"location":"get/releases/","title":"Get/Releases","text":"<p>The most convenient way to use the Projects \u2022 Double-click and run, hopefully</p> <p>Recommended for: Basic users</p>"},{"location":"get/releases/#installing","title":"\u26a1\ufe0f Installing","text":"<p>I make self-installing executables using PyApp for your convenience!</p> <p>Select your Platform</p>  Windows Linux MacOS <p> Project  Any (CPU)  NVIDIA (CUDA)  Radeon (ROCm) \ud83c\udf0a DepthFlow  CPU  CUDA  ROCm \ud83d\udd25 ShaderFlow  Download \ud83c\udfb9 Pianola  Download \ud83c\udfa7 SpectroNote  Download </p> <p> Project  Any (CPU)  NVIDIA (CUDA)  Radeon (ROCm) \ud83c\udf0a DepthFlow  CPU  CUDA  ROCm \ud83d\udd25 ShaderFlow  Download \ud83c\udfb9 Pianola  Download \ud83c\udfa7 SpectroNote  Download </p> <p> Project Apple Silicon (ARM64) \ud83c\udf0a DepthFlow  CPU \ud83d\udd25 ShaderFlow  Download \ud83c\udfb9 Pianola  Download \ud83c\udfa7 SpectroNote  Download </p> <p>Help needed, I don't have the Hardware to test Apple Silicon builds</p> <p>Customization options are limited at the moment. Prefer From Source or From PyPI</p>"},{"location":"get/releases/#usage","title":"\u2b50\ufe0f Usage","text":"<p>Simply double click and run the executable on your platform</p> <ul> <li>Preferably Open it on a Terminal, for example:</li> </ul> Terminal<pre><code>./shaderflow-linux-amd64-0.3.1.bin default -o ./video.mp4\n</code></pre> <p>Not all projects have a default \"visible\" behavior</p> <p>Projects like ShaderFlow requires a Scene name to be sent as a argument:</p> <ul> <li>When no arguments are sent, the behavior is to list all Scenes and quit</li> <li>The immediate interpretation is that it crashed, when it ran fine</li> </ul> <p>Projects like DepthFlow have a default configuration and implicitly call the Scene's <code>main</code></p> <ul> <li> <p>To select your own image, run as CLI, e.g. <code>depthflow input -i ./image.png main -o ./video.mp4</code></p> </li> <li> <p>Downloading the models on the first execution takes a while, progress is seen running on Terminal</p> </li> </ul>"},{"location":"get/releases/#upgrading","title":"\ud83d\ude80 Upgrading","text":"<p>Download a newer release from GitHub or from your Package Manager</p>"},{"location":"get/releases/#uninstalling","title":"\u267b\ufe0f Uninstalling","text":"<p>See the Uninstalling page</p>"},{"location":"get/source/","title":"Get/Source","text":"<p>The most flexible way to use the Projects \u2022 Latest features, bugs, fixes, git clone</p> <p>Recommended for: Advanced users, Contributors, Developers</p>"},{"location":"get/source/#installing","title":"\u26a1\ufe0f Installing","text":"<p>Running any of my Projects takes only two commands</p> <p>1. Select your Platform</p>  Windows Linux MacOS Manual <p></p> <p>Open some folder to download the code on Windows Explorer</p> <ul> <li>Press Ctrl+L , run <code>powershell</code> and execute:</li> </ul> PowerShell<pre><code># How it works: 'irm' downloads, 'iex' executes, '|' links the two\nirm https://brokensrc.dev/get.ps1 | iex\n</code></pre> Read what <code>get.ps1</code> does PowerShell<pre><code>#!/usr/bin/env pwsh\n\n&lt;# Kudos for your cautiousness in checking out the script before running it !\n\n    The script does the following:\n\n    - Install Winget if not found: The official Microsoft's Package Manager\n    - Install Git and Rye using Winget: To download the Projects and manage Python\n    - Add Rye shims to PATH: So that 'rye' command is available in the shell\n    - Clone the BrokenSource Monorepo\n    - Create a Virtual Environment and install dependencies\n    - Spawn a new shell in the Virtual Environment\n#&gt;\n\n# This function reloads the \"PATH\" environment variable so that we can\n# find newly installed applications on the same script execution\nfunction Reload-Path {\n    $wingetPath  = $env:LocalAppData + \"\\Microsoft\\WindowsApps\"\n    $machinePath = [System.Environment]::GetEnvironmentVariable(\"Path\", \"Machine\")\n    $userPath    = [System.Environment]::GetEnvironmentVariable(\"Path\", \"User\")\n    $env:Path    = $machinePath + \";\" + $userPath + \";\" + $wingetPath\n}\n\n# Consistency in showing steps\nfunction Print-Step {\n    echo \"`n:: $args`n\"\n}\n\n# Option to continue normally even on errors\nfunction Ask-Continue {\n    echo \"`nPress Enter to continue normally, or Ctrl+C to exit\"\n    Read-Host\n}\n\n# This function immediately exits if Winget is found, else it tries to install it with\n# the official Microsoft docs 'Add-AppxPackage' method. If it still fails, it tries\n# to download the Appx package (.msibundle) and install it manually.\nfunction Have-Winget {\n    Reload-Path\n    if ((Get-Command winget -ErrorAction SilentlyContinue)) {\n        return\n    }\n\n    Print-Step \"Installing Winget\"\n\n    # Try installing with Add-AppxPackage\n    Add-AppxPackage -RegisterByFamilyName -MainPackage Microsoft.DesktopAppInstaller_8wekyb3d8bbwe\n    Reload-Path\n\n    # Attempt manual method if still not found\n    if (-not (Get-Command winget -ErrorAction SilentlyContinue)) {\n        echo \"Winget installation with Add-AppxPackage failed, trying 'manual' method..\"\n        Print-Step \"Downloading Winget installer, might take a while.\"\n\n        # Why tf does disabling progress bar yields 50x faster downloads????? https://stackoverflow.com/a/43477248\n        $msi=\"https://github.com/microsoft/winget-cli/releases/download/v1.7.10582/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle\"\n        $tempFile = [System.IO.Path]::GetTempPath() + \"\\winget.msixbundle\"\n        $ProgressPreference = 'SilentlyContinue'\n        Invoke-WebRequest -Uri $msi -OutFile $tempFile\n\n        # Install the Appx package\n        echo \"Finished download, now installing it..\"\n        Add-AppxPackage -Path $tempFile\n        Reload-Path\n    }\n\n    # If Winget is still not available, exit\n    if (-not (Get-Command winget -ErrorAction SilentlyContinue)) {\n        Print-Step \"Winget was not found, and installation failed with Add-AppxPackage\"\n        echo \"Winget was installed but still not found. Probably a Path issue or installation failure\"\n        echo \"&gt; Please get it at https://learn.microsoft.com/en-us/windows/package-manager/winget\"\n        echo \"&gt; Alternatively, install manually what previously failed\"\n        Ask-Continue\n    }\n}\n\n# Install Git\nif (-not (Get-Command git -ErrorAction SilentlyContinue)) {\n    Print-Step \"Git was not found, installing with Winget\"\n    Have-Winget\n    winget install -e --id Git.Git\n    Reload-Path\n    if (-not (Get-Command git -ErrorAction SilentlyContinue)) {\n        Print-Step \"Git was not found, and installation failed with Winget\"\n        echo \"Git was installed but still not found. Probably a Path issue or installation failure\"\n        echo \"&gt; Please get it at https://git-scm.com\"\n        Ask-Continue\n    } else {\n        echo \"Git was installed successfully\"\n    }\n}\n\n# Install Rye\nif (-not (Get-Command rye -ErrorAction SilentlyContinue)) {\n    Print-Step \"Rye was not found, installing with Winget\"\n    Have-Winget\n    winget install --id=Rye.Rye -e\n    Reload-Path\n    if (-not (Get-Command rye -ErrorAction SilentlyContinue)) {\n        Print-Step \"Rye was not found, and installation failed with Winget\"\n        echo \"Rye was installed but still not found. Probably a Path issue or installation failure\"\n        echo \"&gt; Please get it at https://rye.astral.sh\"\n        Ask-Continue\n    } else {\n        echo \"Rye was installed successfully\"\n    }\n}\n\n# Add %USERPROFILE%\\.rye\\shims to PATH permanently if not there\n# This is where the main 'rye' tool is located, make it available\n$ryePath = $env:USERPROFILE + \"\\.rye\\shims\"\nif ($env:Path -notlike \"*$ryePath*\") {\n    Print-Step \"Adding Rye Shims to PATH as it was not found\"\n    [System.Environment]::SetEnvironmentVariable(\"Path\", $env:Path + \";\" + $ryePath, \"User\")\n    Reload-Path\n}\n\nReload-Path\n\n# # Clone the Repositories, Install Python Dependencies on venv and Spawn a new Shell\n\n# Skip cloning if already on a cloned directory\nif (-not (Test-Path -Path \"Broken\")) {\n    Print-Step \"Cloning BrokenSource Repository and all Submodules\"\n    git clone https://github.com/BrokenSource/BrokenSource --recurse-submodules --jobs 4\n    cd BrokenSource\n\n    Print-Step \"Checking out main branch for all submodules\"\n    git submodule foreach --recursive 'git checkout main || true'\n} else {\n    Print-Step \"Already in a Cloned Directory, Skipping Cloning\"\n}\n\nPrint-Step \"Creating Virtual Environment and Installing Dependencies\"\nrye self update\nrye config --set-bool behavior.autosync=true\nrye config --set-bool behavior.use-uv=true\nrye config --set-bool global-python=false\nrye sync\n\nPrint-Step \"Spawning a new Shell in the Virtual Environment\"\npowershell -NoLogo -NoExit -File .\\.venv\\Scripts\\Activate.ps1\n</code></pre> Enable Developer Mode for a Better Experience <p>To have Folder Shortcuts (Symbolic Links) to the Project's Workspace Directory (Data, Downloads, Config, etc) where the Source Code is, please enable Developer Mode on Windows Settings per Rye FAQ.</p> <ul> <li>This will also drastically speed up Virtual Environment creation</li> </ul> <p></p> <p>Open a Terminal on some directory and run</p> Terminal<pre><code>/bin/bash -c \"$(curl -sS https://brokensrc.dev/get.sh)\"\n</code></pre> Read what <code>get.sh</code> does PowerShell<pre><code>#!/bin/bash\n\n{ # Prevent execution if partially downloaded\n\n# Find 'git', exit if not found\ngit=\"\"\nif [ -x \"$(command -v git)\" ]; then\n  git=$(readlink -f $(which git))\n  echo \"\u2022 Found Git at ($git)\"\nelse\n  echo \"\u2022 Git wasn't found, please get it at (https://git-scm.com)\"\n  exit 1\nfi\n\n# Find 'rye', install if not found\nrye=\"\"\nfor attempt in $(seq 1 2); do\n  if [ -x \"$(command -v rye)\" ]; then\n    rye=$(readlink -f $(which rye))\n    echo \"\u2022 Found Rye at ($rye)\"\n    break\n  fi\n\n  if [ $attempt -eq 2 ]; then\n    echo \"Rye wasn't found after an installation attempt\"\n    echo \"\u2022 Do you have the Shims directory on PATH?\"\n    echo \"\u2022 Try restarting the Shell and retrying\"\n    echo \"\u2022 Get it at (https://rye.astral.sh)\"\n    exit 1\n  fi\n\n  echo \"\u2022 Rye wasn't found, will attempt to install it\"\n  export RYE_TOOLCHAIN_VERSION=\"cpython@3.11\"\n  export RYE_INSTALL_OPTION=\"--yes\"\n  export RYE_NO_AUTO_INSTALL=1\n  /bin/bash -c \"$(curl -sSf https://rye.astral.sh/get)\"\ndone\n\n# # Clone the Repositories, Install Python Dependencies on venv and Spawn a new Shell\n\n# Only clone if not already on a BrokenSource Repository\nif [ ! -d \"Broken\" ]; then\n  printf \"\\n:: Cloning BrokenSource Repository and all Submodules\\n\\n\"\n  $git clone https://github.com/BrokenSource/BrokenSource --recurse-submodules --jobs 4\n  cd BrokenSource\n\n  printf \"\\n:: Checking out main branch for all submodules\\n\"\n  $git submodule foreach --recursive 'git checkout main || true'\nelse\n  printf \"\\n:: Already on a BrokenSource Repository\\n\"\nfi\n\n# Make scripts executable for later use\nchmod +x Website/get.sh\nchmod +x ./Scripts/activate.sh\n\nprintf \"\\n:: Creating Virtual Environment and Installing Dependencies\\n\"\n$rye self update\n$rye config --set-bool behavior.autosync=true\n$rye config --set-bool behavior.use-uv=true\n$rye config --set-bool global-python=false\n$rye sync\n\nprintf \"\\n:: Spawning a new Shell in the Virtual Environment\\n\"\nsource .venv/bin/activate\nexec $SHELL\n\n}\n</code></pre> <p></p> <p>Open a Terminal on some directory and run</p> Terminal<pre><code>/bin/bash -c \"$(curl -sS https://brokensrc.dev/get.sh)\"\n</code></pre> Read what <code>get.sh</code> does PowerShell<pre><code>#!/bin/bash\n\n{ # Prevent execution if partially downloaded\n\n# Find 'git', exit if not found\ngit=\"\"\nif [ -x \"$(command -v git)\" ]; then\n  git=$(readlink -f $(which git))\n  echo \"\u2022 Found Git at ($git)\"\nelse\n  echo \"\u2022 Git wasn't found, please get it at (https://git-scm.com)\"\n  exit 1\nfi\n\n# Find 'rye', install if not found\nrye=\"\"\nfor attempt in $(seq 1 2); do\n  if [ -x \"$(command -v rye)\" ]; then\n    rye=$(readlink -f $(which rye))\n    echo \"\u2022 Found Rye at ($rye)\"\n    break\n  fi\n\n  if [ $attempt -eq 2 ]; then\n    echo \"Rye wasn't found after an installation attempt\"\n    echo \"\u2022 Do you have the Shims directory on PATH?\"\n    echo \"\u2022 Try restarting the Shell and retrying\"\n    echo \"\u2022 Get it at (https://rye.astral.sh)\"\n    exit 1\n  fi\n\n  echo \"\u2022 Rye wasn't found, will attempt to install it\"\n  export RYE_TOOLCHAIN_VERSION=\"cpython@3.11\"\n  export RYE_INSTALL_OPTION=\"--yes\"\n  export RYE_NO_AUTO_INSTALL=1\n  /bin/bash -c \"$(curl -sSf https://rye.astral.sh/get)\"\ndone\n\n# # Clone the Repositories, Install Python Dependencies on venv and Spawn a new Shell\n\n# Only clone if not already on a BrokenSource Repository\nif [ ! -d \"Broken\" ]; then\n  printf \"\\n:: Cloning BrokenSource Repository and all Submodules\\n\\n\"\n  $git clone https://github.com/BrokenSource/BrokenSource --recurse-submodules --jobs 4\n  cd BrokenSource\n\n  printf \"\\n:: Checking out main branch for all submodules\\n\"\n  $git submodule foreach --recursive 'git checkout main || true'\nelse\n  printf \"\\n:: Already on a BrokenSource Repository\\n\"\nfi\n\n# Make scripts executable for later use\nchmod +x Website/get.sh\nchmod +x ./Scripts/activate.sh\n\nprintf \"\\n:: Creating Virtual Environment and Installing Dependencies\\n\"\n$rye self update\n$rye config --set-bool behavior.autosync=true\n$rye config --set-bool behavior.use-uv=true\n$rye config --set-bool global-python=false\n$rye sync\n\nprintf \"\\n:: Spawning a new Shell in the Virtual Environment\\n\"\nsource .venv/bin/activate\nexec $SHELL\n\n}\n</code></pre> <p></p> <ul> <li>Install Git and Rye on your Platform</li> </ul> <p>Clone the Monorepo and all Submodules<pre><code>git clone https://github.com/BrokenSource/BrokenSource --recurse-submodules --jobs 4\n</code></pre> Enter the Monorepo directory<pre><code>cd BrokenSource\n</code></pre> Checkout all Submodules to the main branch<pre><code>git submodule foreach --recursive 'git checkout main || true'\n</code></pre> Create the main Virtual Environment and Install Dependencies<pre><code>rye sync\n</code></pre> Activate the main Virtual Environment<pre><code># Windows:\n.venv\\Scripts\\Activate.ps1 # PowerShell\n.venv\\Scripts\\Activate.bat # CMD\n\n# Linux and MacOS:\nsource .venv/bin/activate # Bash\nsource .venv/bin/activate.fish # Fish\n</code></pre> Start using any Project<pre><code>broken\nshaderflow\ndepthflow\n</code></pre></p> Something Failed? <p>Try following the Manual Instructions Tab above, else Get in Touch with me, preferably Discord</p> <ul> <li>Please, show some effort or try solving the problem first, often you'll get it :)</li> </ul> <p>2. Run any Project</p> <p>Now, simply run <code>broken</code> for a full command list, and to check if the setup is ok \ud83d\ude80</p> <ul> <li>Start using projects directly, like <code>depthflow main</code>, <code>shaderflow</code>, etc</li> <li>Return the project you're interested for further instructions</li> </ul> <p>Next time, to use the projects</p> <p>You just have to Open a Terminal on the BrokenSource directory and Source the Virtual Environment</p> <ul> <li>For that, run <code>Scripts/activate.sh</code> if on Linux/MacOS or <code>Scripts/activate.ps1</code> if on Windows</li> <li>Or manually with <code>source .venv/bin/activate</code> or <code>.venv\\Scripts\\Activate.ps1</code></li> </ul> <p></p>"},{"location":"get/source/#upgrading","title":"\ud83d\ude80 Upgrading","text":""},{"location":"get/source/#repositories","title":"\ud83c\udf31 Repositories","text":"<p>The installation script should've initialized and set all submodules to the main branch:</p> Command<pre><code>git submodule foreach --recursive 'git checkout main || true'\n</code></pre> <p>After that, you can pull the latest changes of all repositories with:</p> Command<pre><code>git pull --recurse-submodules --jobs=4\n</code></pre> <p>If you have any local changes</p> <ul> <li>Keep them: Add <code>--rebase</code> to the command above</li> <li>Delete them: Add <code>--force</code> to the command above</li> </ul>"},{"location":"get/source/#packages","title":"\ud83c\udf31 Packages","text":"<p>The Python tooling I'm using to orchestrate the Monorepo is Rye</p> <ul> <li>You'll probably only need to know of a single command:</li> </ul> <p>Command: <code>rye sync</code></p> <p>This will update the Virtual Environment and install any new dependencies</p> <p>After that, just activate the venv and you're good to go!</p>"},{"location":"get/source/#uninstalling","title":"\u267b\ufe0f Uninstalling","text":"<p>See the Uninstalling page</p>"},{"location":"get/uninstalling/","title":"Get/Uninstalling","text":"<p>Thanks for using Broken Source Software, I hope you found it useful \u2764\ufe0f</p> <ul> <li>Here's a exhaustive list of places you'll find all Project data:</li> </ul>"},{"location":"get/uninstalling/#runtime-data","title":"\u2705 Runtime Data","text":"<p>Project Workspaces: Where Cache, Data, etc are stored</p> <p>The main Library uses AppDirs to decide per-platform directories</p> <p>For unification, all project's Workspaces are located at your Platform's User Data directory, followed by a AppAuthor and AppName subdirectories, which will be BrokenSource and ProjectName in most cases</p> <ul> <li>Linux: <code>~/.local/share/BrokenSource/AppName/*</code></li> <li>Windows: <code>%localappdata%\\BrokenSource\\AppName\\*</code></li> <li>MacOS: <code>~/Library/Application Support/BrokenSource/AppName/*</code></li> </ul> <p>PyTorch Models: HuggingFace, TorchHub, Transformers</p> <p>You may find cache directories, if the project uses PyTorch, for Neural Network models at your Platform's Cache directory (or the one managed by any of those tools), usually found at:</p> <ul> <li>Linux: <code>~/.cache/{huggingface,transformers,torch}/*</code></li> <li>Windows: <code>%localappdata%\\{huggingface,transformers,torch}\\*</code></li> <li>MacOS: <code>~/Library/Caches/{huggingface,transformers,torch}/*</code></li> </ul>"},{"location":"get/uninstalling/#virtual-environment","title":"\ud83d\udc0d Virtual Environment","text":"<p>Where Dependencies are installed</p> <p>Depending on what Package Manager you use (\u26a0\ufe0f Rye is used on the From Source installation), you'll find the Python Virtual Environment in a couple different places:</p>  Pip Poetry Rye PDM <p>Manual method, you either created it yourself with <code>python -m venv (path)</code> or it's located at the System Site Packages for your Platform. It's a BAD IDEA to remove the later, so <code>pip uninstall {packages}</code></p> <p>Poetry, by default, installs venvs at your Platform's Cache directory:</p> <ul> <li>Linux: <code>~/.cache/pypoetry/virtualenvs/*</code></li> <li>Windows: <code>%localappdata%\\pypoetry\\virtualenvs\\*</code></li> <li>MacOS: <code>~/Library/Caches/pypoetry/virtualenvs/*</code></li> </ul> <p>Rye creates Virtual Environments on the <code>.venv</code> directory on the Monorepo root or your Project's</p> <p>PDM creates Virtual Environments on the <code>.venv</code> directory on the Monorepo root or your Project's</p>"},{"location":"get/uninstalling/#from-releases","title":"\ud83d\udce6 From Releases","text":"<p>Where the executables manages themselves</p> <p>PyApp stores cache, installs packages, creates venv on:</p> <ul> <li>Linux: <code>~/.local/share/pyapp</code></li> <li>Windows: <code>%applocaldata%\\pyapp</code></li> <li>MacOS: <code>~/Library/Application Support/pyapp</code></li> </ul>"},{"location":"get/uninstalling/#package-manager-cache","title":"\ud83d\udd2e Package Manager Cache","text":"<p>Where download cache is located</p> <p>Depending on what Python Package Manager you use, you may find cache directories at:</p> <ul> <li>Linux: <code>~/.cache/{pip,uv,poetry,pdm}/*</code></li> <li>Windows: <code>%localappdata%\\{pip,uv,poetry,pdm}\\*</code></li> <li>MacOS: <code>~/Library/Caches/{pip,uv,poetry,pdm}/*</code></li> </ul>"},{"location":"include/install/","title":"Install","text":"<p>Unified Installation</p> <p>Follow the main Installation Guide, then continue from here</p>"},{"location":"news/2024/v0.2.0/","title":"<b>Release v0.2.0</b>","text":"<p>ShaderFlow:</p> <ul> <li> <p>Fixes for True Headless rendering with <code>SHADERFLOW_BACKEND=headless</code> on Linux servers by using EGL backend on glcontext of the ModernGL Window, so <code>xvfb-run</code>/X11 is no longer needed, and GPU acceleration should work</p> </li> <li> <p>Mechanism to enforce Aspect Ratio on Scenes:</p> <ul> <li>Without AR, keep previous resolution and override <code>-w</code> or <code>-h</code></li> <li>With AR, when one component is sent, calculate the other,-</li> <li>If both are sent, calculates height based on width (prioritizes)</li> <li>Option to limit to a maximum resolution (often the Monitor size)</li> <li>Rounds to nearest multiple of two, so FFmpeg is happy</li> </ul> </li> <li> <p>Performance improvements:</p> <ul> <li>The final Fractional SSAA Shader doesn't need the full pipeline</li> <li>Pre-allocate a Buffer to copy each rendered frame to when exporting, to avoid the creation of a temporary <code>bytes</code> object</li> <li>Mystery: Threaded pipes to FFmpeg subprocess on Linux are wayy faster than single threaded, even though they perform a COPY on each new frame and the subprocess stdin is a <code>BufferedIO</code>. Windows performance is comparable to Linux with synchronous code, as expected</li> </ul> </li> </ul> <p>DepthFlow:</p> <ul> <li>Now applies the new AR enforcing on loaded images resolution</li> <li>All of ShaderFlow above applies</li> </ul> <p>Known Issues:</p> <ul> <li>AttributeError on BrokenPath in Python 3.12</li> </ul> <p>Fixes:</p> <ul> <li>Added <code>cmake</code> to <code>[build-system.requires]</code> for <code>samplerate</code></li> </ul>"},{"location":"news/2024/v0.2.1/","title":"<b>Release v0.2.1</b>","text":"<p>ShaderFlow:</p> <ul> <li>Make <code>samplerate</code> dependency optional on <code>ShaderSpectrogram</code>, when <code>sample_rateio!=1</code>, now Linux shouldn't need C++ compilers to be installed on Python 3.10 or 3.11</li> </ul> <p>SpectroNote:</p> <ul> <li>Don't resample audio - generally speaking, no information is gained</li> </ul> <p>Fixes:</p> <ul> <li>Move staging/future dependencies to optional groups</li> <li>Fix Python 3.12 AttributeError of BrokenPath</li> </ul>"},{"location":"news/2024/v0.3.0/","title":"<b>Release v0.3.0</b>","text":"<p>A bag of new featurs that will stabilize in the upcoming patch versions</p> <p>General:</p> <ul> <li>The new minimum Python version is 3.9</li> <li>Added <code>Broken.temp_env</code> context, might be useful later</li> <li>Added <code>OnceTracker</code>, complementing <code>SameTracker</code> values</li> <li>Fix <code>StopIteration</code> on <code>BrokenPath.*.extract().rglob()</code> due bad Path with double output stems</li> </ul> <p>ShaderFlow:</p> <ul> <li> <p>Bugfixes:</p> <ul> <li>Reset time when pressing \"o\" for resetting the Scene</li> <li>Set <code>repeat=False</code> on shader texture, as it was wrapping pixels on <code>ssaa&lt;1</code></li> <li>Progress bar no longer interfered with window visibility <code>log.info</code> (changed to <code>log.debug</code>)</li> <li>Improve precision of finding a (numerator, denominator) on glfw.set_window_aspect_ratio</li> <li>Integration on values close to target in Dynamics should not be skipped</li> <li>Use multiple threads in PyTorch due NumPy import with <code>OMP_NUM_THREADS=1</code></li> </ul> </li> <li> <p>Additions/Changes:</p> <ul> <li>Initial logic for batch exporting:<ul> <li>Add <code>hyphen_range</code> parser to the shared library for that</li> <li>New <code>--batch/-b</code> command on ShaderScene's main</li> </ul> </li> <li>The <code>scale</code> is now an attribute, rather than carrying pre-multiplication on width and height</li> <li>Performance improvement on not importing full <code>arrow</code> on <code>ShaderScene.main</code></li> <li>Renamed <code>SHADERFLOW_BACKEND</code> to <code>WINDOW_BACKEND</code> env configuration</li> <li>Add <code>.instant = True</code> mode on DynamicNumber, should be useful later on</li> <li>Always build scenes when initializing, so it's not explicit or not assumes else;<ul> <li>Fixme: When one just wants the CLI, the full window and shader shall be loaded</li> </ul> </li> <li>Add <code>.duration</code> property to ShaderPiano, rename some attributes</li> <li>Fix and rename the Motion Blur scene. Instead of bindless textures, return <code>vec4</code> switch case</li> <li>The camera 2D Projection plane is now generic, slightly more costly but worth it<ul> <li>The plane is defined by <code>camera.plane_point</code> and <code>camera.plane_normal</code> on manual inits</li> </ul> </li> </ul> </li> </ul> <p>DepthFlow:</p> <ul> <li>Additions/Changes:<ul> <li>Refactor <code>parallax_*</code> attributes to a state dictionary</li> <li>Implement a new static-projections focal depth plane attribute</li> </ul> </li> </ul> <p>Pianola:</p> <ul> <li>Improved visuals, note border and beat markers</li> <li>Set initial time to minus roll time, so notes don't suddenly appear</li> <li>Set the Scene runtime to the Midi's one when loading</li> <li>Unify Midi loading on a <code>.load_midi</code> function</li> </ul>"},{"location":"news/2024/v0.3.1/","title":"<b>Release v0.3.1</b>","text":"<p>General:</p> <ul> <li>Fixed PyApp releases of the projects in the new single wheel architecture<ul> <li>The venv is shared across same-version projects and managed by uv</li> <li>Fixme hack: PyTorch flavor is being passed as <code>PYAPP_SELF_COMMAND</code> until we can send envs</li> </ul> </li> <li>Projects requiring PyTorch now have a prompt to install it if not found</li> <li>Windows NTFS workaround on deleting the release venv if a reinstall is due</li> <li>Use newest version of PyApp, as yanked dependency specification was updated</li> </ul> <p>DepthFlow:</p> <ul> <li>Use <code>SSAA=1.5</code> by default, for sharper images than brute forcing <code>quality</code> parameter</li> </ul>"},{"location":"news/2024/v0.3.2/","title":"<b>Release v0.3.2</b>","text":"<p>General:</p> <ul> <li>Iterate over <code>site.getsitepackages()</code> for finding PyTorch version instead of <code>[-1]</code></li> </ul> <p>ShaderFlow:</p> <ul> <li>Fix early Shader rendering when they weren't compiled on Windows<ul> <li>Caused by the hidden GLFW window signaling a resize when final resolution was set calculated</li> </ul> </li> <li>Temporary Debug UI modules contents are expanded by default</li> <li>Add an opt-out <code>WINDOW_EGL=1</code> env var for Linux Headless rendering</li> </ul> <p>DepthFlow:</p> <ul> <li>Add Depth of Field and Vignette post processing effects.<ul> <li>Disabled by default until better parameters are found, and maybe a faster blur</li> </ul> </li> </ul>"},{"location":"news/2024/v0.4.0/","title":"<b>Release v0.4.0</b>","text":"<p>Large batch of features of the v0.4.0 release</p>"},{"location":"news/2024/v0.4.0/#technical-changes","title":"Technical changes","text":"<p>The changes below aren't exhaustive, I'll keep track more closely on future releases</p> <p>Broken:</p> <ul> <li>Fix: Always <code>.upper()</code> values from <code>LOGLEVEL</code></li> <li>Add <code>valid: bool</code> on <code>BrokenPath</code> initialization itself, as <code>BrokenPath(None).valid()</code> is invalid</li> <li>Fix: <code>BrokenTyper</code> replace '_' with '-' on given command names and <code>tuple(map(str, args))</code> them</li> <li>Fixed BrokenAudioReader not yielding data if <code>chunk=0</code> when entering the context</li> <li>Rewrite FFmpeg file, options for easily exporting to H264, HEVC, AV1, VP9, (+NVENC alts)</li> <li>Rewrite Upscalers file, much more stable and better code</li> <li>Reimplement threaded stdin writing directly on <code>shell</code> command</li> <li>Performance improvement on BrokenScheduler by reducing sanitization overhead (roughly 6%)</li> </ul> <p>ShaderFlow:</p> <ul> <li>Prompt the user to install audio server packages if <code>soundcard</code> import fails</li> <li>Always use EGL for creating the OpenGL context, disableable with <code>WINDOW_EGL=0</code></li> <li>Safety checks for all modules to be initialized with <code>Module(self=instance(ShaderScene))</code><ul> <li>Don't worry, a scene itself defaults <code>self.scene = self</code> so it is a scene !</li> <li>This enables type hinting on the Module class, that depends on Scene, which depends on Module</li> </ul> </li> <li>Always swap buffers even if on headless, NVIDIA driver was softlocking/hanging on benchmark mode</li> <li>Added <code>ShaderScene.cycle</code> variable. <code>tau</code> is normalized time, and <code>cycle</code> is norm angle <code>2pi*tau</code></li> <li>Renamed <code>Message</code> to <code>ShaderMessage</code> for consistency (psa. Shader is short for ShaderFlow)</li> <li>Rename <code>ShaderScene.main(end)</code> to <code>ShaderScene.main(time)</code></li> <li>The default quality level is now <code>50%</code>, for equal options on increasing or decreasing</li> <li>Rewrite Monocular Depth Estimators class, options for DepthAnything(1,2), ZoeDepth, Marigold</li> <li>Depth estimators now use and saves uint16 pngs file for better precision on large offsets</li> <li>The equirectangular 360\u00b0 videos projection mode can now be 'zoomed' with regular zoom factor</li> <li>Added .on_frame BrokenRelay to ShaderVideo, for user option to process raw video frames</li> <li>Video flipping is now applied on the shader side when rendering, instead of ffmpeg -vf vflip</li> <li>Added a <code>ShaderCamera.rotate2d()</code> method for static and known angles relative to the screen plane</li> <li>Fix first frametime of the scheduler either being too short or long; now a perfect 1/fps start</li> <li>Improved music visualizer demo scene</li> </ul> <p>DepthFlow:</p> <ul> <li>Huge performance gains on the shader by walking on bigger steps first, then precise backwards</li> <li>Big performance gain on not calculating <code>tan(theta)</code> on every loop (that was uneventful lol)</li> <li>Per uint16 depth maps, removed the option to upscale them, as ncnn doesn't implement it</li> <li>Added a <code>vec2 iDepthCenter</code> shader variable for true camera offsets</li> <li>Renamed <code>focus-&gt;static</code> and <code>plane-&gt;focus</code> for better clarity</li> <li>Renamed all shader variables prefixes from <code>iParallax</code> to <code>iDepth</code></li> </ul>"},{"location":"pianola/","title":"Index","text":"<p>Important</p> <p><sub>This repository is part of a monorepo and shouldn't be cloned alone</sub></p> Pianola   World's Smoothest and Most Customizable Piano Roll.    <p></p> <ul> <li>Pianola Shader is CC-BY-SA 4.0, just attribute on videos and same-license modifications :)</li> </ul> \ud83c\udf41 Learn More \ud83c\udf41 \u2728 Check out my Awesome Website instead of a boring Readme \u2728 Installation Guides, Usage, Tips, Code Reference and More!"},{"location":"pianola/get/","title":"\ud83c\udfb9 Pianola","text":"<p>Unified Installation</p> <p>Follow the main Installation Guide, then continue from here</p> <p>This project will receive further development soon</p> <p>For now, manual work is needed to change anything</p> <p>After activating the Virtual Environment on <code>.venv</code>:</p> <ul> <li>Run <code>pianola</code> for a real-time window</li> <li>Run <code>pianola --help</code> for rendering options</li> </ul>"},{"location":"pianola/reference/pianola/","title":"Pianola","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"pianola/reference/pianola/#Pianola","title":"<code>Pianola</code>","text":""},{"location":"pianola/reference/pianola/#Pianola.PIANOLA","title":"<code>Pianola.PIANOLA = BrokenProject(PACKAGE=__file__, APP_NAME='Pianola', APP_AUTHOR='BrokenSource', RESOURCES=PianolaResources)</code>  <code>module-attribute</code>","text":""},{"location":"pianola/reference/pianola/#Pianola.PROJECT","title":"<code>Pianola.PROJECT = BrokenProject(PACKAGE=__file__, APP_NAME='Pianola', APP_AUTHOR='BrokenSource', RESOURCES=PianolaResources)</code>  <code>module-attribute</code>","text":""},{"location":"shaderflow/","title":"Index","text":"<p>Important</p> <p><sub>This repository is part of a monorepo and shouldn't be cloned alone</sub></p> ShaderFlow   Imagine ShaderToy, on a Manim-like Architecture. That's ShaderFlow <p></p>"},{"location":"shaderflow/#description","title":"\ud83d\udd25 Description","text":"<p>ShaderFlow is a complete Tool for Artists, Musicians and Shader Enthusiasts</p> <p>A Framework for Creating, Exporting Real Time and Audio Reactive Shaders</p> <ul> <li>\ud83d\udee1\ufe0f Open Source, trust and transparency, cross platform, configurable</li> <li>\ud83e\uddf8 80% ShaderToy compatible, easily transfer your knowledge</li> <li>\ud83d\udcd4 Video Codecs: easily export to H264, HEVC, AV1, (+NVENC)</li> <li>\ud83d\ude80 Physics-like animations with control systems dynamics</li> <li>\ud83d\udd31 High Quality, any resolution, framerate, bitrate, SSAA</li> <li>\ud83c\udfb5 Audio Reactive, live music, professional video</li> <li>\ud83c\udf0a Audio Waveforms and oscilloscope support</li> <li>\ud83c\udfa5 Video as Texture: real time 4k processing</li> <li>\u267b\ufe0f Live Reload shaders, instant feedback</li> <li>\ud83c\udfa8 No Watermarks, user first experience</li> <li>\u23f3 Perfect Frametimes, no jitter, no lag</li> <li>\ud83c\udf35 Fastest rendering times in the west</li> <li>\ud83d\udc41 Built-in Camera 2D, 3D, 360\u00b0, VR</li> <li>\ud83c\udfb9 Piano Roll scene, the smoothest</li> </ul> <p></p>"},{"location":"shaderflow/#showcase","title":"\ud83d\udcf8 Showcase","text":"<p>\ud83c\udfa7 \u2022 Remember to Enable Audio on the Videos !</p> <p></p> <p><sup>Video: Music Visualizer Tech Demo Scene. Sources: Music and Image. Property of their original owners \u2696\ufe0f</sup></p> <p></p> <p><sup>Video: Music Bars Tech Demo Scene. Sources: Music. Property of their original owners \u2696\ufe0f</sup></p> <p></p> <p><sup>Video: Real Time Piano Roll Tech Demo Scene. Sources: Salamander Grand Piano by Alexander Holm, CC BY 3.0 and Midi File for the composition Flight of The Bumblebee by Rimsky Korsakov. Property of their original owners \u2696\ufe0f</sup></p> <p></p> <p><sup>Video: Educational Scene about Parallel Plates Capacitor. Source: Coded myself long ago.</sup></p> <p> </p> \ud83c\udf41 Learn More \ud83c\udf41 \u2728 Check out my Awesome Website instead of a boring Readme \u2728 Installation Guides, Usage, Tips, Code Reference and More!"},{"location":"shaderflow/controls/","title":"Controls","text":""},{"location":"shaderflow/controls/#camera-modes","title":"Camera Modes","text":"<ul> <li>1 Free Camera 3D</li> <li>2 Generic Camera 2D</li> <li>3 Spherical Camera 3D</li> <li>p Camera Projection</li> <li>i j k UP Axis (x, y, z)</li> </ul>"},{"location":"shaderflow/controls/#camera-controls","title":"Camera Controls","text":"<ul> <li>W A S D Move</li> <li>Q E Roll</li> <li>Space Shift Move Up/Down</li> <li>Mouse Look Around</li> <li>Mouse Wheel Zoom In/Out</li> <li>T G Isometric +/-</li> </ul>"},{"location":"shaderflow/controls/#scene-controls","title":"Scene Controls","text":"<ul> <li>R Reload Shaders</li> <li>O Reset Scene</li> </ul>"},{"location":"shaderflow/controls/#window-controls","title":"Window Controls","text":"<ul> <li>Tab ShaderFlow Menu</li> <li>F1 Exclusive Mouse Mode</li> <li>F2 Screenshot</li> <li>F11 Fullscreen</li> <li>Esc Exit</li> </ul>"},{"location":"shaderflow/get/","title":"\ud83d\udd25 ShaderFlow","text":"<p>\ud83d\udea7 Better Documentation is Work in Progress \ud83d\udea7</p> <p>Unified Installation</p> <p>Follow the main Installation Guide, then continue from here</p> <p>Intended Usage</p> <p>ShaderFlow, similar to Manim, is best used directly from a <code>python</code> script</p> <ul> <li>\"From Source\" and \"From PyPI\" Installation is recommended</li> </ul> <p>After activating the Virtual Environment on <code>.venv</code>:</p> <ul> <li>Run <code>shaderflow</code> to see all available scenes</li> <li>Run <code>shaderflow (scene)</code> to run a specific scene</li> <li>Run <code>shaderflow (scene) --help</code> for rendering options</li> </ul> <p>Official Scene files are located at <code>ShaderFlow/Resources/Scenes/**/*.py</code></p> <p>Community Scene files are located at <code>Community/**/*.py</code></p>"},{"location":"shaderflow/reference/message/","title":"Message","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/message/#Message","title":"<code>Message</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage","title":"<code>Message.ShaderMessage</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>class ShaderMessage:\n\n    # # Special\n\n    class Custom:\n        \"\"\"Any data type\"\"\"\n        data: Any\n\n    # # Mouse\n\n    class Mouse:\n\n        @define\n        class Position:\n            # Real\n            x:  int = 0\n            y:  int = 0\n            dx: int = 0\n            dy: int = 0\n\n            # Normalized\n            u:  float = 0.0\n            v:  float = 0.0\n            du: float = 0.0\n            dv: float = 0.0\n\n        @define\n        class Press:\n            button: int = 0\n\n            # Real\n            x: int = 0\n            y: int = 0\n\n            # Normalized\n            u: float = 0.0\n            v: float = 0.0\n\n        @define\n        class Release:\n            button: int = 0\n\n            # Real\n            x: int = 0\n            y: int = 0\n\n            # Normalized\n            u: float = 0.0\n            v: float = 0.0\n\n        @define\n        class Drag:\n            # Real\n            x:  int = 0\n            y:  int = 0\n            dx: int = 0\n            dy: int = 0\n\n            # Normalized\n            u:  float = 0.0\n            v:  float = 0.0\n            du: float = 0.0\n            dv: float = 0.0\n\n        @define\n        class Scroll:\n            # Real\n            dx: int = 0\n            dy: int = 0\n\n            # Normalized\n            du: float = 0.0\n            dv: float = 0.0\n\n        @define\n        class Enter:\n            state: bool\n\n    # # Window\n\n    class Window:\n\n        @define\n        class Resize:\n            width:  int = None\n            height: int = None\n\n            @property\n            def size(self) -&gt; tuple[int, int]:\n                return self.width, self.height\n\n        @define\n        class Iconify:\n            state: bool = None\n\n        @define\n        class FileDrop:\n            files: list[str] = None\n\n        @define\n        class Close:\n            ...\n\n    # # Shader\n\n    class Shader:\n\n        @define\n        class RecreateTextures:\n            ...\n\n        @define\n        class Compile:\n            ...\n\n        @define\n        class Render:\n            ...\n\n    # # Keyboard\n\n    class Keyboard:\n\n        @define\n        class Press:\n            key:       int = None\n            action:    int = None\n            modifiers: int = None\n\n        @define\n        class KeyDown:\n            key:       int = None\n            modifiers: int = None\n\n        @define\n        class KeyUp:\n            key:       int = None\n            modifiers: int = None\n\n        @define\n        class Unicode:\n            char: str = None\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Custom","title":"<code>Custom</code>","text":"<p>Any data type</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>class Custom:\n    \"\"\"Any data type\"\"\"\n    data: Any\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Custom.data","title":"<code>data: Any</code>  <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse","title":"<code>Mouse</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>class Mouse:\n\n    @define\n    class Position:\n        # Real\n        x:  int = 0\n        y:  int = 0\n        dx: int = 0\n        dy: int = 0\n\n        # Normalized\n        u:  float = 0.0\n        v:  float = 0.0\n        du: float = 0.0\n        dv: float = 0.0\n\n    @define\n    class Press:\n        button: int = 0\n\n        # Real\n        x: int = 0\n        y: int = 0\n\n        # Normalized\n        u: float = 0.0\n        v: float = 0.0\n\n    @define\n    class Release:\n        button: int = 0\n\n        # Real\n        x: int = 0\n        y: int = 0\n\n        # Normalized\n        u: float = 0.0\n        v: float = 0.0\n\n    @define\n    class Drag:\n        # Real\n        x:  int = 0\n        y:  int = 0\n        dx: int = 0\n        dy: int = 0\n\n        # Normalized\n        u:  float = 0.0\n        v:  float = 0.0\n        du: float = 0.0\n        dv: float = 0.0\n\n    @define\n    class Scroll:\n        # Real\n        dx: int = 0\n        dy: int = 0\n\n        # Normalized\n        du: float = 0.0\n        dv: float = 0.0\n\n    @define\n    class Enter:\n        state: bool\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Position","title":"<code>Position</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Position:\n    # Real\n    x:  int = 0\n    y:  int = 0\n    dx: int = 0\n    dy: int = 0\n\n    # Normalized\n    u:  float = 0.0\n    v:  float = 0.0\n    du: float = 0.0\n    dv: float = 0.0\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Position.x","title":"<code>x: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Position.y","title":"<code>y: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Position.dx","title":"<code>dx: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Position.dy","title":"<code>dy: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Position.u","title":"<code>u: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Position.v","title":"<code>v: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Position.du","title":"<code>du: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Position.dv","title":"<code>dv: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Press","title":"<code>Press</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Press:\n    button: int = 0\n\n    # Real\n    x: int = 0\n    y: int = 0\n\n    # Normalized\n    u: float = 0.0\n    v: float = 0.0\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Press.button","title":"<code>button: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Press.x","title":"<code>x: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Press.y","title":"<code>y: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Press.u","title":"<code>u: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Press.v","title":"<code>v: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Release","title":"<code>Release</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Release:\n    button: int = 0\n\n    # Real\n    x: int = 0\n    y: int = 0\n\n    # Normalized\n    u: float = 0.0\n    v: float = 0.0\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Release.button","title":"<code>button: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Release.x","title":"<code>x: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Release.y","title":"<code>y: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Release.u","title":"<code>u: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Release.v","title":"<code>v: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Drag","title":"<code>Drag</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Drag:\n    # Real\n    x:  int = 0\n    y:  int = 0\n    dx: int = 0\n    dy: int = 0\n\n    # Normalized\n    u:  float = 0.0\n    v:  float = 0.0\n    du: float = 0.0\n    dv: float = 0.0\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Drag.x","title":"<code>x: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Drag.y","title":"<code>y: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Drag.dx","title":"<code>dx: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Drag.dy","title":"<code>dy: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Drag.u","title":"<code>u: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Drag.v","title":"<code>v: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Drag.du","title":"<code>du: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Drag.dv","title":"<code>dv: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Scroll","title":"<code>Scroll</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Scroll:\n    # Real\n    dx: int = 0\n    dy: int = 0\n\n    # Normalized\n    du: float = 0.0\n    dv: float = 0.0\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Scroll.dx","title":"<code>dx: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Scroll.dy","title":"<code>dy: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Scroll.du","title":"<code>du: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Scroll.dv","title":"<code>dv: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Enter","title":"<code>Enter</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Enter:\n    state: bool\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Mouse.Enter.state","title":"<code>state: bool</code>  <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window","title":"<code>Window</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>class Window:\n\n    @define\n    class Resize:\n        width:  int = None\n        height: int = None\n\n        @property\n        def size(self) -&gt; tuple[int, int]:\n            return self.width, self.height\n\n    @define\n    class Iconify:\n        state: bool = None\n\n    @define\n    class FileDrop:\n        files: list[str] = None\n\n    @define\n    class Close:\n        ...\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window.Resize","title":"<code>Resize</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Resize:\n    width:  int = None\n    height: int = None\n\n    @property\n    def size(self) -&gt; tuple[int, int]:\n        return self.width, self.height\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window.Resize.width","title":"<code>width: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window.Resize.height","title":"<code>height: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window.Resize.size","title":"<code>size: tuple[int, int]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window.Iconify","title":"<code>Iconify</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Iconify:\n    state: bool = None\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window.Iconify.state","title":"<code>state: bool = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window.FileDrop","title":"<code>FileDrop</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass FileDrop:\n    files: list[str] = None\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window.FileDrop.files","title":"<code>files: list[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Window.Close","title":"<code>Close</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Close:\n    ...\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Shader","title":"<code>Shader</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>class Shader:\n\n    @define\n    class RecreateTextures:\n        ...\n\n    @define\n    class Compile:\n        ...\n\n    @define\n    class Render:\n        ...\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Shader.RecreateTextures","title":"<code>RecreateTextures</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass RecreateTextures:\n    ...\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Shader.Compile","title":"<code>Compile</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Compile:\n    ...\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Shader.Render","title":"<code>Render</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Render:\n    ...\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard","title":"<code>Keyboard</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>class Keyboard:\n\n    @define\n    class Press:\n        key:       int = None\n        action:    int = None\n        modifiers: int = None\n\n    @define\n    class KeyDown:\n        key:       int = None\n        modifiers: int = None\n\n    @define\n    class KeyUp:\n        key:       int = None\n        modifiers: int = None\n\n    @define\n    class Unicode:\n        char: str = None\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.Press","title":"<code>Press</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Press:\n    key:       int = None\n    action:    int = None\n    modifiers: int = None\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.Press.key","title":"<code>key: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.Press.action","title":"<code>action: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.Press.modifiers","title":"<code>modifiers: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.KeyDown","title":"<code>KeyDown</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass KeyDown:\n    key:       int = None\n    modifiers: int = None\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.KeyDown.key","title":"<code>key: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.KeyDown.modifiers","title":"<code>modifiers: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.KeyUp","title":"<code>KeyUp</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass KeyUp:\n    key:       int = None\n    modifiers: int = None\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.KeyUp.key","title":"<code>key: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.KeyUp.modifiers","title":"<code>modifiers: int = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.Unicode","title":"<code>Unicode</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Message.py</code> Python<pre><code>@define\nclass Unicode:\n    char: str = None\n</code></pre>"},{"location":"shaderflow/reference/message/#Message.ShaderMessage.Keyboard.Unicode.char","title":"<code>char: str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/module/","title":"Module","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/module/#Module","title":"<code>Module</code>","text":""},{"location":"shaderflow/reference/module/#Module.ShaderModule","title":"<code>Module.ShaderModule</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@define\nclass ShaderModule(BrokenFluentBuilder, BrokenAttrs):\n    scene: ShaderScene = field(default=None, repr=False)\n    \"\"\"The ShaderScene this module belongs to. Must be set on initialization of any module with\n    `ShaderModule(scene=...)` even though marked as `default=None` to make flexible MRO parenting\"\"\"\n\n    uuid: int = Factory(itertools.count(1).__next__)\n    \"\"\"A module identifier, mostly used for differentiating log statements of same type modules\"\"\"\n\n    name: str = None\n    \"\"\"The base name for exported GLSL variables, textures, etc. It is technically optional, but\n    it's not a bad idea for all modules to have a default value for this attribute than None\"\"\"\n\n    @property\n    def who(self) -&gt; str:\n        return f\"({self.uuid:&gt;2}) {type(self).__name__[:18].ljust(18)} \u2502 \u25b8\"\n\n    def __post__(self):\n        # Post-import for type checking to avoid circular reference\n        from ShaderFlow.Scene import ShaderScene\n\n        # The module can be a ShaderScene itself\n        self.scene = self.scene or self\n\n        # Module must be part of a 'scene=instance(ShaderScene)'\n        if not isinstance(self.scene, ShaderScene):\n            raise RuntimeError(log.error('\\n'.join((\n                f\"Module of type '{type(self).__name__}' must be added to a 'ShaderScene' instance\",\n                f\"\u2022 Initialize it with {type(self).__name__}(scene='instance(ShaderScene)', ...)\",\n            ))))\n\n        log.trace(f\"{self.who} Module added to the Scene\")\n        self.scene.modules.append(self)\n        self.commands()\n\n    @abstractmethod\n    def commands(self) -&gt; None:\n        \"\"\"Add commands to the scene with `self.scene.typer.command(target=..., ...)`\"\"\"\n        ...\n\n    # # Messaging\n\n    def relay(self, message: Union[ShaderMessage, Type[ShaderMessage]]) -&gt; Self:\n        \"\"\"Send a message to all modules in the scene. Handle it defining a `self.handle(message)`\"\"\"\n        if isinstance(message, type):\n            message = message()\n        for module in self.scene.modules:\n            module.handle(message)\n        return self\n\n    @abstractmethod\n    def handle(self, message: ShaderMessage) -&gt; None:\n        \"\"\"Whenever a module relays a message on the scene, all modules are signaled via this method\n        for potentially acting on it. A Camera might move on WASD keys, for example\"\"\"\n        ...\n\n    def find(self, type: Type[ShaderModule]) -&gt; Iterable[ShaderModule]:\n        for module in self.scene.modules:\n            if isinstance(module, type):\n                yield module\n\n    @property\n    @abstractmethod\n    def duration(self) -&gt; float:\n        \"\"\"Self-reported 'time to render' until the module is finished. A ShaderAudio shall export\n        the input audio duration, for example\"\"\"\n        return 0.0\n\n    @abstractmethod\n    def build(self) -&gt; None:\n        \"\"\"Create Textures, child ShaderModules, load base shaders, etc. Happens only once, and it's\n        a good place to set default values for attributes, such as a background image that can be\n        later changed on `self.setup()` or, better yet, on the CLI of the module/custom Scene\"\"\"\n        pass\n\n    @abstractmethod\n    def setup(self) -&gt; None:\n        \"\"\"Called every time before the initialization (rendering) of the Scene. Useful for managing\n        the behavior of batch exporting per export index; also a good place to reset values to their\n        defaults or create procedural objects (seeds) after `self.build()`\"\"\"\n        pass\n\n    @abstractmethod\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        \"\"\"Returns the list of variables that will be exported to all Shaders of the scene. The\n        first compilation happens after `self.build()`, where all variables are metaprogrammed into\n        the GLSL code. Subsequent calls happens after all `self.update()` on every frame and the\n        variables are updated to the yielded values here\"\"\"\n        return []\n\n    @abstractmethod\n    def update(self) -&gt; None:\n        \"\"\"Called every frame. This defines the main behavior of the module inside the event loop.\n        All non-ShaderModules are called first, then the former ones. Access state data directly\n        on the Scene with `self.scene.{dt,time,width,height,...}`\"\"\"\n        pass\n\n    @abstractmethod\n    def ffmpeg(self, ffmpeg: BrokenFFmpeg) -&gt; None:\n        \"\"\"When exporting the Scene, after the initial CLI configuration of FFmpeg by the Scene's\n        `self.main` method, all modules have an option to change the FFmpeg settings on the fly.\n        Note that this can also be implemented on a custom Scene itself, and behavior _can_ be\n        changed per batch exporting\"\"\"\n        pass\n\n    # ------------------------------------------|\n    # Stuff pending a remaster\n\n    def __process_include__(self, include: str) -&gt; str:\n        return include.format({f\"${k}\": v for k, v in vars(self).items()})\n\n    @abstractmethod\n    def includes(self) -&gt; Iterable[str]:\n        yield \"\"\n\n    @abstractmethod\n    def defines(self) -&gt; Iterable[str]:\n        yield None\n\n    # # User interface\n\n    def __shaderflow_ui__(self) -&gt; None:\n        \"\"\"Basic info of a Module\"\"\"\n        # Todo: Make automatic Imgui methods\n\n        # Module - self.__ui__ must be implemented\n        if not getattr(self.__ui__, \"__isabstractmethod__\", False):\n            self.__ui__()\n\n        # Module - self.ui must be implemented\n        if not getattr(self.ui, \"__isabstractmethod__\", False):\n            self.ui()\n\n    @abstractmethod\n    def __ui__(self) -&gt; None:\n        \"\"\"Internal method for self.ui\"\"\"\n        pass\n\n    @abstractmethod\n    def ui(self) -&gt; None:\n        \"\"\"\n        Draw the UI for this module\n        \"\"\"\n        pass\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.scene","title":"<code>scene: ShaderScene = field(default=None, repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The ShaderScene this module belongs to. Must be set on initialization of any module with <code>ShaderModule(scene=...)</code> even though marked as <code>default=None</code> to make flexible MRO parenting</p>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.uuid","title":"<code>uuid: int = Factory(itertools.count(1).__next__)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A module identifier, mostly used for differentiating log statements of same type modules</p>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.name","title":"<code>name: str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The base name for exported GLSL variables, textures, etc. It is technically optional, but it's not a bad idea for all modules to have a default value for this attribute than None</p>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.who","title":"<code>who: str</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/module/#Module.ShaderModule.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>def __post__(self):\n    # Post-import for type checking to avoid circular reference\n    from ShaderFlow.Scene import ShaderScene\n\n    # The module can be a ShaderScene itself\n    self.scene = self.scene or self\n\n    # Module must be part of a 'scene=instance(ShaderScene)'\n    if not isinstance(self.scene, ShaderScene):\n        raise RuntimeError(log.error('\\n'.join((\n            f\"Module of type '{type(self).__name__}' must be added to a 'ShaderScene' instance\",\n            f\"\u2022 Initialize it with {type(self).__name__}(scene='instance(ShaderScene)', ...)\",\n        ))))\n\n    log.trace(f\"{self.who} Module added to the Scene\")\n    self.scene.modules.append(self)\n    self.commands()\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.commands","title":"<code>commands() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Add commands to the scene with <code>self.scene.typer.command(target=..., ...)</code></p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef commands(self) -&gt; None:\n    \"\"\"Add commands to the scene with `self.scene.typer.command(target=..., ...)`\"\"\"\n    ...\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.relay","title":"<code>relay(message: Union[ShaderMessage, Type[ShaderMessage]]) -&gt; Self</code>","text":"<p>Send a message to all modules in the scene. Handle it defining a <code>self.handle(message)</code></p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>def relay(self, message: Union[ShaderMessage, Type[ShaderMessage]]) -&gt; Self:\n    \"\"\"Send a message to all modules in the scene. Handle it defining a `self.handle(message)`\"\"\"\n    if isinstance(message, type):\n        message = message()\n    for module in self.scene.modules:\n        module.handle(message)\n    return self\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.handle","title":"<code>handle(message: ShaderMessage) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Whenever a module relays a message on the scene, all modules are signaled via this method for potentially acting on it. A Camera might move on WASD keys, for example</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef handle(self, message: ShaderMessage) -&gt; None:\n    \"\"\"Whenever a module relays a message on the scene, all modules are signaled via this method\n    for potentially acting on it. A Camera might move on WASD keys, for example\"\"\"\n    ...\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.find","title":"<code>find(type: Type[ShaderModule]) -&gt; Iterable[ShaderModule]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>def find(self, type: Type[ShaderModule]) -&gt; Iterable[ShaderModule]:\n    for module in self.scene.modules:\n        if isinstance(module, type):\n            yield module\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.duration","title":"<code>duration: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Self-reported 'time to render' until the module is finished. A ShaderAudio shall export the input audio duration, for example</p>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.build","title":"<code>build() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Create Textures, child ShaderModules, load base shaders, etc. Happens only once, and it's a good place to set default values for attributes, such as a background image that can be later changed on <code>self.setup()</code> or, better yet, on the CLI of the module/custom Scene</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef build(self) -&gt; None:\n    \"\"\"Create Textures, child ShaderModules, load base shaders, etc. Happens only once, and it's\n    a good place to set default values for attributes, such as a background image that can be\n    later changed on `self.setup()` or, better yet, on the CLI of the module/custom Scene\"\"\"\n    pass\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.setup","title":"<code>setup() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Called every time before the initialization (rendering) of the Scene. Useful for managing the behavior of batch exporting per export index; also a good place to reset values to their defaults or create procedural objects (seeds) after <code>self.build()</code></p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef setup(self) -&gt; None:\n    \"\"\"Called every time before the initialization (rendering) of the Scene. Useful for managing\n    the behavior of batch exporting per export index; also a good place to reset values to their\n    defaults or create procedural objects (seeds) after `self.build()`\"\"\"\n    pass\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>  <code>abstractmethod</code>","text":"<p>Returns the list of variables that will be exported to all Shaders of the scene. The first compilation happens after <code>self.build()</code>, where all variables are metaprogrammed into the GLSL code. Subsequent calls happens after all <code>self.update()</code> on every frame and the variables are updated to the yielded values here</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef pipeline(self) -&gt; Iterable[ShaderVariable]:\n    \"\"\"Returns the list of variables that will be exported to all Shaders of the scene. The\n    first compilation happens after `self.build()`, where all variables are metaprogrammed into\n    the GLSL code. Subsequent calls happens after all `self.update()` on every frame and the\n    variables are updated to the yielded values here\"\"\"\n    return []\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.update","title":"<code>update() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Called every frame. This defines the main behavior of the module inside the event loop. All non-ShaderModules are called first, then the former ones. Access state data directly on the Scene with <code>self.scene.{dt,time,width,height,...}</code></p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef update(self) -&gt; None:\n    \"\"\"Called every frame. This defines the main behavior of the module inside the event loop.\n    All non-ShaderModules are called first, then the former ones. Access state data directly\n    on the Scene with `self.scene.{dt,time,width,height,...}`\"\"\"\n    pass\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.ffmpeg","title":"<code>ffmpeg(ffmpeg: BrokenFFmpeg) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>When exporting the Scene, after the initial CLI configuration of FFmpeg by the Scene's <code>self.main</code> method, all modules have an option to change the FFmpeg settings on the fly. Note that this can also be implemented on a custom Scene itself, and behavior can be changed per batch exporting</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef ffmpeg(self, ffmpeg: BrokenFFmpeg) -&gt; None:\n    \"\"\"When exporting the Scene, after the initial CLI configuration of FFmpeg by the Scene's\n    `self.main` method, all modules have an option to change the FFmpeg settings on the fly.\n    Note that this can also be implemented on a custom Scene itself, and behavior _can_ be\n    changed per batch exporting\"\"\"\n    pass\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.__process_include__","title":"<code>__process_include__(include: str) -&gt; str</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>def __process_include__(self, include: str) -&gt; str:\n    return include.format({f\"${k}\": v for k, v in vars(self).items()})\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.includes","title":"<code>includes() -&gt; Iterable[str]</code>  <code>abstractmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef includes(self) -&gt; Iterable[str]:\n    yield \"\"\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.defines","title":"<code>defines() -&gt; Iterable[str]</code>  <code>abstractmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef defines(self) -&gt; Iterable[str]:\n    yield None\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.__shaderflow_ui__","title":"<code>__shaderflow_ui__() -&gt; None</code>","text":"<p>Basic info of a Module</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>def __shaderflow_ui__(self) -&gt; None:\n    \"\"\"Basic info of a Module\"\"\"\n    # Todo: Make automatic Imgui methods\n\n    # Module - self.__ui__ must be implemented\n    if not getattr(self.__ui__, \"__isabstractmethod__\", False):\n        self.__ui__()\n\n    # Module - self.ui must be implemented\n    if not getattr(self.ui, \"__isabstractmethod__\", False):\n        self.ui()\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.__ui__","title":"<code>__ui__() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Internal method for self.ui</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef __ui__(self) -&gt; None:\n    \"\"\"Internal method for self.ui\"\"\"\n    pass\n</code></pre>"},{"location":"shaderflow/reference/module/#Module.ShaderModule.ui","title":"<code>ui() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Draw the UI for this module</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Module.py</code> Python<pre><code>@abstractmethod\ndef ui(self) -&gt; None:\n    \"\"\"\n    Draw the UI for this module\n    \"\"\"\n    pass\n</code></pre>"},{"location":"shaderflow/reference/scene/","title":"Scene","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/scene/#Scene","title":"<code>Scene</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.WindowBackend","title":"<code>Scene.WindowBackend</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>class WindowBackend(BrokenEnum):\n    Headless = \"headless\"\n    GLFW     = \"glfw\"\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.WindowBackend.Headless","title":"<code>Headless = 'headless'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.WindowBackend.GLFW","title":"<code>GLFW = 'glfw'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene","title":"<code>Scene.ShaderScene</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>@define\nclass ShaderScene(ShaderModule):\n    __name__ = \"Scene\"\n\n    # # Base modules\n\n    modules: Deque[ShaderModule] = Factory(deque)\n    \"\"\"Deque of all Modules on the Scene, not a set for order preservation\"\"\"\n\n    # Scheduling\n    scheduler: BrokenScheduler = Factory(BrokenScheduler)\n    vsync: BrokenTask = None\n\n    # ShaderFlow modules\n    frametimer: ShaderFrametimer = None\n    keyboard: ShaderKeyboard = None\n    camera: ShaderCamera = None\n    ffmpeg: BrokenFFmpeg = None\n\n    # # Fractional SSAA\n\n    shader: ShaderObject = None\n    \"\"\"The main ShaderObject of the Scene, the visible content of the Window\"\"\"\n\n    _final: ShaderObject = None\n    \"\"\"Internal ShaderObject used for a Fractional Super-Sampling Anti-Aliasing (SSAA). This shader\n    samples the texture from the user's final self.shader, which is rendered at SSAA resolution\"\"\"\n\n    alpha: bool = False\n    \"\"\"Makes the final texture have an alpha channel, useful for transparent windows. Exporting\n    videos might fail, perhaps output a Chroma Key compatible video - add this to the shader:\n    - `fragColor.rgb = mix(vec3(0, 1, 0), fragColor.rgb, fragColor.a);`\"\"\"\n\n    quality: float = field(default=50, converter=lambda x: clamp(x, 0, 100))\n    \"\"\"Rendering Quality, if implemented - either on the GPU Shader or CPU Python side\"\"\"\n\n    typer: BrokenTyper = Factory(lambda: BrokenTyper(chain=True))\n    \"\"\"This Scene's BrokenTyper instance for the CLI. Commands are added by any module in the\n    `self.commands` method. The `self.main` is always added to it\"\"\"\n\n    def __post__(self):\n        self.typer.description = (self.typer.description or self.__class__.__doc__)\n        self.typer._panel = \"\ud83d\udd25 Scene commands\"\n        self.typer.command(self.main, context=True)\n        self.build()\n\n    def cli(self, *args: List[Union[Any, str]]):\n        \"\"\"Interpret a list of arguments as actions, defined by the Scene's `self.commands` plus\n        the `main` method. Must not start with `sys.executable`, so send `sys.argv[1:]` or direct\"\"\"\n        self.typer(flatten(args))\n\n    @OnceTracker.decorator\n    def build(self):\n        imgui.create_context()\n        self.imguio = imgui.get_io()\n        self.imguio.font_global_scale = 1\n        self.imguio.fonts.add_font_from_file_ttf(\n            str(Broken.BROKEN.RESOURCES.FONTS/\"DejaVuSans.ttf\"),\n            16*self.imguio.font_global_scale,\n        )\n\n        # Default modules\n        self.init_window()\n        self.frametimer = ShaderFrametimer(scene=self)\n        self.keyboard = ShaderKeyboard(scene=self)\n        self.camera = ShaderCamera(scene=self)\n\n        # Create the SSAA Workaround engines\n        self._final = ShaderObject(scene=self, name=\"iFinal\")\n        self._final.texture.components = 3 + int(self.alpha)\n        self._final.texture.dtype = \"f1\"\n        self._final.texture.final = True\n        self._final.texture.track = True\n        self._final.fragment = (SHADERFLOW.RESOURCES.FRAGMENT/\"Final.glsl\")\n        self.shader = ShaderObject(scene=self, name=\"iScreen\")\n        self.shader.texture.track = True\n        self.shader.texture.repeat(False)\n\n    # ---------------------------------------------------------------------------------------------|\n    # Temporal\n\n    time: Seconds = field(default=0.0, converter=float)\n    \"\"\"Current time in seconds. Ideally, everything should depend on time, for flexibility\"\"\"\n\n    tempo: float = Factory(lambda: DynamicNumber(value=1, frequency=3))\n    \"\"\"Time scale factor, used for `dt`, which integrates to `time`\"\"\"\n\n    runtime: Seconds = field(default=10.0, converter=float)\n    \"\"\"The longest module duration; overriden by the user; or default length of 10s\"\"\"\n\n    fps: Hertz = field(default=60.0, converter=lambda x: max(float(x), 1.0))\n    \"\"\"Target frames per second rendering speed\"\"\"\n\n    dt: Seconds = field(default=0.0, converter=float)\n    \"\"\"Virtual delta time since last frame, time scaled by `tempo`. Use `self.rdt` for real delta\"\"\"\n\n    rdt: Seconds = field(default=0.0, converter=float)\n    \"\"\"Real life, physical delta time since last frame. Use `self.dt` for time scaled version\"\"\"\n\n    @property\n    def tau(self) -&gt; float:\n        \"\"\"Normalized time value relative to runtime between 0 and 1\"\"\"\n        return (self.time / self.runtime)\n\n    @property\n    def cycle(self) -&gt; float:\n        \"\"\"A number from 0 to 2pi that ends on the runtime ('normalized angular time')\"\"\"\n        return (2 * math.pi * self.tau)\n\n    @property\n    def frametime(self) -&gt; Seconds:\n        \"\"\"Ideal time between two frames. This value is coupled with `fps`\"\"\"\n        return (1 / self.fps)\n\n    @frametime.setter\n    def frametime(self, value: Seconds):\n        self.fps = (1 / value)\n\n    @property\n    def frame(self) -&gt; int:\n        \"\"\"Current frame being rendered. This value is coupled with 'time' and 'fps'\"\"\"\n        return round(self.time * self.fps)\n\n    @frame.setter\n    def frame(self, value: int):\n        self.time = (value / self.fps)\n\n    # Total Duration\n\n    @property\n    def duration(self) -&gt; Seconds:\n        \"\"\"Alias to self.runtime. Set both with `.set_duration()`\"\"\"\n        return self.runtime\n\n    def set_duration(self, override: Seconds=None, *, minimum: Seconds=10) -&gt; Seconds:\n        \"\"\"Either force the runtime to be 'override' or find the longest module lower bounded\"\"\"\n        self.runtime = (override or minimum)\n        for module in (not bool(override)) * self.modules:\n            self.runtime = max(self.runtime, module.duration)\n        self.runtime /= self.tempo.value\n        return self.runtime\n\n    @property\n    def total_frames(self) -&gt; int:\n        \"\"\"The total frames this scene should render when exporting, if 'runtime' isn't changed\"\"\"\n        return round(self.runtime * self.fps)\n\n    # ---------------------------------------------------------------------------------------------|\n    # Window synchronized properties\n\n    # # Title\n\n    _title: str = \"ShaderFlow\"\n\n    @property\n    def title(self) -&gt; str:\n        \"\"\"Realtime window 'title' property\"\"\"\n        return self._title\n\n    @title.setter\n    def title(self, value: str):\n        log.debug(f\"{self.who} Changing Window Title to ({value})\")\n        self.window.title = value\n        self._title = value\n\n    # # Resizable\n\n    _resizable: bool = True\n\n    @property\n    def resizable(self) -&gt; bool:\n        \"\"\"Realtime window 'is resizable' property\"\"\"\n        return self._resizable\n\n    @resizable.setter\n    def resizable(self, value: bool):\n        log.debug(f\"{self.who} Changing Window Resizable to ({value})\")\n        self.window.resizable = value\n        self._resizable = value\n\n    # # Visible\n\n    _visible: bool = False\n\n    @property\n    def visible(self) -&gt; bool:\n        \"\"\"Realtime window 'is visible' property\"\"\"\n        return self._visible\n\n    @visible.setter\n    def visible(self, value: bool):\n        log.debug(f\"{self.who} Changing Window Visibility to ({value})\")\n        self.window.visible = value\n        self._visible = value\n\n    # # Window Fullscreen\n\n    _fullscreen: bool = False\n\n    @property\n    def fullscreen(self) -&gt; bool:\n        \"\"\"Window 'is fullscreen' property\"\"\"\n        return self._fullscreen\n\n    @fullscreen.setter\n    def fullscreen(self, value: bool):\n        log.debug(f\"{self.who} Changing Window Fullscreen to ({value})\")\n        self._fullscreen = value\n        try:\n            self.window.fullscreen = value\n        except AttributeError:\n            pass\n\n    # # Window Exclusive\n\n    _exclusive: bool = False\n\n    @property\n    def exclusive(self) -&gt; bool:\n        \"\"\"Window 'mouse exclusivity' property: Is the mouse cursor be locked to the window\"\"\"\n        return self._exclusive\n\n    @exclusive.setter\n    def exclusive(self, value: bool):\n        log.debug(f\"{self.who} Changing Window Exclusive to ({value})\")\n        self.window.mouse_exclusivity = value\n        self._exclusive = value\n\n    # # Video modes and monitor\n\n    monitor: int = os.getenv(\"MONITOR\", 0)\n\n    @property\n    def glfw_monitor(self) -&gt; Optional[glfw._GLFWmonitor]:\n        if (monitors := glfw.get_monitors()):\n            return monitors[self.monitor]\n\n    @property\n    def glfw_video_mode(self) -&gt; Optional[Dict]:\n        if (monitor := self.glfw_monitor):\n            return glfw.get_video_mode(monitor)\n\n    @property\n    def monitor_framerate(self) -&gt; float:\n        \"\"\"Note: Defaults to 60 if no monitor is found\"\"\"\n        if (mode := self.glfw_video_mode):\n            return mode.refresh_rate or 60.0\n        return 60.0\n\n    @property\n    def monitor_size(self) -&gt; Optional[Tuple[int, int]]:\n        if self.exporting:\n            return None\n        if (mode := self.glfw_video_mode):\n            return (mode.size.width, mode.size.height)\n\n    @property\n    def monitor_width(self) -&gt; Optional[int]:\n        if (resolution := self.monitor_size):\n            return resolution[0]\n\n    @property\n    def monitor_height(self) -&gt; Optional[int]:\n        if (resolution := self.monitor_size):\n            return resolution[1]\n\n    # ---------------------------------------------------------------------------------------------|\n    # Resolution\n\n    # # Scale\n\n    _scale: float = field(default=1.0, converter=lambda x: max(0.01, x))\n\n    @property\n    def scale(self) -&gt; float:\n        \"\"\"Resolution scale factor, the `self.width` and `self.height` are multiplied by this\"\"\"\n        return self._scale\n\n    @scale.setter\n    def scale(self, value: float):\n        log.debug(f\"{self.who} Changing Resolution Scale to ({value})\")\n        self.resize(scale=value)\n\n    # # Width\n\n    _width: int = field(default=1920, converter=lambda x: int(max(1, x)))\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Rendering width (horizontal size) of the Scene in pixels\"\"\"\n        return round(self._width * self._scale)\n\n    @width.setter\n    def width(self, value: int):\n        self.resize(width=value)\n\n    # # Height\n\n    _height: int = field(default=1080, converter=lambda x: int(max(1, x)))\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"Rendering height (vertical size) of the Scene in pixels\"\"\"\n        return round(self._height * self._scale)\n\n    @height.setter\n    def height(self, value: int):\n        self.resize(height=value)\n\n    # # SSAA\n\n    _ssaa: float = field(default=1.0,  converter=lambda x: max(0.01, x))\n\n    @property\n    def ssaa(self) -&gt; float:\n        \"\"\"Fractional Super Sampling Anti-Aliasing (SSAA) factor. Improves the image quality (&gt;1) by\n        rendering at a higher resolution and then downsampling, resulting in smoother edges at a\n        significant GPU computational cost of O(N^2). Values lower than 1 (yield worse quality, but)\n        are useful when the GPU can't keep up: when the resolution is too high or FPS is too low\"\"\"\n        return self._ssaa\n\n    @ssaa.setter\n    def ssaa(self, value: float):\n        log.debug(f\"{self.who} Changing Fractional SSAA to {value}\")\n        self._ssaa = value\n        self.relay(ShaderMessage.Shader.RecreateTextures)\n\n    # # Resolution (With, Height)\n\n    @property\n    def resolution(self) -&gt; Tuple[int, int]:\n        \"\"\"The resolution the Scene is rendering in pixels\"\"\"\n        return (self.width, self.height)\n\n    @resolution.setter\n    def resolution(self, value: Tuple[int, int]):\n        self.resize(*value)\n\n    @property\n    def render_resolution(self) -&gt; Tuple[int, int]:\n        \"\"\"Internal 'true' rendering resolution for SSAA. Same as `self.resolution*self.ssaa`\"\"\"\n        return (round(self.width*self.ssaa), round(self.height*self.ssaa))\n\n    # # Aspect Ratio\n\n    _aspect_ratio: float = None\n\n    @property\n    def aspect_ratio(self) -&gt; float:\n        \"\"\"Either the forced `self._aspect_ratio` or dynamic from `self.width/self.height`. When set\n        and resizing, the logic of `BrokenResolution.fit` is applied to enforce ratios\"\"\"\n        return self._aspect_ratio or (self._width/self._height)\n\n    @aspect_ratio.setter\n    def aspect_ratio(self, value: Union[float, str]):\n        log.debug(f\"{self.who} Changing Aspect Ratio to {value}\")\n\n        # The aspect ratio can be sent as a fraction or \"none\", \"false\"\n        if isinstance(value, str):\n            value = eval(value.replace(\":\", \"/\").capitalize())\n\n        # Optimization: Only change if different\n        if (self._aspect_ratio == value):\n            return\n\n        self._aspect_ratio = value\n\n        if (self.backend == WindowBackend.GLFW):\n            num, den = limited_integer_ratio(self._aspect_ratio, limit=2**20) or (glfw.DONT_CARE, glfw.DONT_CARE)\n            glfw.set_window_aspect_ratio(self.window._window, num, den)\n\n    def resize(self,\n        width: Union[int, float]=Unchanged,\n        height: Union[int, float]=Unchanged,\n        *,\n        aspect_ratio: Union[Unchanged, float, str]=Unchanged,\n        scale: float=Unchanged\n    ) -&gt; Tuple[int, int]:\n        \"\"\"\n        Resize the true final rendering resolution of the Scene. Rounded to nearest multiple of 2,\n        so FFmpeg is happy, and limited by the monitor resolution if realtime\n\n        Args:\n            width:  New width of the Scene, None to not change\n            height: New height of the Scene, None to not change\n\n        Returns:\n            Self: Fluent interface\n        \"\"\"\n\n        # Maybe update auxiliary properties\n        self.aspect_ratio = (aspect_ratio or self._aspect_ratio)\n        self._scale = (scale or self._scale)\n\n        # The parameters aren't trivial. The idea is to fit resolution from the scale-less components,\n        # so scaling isn't carried over, then to apply scaling (self.resolution)\n        resolution = BrokenResolution.fit(\n            old=(self._width, self._height),\n            new=(width, height),\n            max=(self.monitor_size),\n            ar=self._aspect_ratio\n        )\n\n        # Optimization: Only resize when resolution changes\n        if (resolution != (self.width, self.height)):\n            self._width, self._height = resolution\n            self.window.size = self.resolution\n            self.relay(ShaderMessage.Shader.RecreateTextures)\n            log.info(f\"{self.who} Resized Window to {self.resolution}\")\n\n        return self.resolution\n\n    # ---------------------------------------------------------------------------------------------|\n    # Window, OpenGL, Backend\n\n    backend: WindowBackend = WindowBackend.get(os.getenv(\"WINDOW_BACKEND\", WindowBackend.GLFW))\n    \"\"\"The ModernGL Window Backend. **Cannot be changed after creation**. Can also be set with the\n    environment variable `WINDOW_BACKEND=&lt;backend&gt;`, where `backend = {glfw, headless}`\"\"\"\n\n    opengl: moderngl.Context = None\n    \"\"\"ModernGL Context of this Scene. The thread accessing this MUST own or ENTER its context for\n    creating, changing, deleting objects; more often than not, it's the Main thread\"\"\"\n\n    window: ModernglWindow = None\n    \"\"\"ModernGL Window instance at `site-packages/moderngl_window.context.&lt;self.backend&gt;.Window`\"\"\"\n\n    imgui: ModernglImgui = None\n    \"\"\"ModernGL Imgui integration class bound to the Window\"\"\"\n\n    imguio: Any = None\n    \"\"\"Imgui IO object\"\"\"\n\n    def init_window(self) -&gt; None:\n        \"\"\"Create the window and the OpenGL context\"\"\"\n        if self.window:\n            raise RuntimeError(\"Window backend cannot be changed after creation\")\n\n        # Use EGL for creating a OpenGL context, allows true headless with GPU acceleration\n        # Comments 2 and 6: (https://forums.developer.nvidia.com/t/81412)\n        # Note: For the cloud, see (https://brokensrc.dev/get/docker/)\n        backend = \"egl\" if (os.getenv(\"WINDOW_EGL\", \"1\") == \"1\") else None\n\n        # Dynamically import the ModernGL Window Backend and instantiate it. Vsync is on our side \ud83d\ude09\n        module = f\"moderngl_window.context.{denum(self.backend).lower()}\"\n        self.window = importlib.import_module(module).Window(\n            size=self.resolution,\n            title=self.title,\n            resizable=self.resizable,\n            visible=self.visible,\n            fullscreen=self.fullscreen,\n            vsync=False,\n            backend=backend\n        )\n        ShaderKeyboard.set_keymap(self.window.keys)\n        self.imgui  = ModernglImgui(self.window)\n        self.opengl = self.window.ctx\n\n        # Bind window events to relay\n        self.window.resize_func               = self.__window_resize__\n        self.window.close_func                = self.__window_close__\n        self.window.iconify_func              = self.__window_iconify__\n        self.window.key_event_func            = self.__window_key_event__\n        self.window.mouse_position_event_func = self.__window_mouse_position_event__\n        self.window.mouse_press_event_func    = self.__window_mouse_press_event__\n        self.window.mouse_release_event_func  = self.__window_mouse_release_event__\n        self.window.mouse_drag_event_func     = self.__window_mouse_drag_event__\n        self.window.mouse_scroll_event_func   = self.__window_mouse_scroll_event__\n        self.window.unicode_char_entered_func = self.__window_unicode_char_entered__\n        self.window.files_dropped_event_func  = self.__window_files_dropped_event__\n\n        if (self.backend == WindowBackend.GLFW):\n            BrokenThread.new(target=self.window.set_icon, icon_path=Broken.PROJECT.RESOURCES.ICON, daemon=True)\n            glfw.set_cursor_enter_callback(self.window._window, lambda _, enter: self.__window_mouse_enter_event__(inside=enter))\n            glfw.set_drop_callback(self.window._window, self.__window_files_dropped_event__)\n            ShaderKeyboard.Keys.LEFT_SHIFT = glfw.KEY_LEFT_SHIFT\n            ShaderKeyboard.Keys.LEFT_CTRL  = glfw.KEY_LEFT_CONTROL\n            ShaderKeyboard.Keys.LEFT_ALT   = glfw.KEY_LEFT_ALT\n\n        log.info(f\"OpenGL Renderer: {self.opengl.info['GL_RENDERER']}\")\n\n    def read_screen(self) -&gt; bytes:\n        \"\"\"Take a screenshot of the screen and return raw bytes. Length `width*height*components`\"\"\"\n        return self.window.fbo.read(viewport=(0, 0, self.width, self.height))\n\n    # ---------------------------------------------------------------------------------------------|\n    # User actions\n\n    @property\n    def directory(self) -&gt; Path:\n        \"\"\"Path of the current Scene file Python script. This works by searching up the call stack\n        for the first context whose filename isn't the local __file__ (of ShaderFlow.Scene)\"\"\"\n        # Idea: Maybe `type(self).mro()[0]` could help\n        for frame in inspect.stack():\n            if (frame.filename != __file__):\n                return Path(frame.filename).parent\n\n    def read_file(self, file: Path, bytes: bool=False) -&gt; Union[str, bytes]:\n        \"\"\"\n        Read a file relative to the current Scene Python script\n\n        Args:\n            file:  File to read, relative to the current Scene script directory\n            bytes: Whether to read the file as bytes, defaults to text\n\n        Returns:\n            File contents as text or bytes\n        \"\"\"\n        file = (self.directory/file)\n        log.info(f\"{self.who} Reading file ({file})\")\n        return LoaderBytes(file) if bytes else LoaderString(file)\n\n    # ---------------------------------------------------------------------------------------------|\n    # Main event loop\n\n    quit: PlainTracker = Factory(lambda: PlainTracker(False))\n    \"\"\"Should the scene end the main event loop? Use as `if scene.quit():`\"\"\"\n\n    def next(self, dt: float) -&gt; Self:\n        \"\"\"Integrate time, update all modules and render the next frame\"\"\"\n\n        # Fixme: Windows: https://github.com/glfw/glfw/pull/1426\n        # Immediately swap the buffer with previous frame for vsync\n        self.window.swap_buffers()\n\n        # Temporal logic\n        dt = min(dt, 1)\n        self.tempo.next(dt=abs(dt))\n        self.vsync.fps = self.fps\n        self.dt    = dt * self.tempo\n        self.rdt   = dt\n        self.time += self.dt\n\n        # Note: Updates in reverse order of addition (child -&gt; parent)\n        # Note: Update non-engine first, as the pipeline might change\n        for module in self.modules:\n            if not isinstance(module, ShaderObject):\n                module.update()\n        for module in reversed(self.modules):\n            if isinstance(module, ShaderObject):\n                module.update()\n\n        self._render_ui()\n        return self\n\n    exporting: bool = True\n    \"\"\"Is this Scene exporting to a video file?\"\"\"\n\n    rendering: bool = False\n    \"\"\"Either Exporting, Rendering or Benchmarking. 'Not Realtime' mode\"\"\"\n\n    realtime: bool = False\n    \"\"\"Running with a window and user interaction\"\"\"\n\n    headless: bool = False\n    \"\"\"Running Headlessly, without a window and user interaction\"\"\"\n\n    benchmark: bool = False\n    \"\"\"Stress test the rendering speed of the Scene\"\"\"\n\n    repeat: int = field(default=1, converter=int)\n    \"\"\"Number of times to loop the exported video. One '1' is no repeat, two '2' doubles the length.\n    Ideally have seamless transitions on the shader based on self.tau and/or/no audio input\"\"\"\n\n    # Batch exporting\n\n    export_batch: Iterable[int] = field(factory=lambda: [0], converter=lambda x: list(x) or [0])\n    \"\"\"Batch indices iterable to export\"\"\"\n\n    export_index: int = 0\n    \"\"\"Current Batch exporting video index\"\"\"\n\n    export_format: str = field(default=\"mp4\", converter=lambda x: str(denum(x)))\n    \"\"\"The last (or only) video export format (extension) to use\"\"\"\n\n    export_base: Path = field(default=Broken.PROJECT.DIRECTORIES.DATA, converter=lambda x: Path(x))\n    \"\"\"The last (or only) video export base directory. Videos should render to ($base/$name) if $name\n    is plain, that is, the path isn't absolute\"\"\"\n\n    @abstractmethod\n    def export_name(self, path: Path) -&gt; Path:\n        \"\"\"Change the video file name being exported based on the current batch index. By default,\n        the name is unchanged in single export, else the stem is appended with the batch index\"\"\"\n        if (len(self.export_batch) &gt; 1):\n            return path.with_stem(f\"{path.stem}_{self.export_index}\")\n        return path\n\n    def main(self,\n        width:      Annotated[int,   Option(\"--width\",      \"-w\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Width  of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1920 on init)[/dim]\")]=None,\n        height:     Annotated[int,   Option(\"--height\",     \"-h\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Height of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1080 on init)[/dim]\")]=None,\n        scale:      Annotated[float, Option(\"--scale\",      \"-x\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Post-multiply width and height by a scale factor [medium_purple3](None to keep)[/medium_purple3] [dim](1.0 on init)[dim]\")]=None,\n        aspect:     Annotated[str,   Option(\"--ar\",         \"-R\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Force resolution aspect ratio [green](Examples: '16:9', '16/9', '1.777')[/green] [medium_purple3](None for dynamic)[/medium_purple3]\")]=None,\n        fps:        Annotated[float, Option(\"--fps\",        \"-f\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Target frames per second [medium_purple3](Defaults to the monitor framerate on realtime else 60)[/medium_purple3]\")]=None,\n        fullscreen: Annotated[bool,  Option(\"--fullscreen\",       help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in fullscreen mode [medium_purple3](Toggle with F11)[/medium_purple3]\")]=False,\n        maximize:   Annotated[bool,  Option(\"--maximize\",   \"-M\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in maximized mode\")]=False,\n        quality:    Annotated[float, Option(\"--quality\",    \"-q\", help=\"[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Shader quality level [green](0-100%)[/green] [yellow](If supported by the shader)[/yellow] [medium_purple3](None to keep, default 50%)[/medium_purple3]\")]=None,\n        ssaa:       Annotated[float, Option(\"--ssaa\",       \"-s\", help=\"[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Fractional super sampling anti aliasing factor [yellow](O(N^2) GPU cost)[/yellow] [medium_purple3](None to keep, default 1.0)[/medium_purple3]\")]=None,\n        render:     Annotated[bool,  Option(\"--render\",     \"-r\", help=\"[green](\ud83d\udfe2 Export )[/green] Export the Scene to a video file [medium_purple3](defined on --output, and implicit if so)[/medium_purple3]\")]=False,\n        output:     Annotated[str,   Option(\"--output\",     \"-o\", help=\"[green](\ud83d\udfe2 Export )[/green] Output file name [green]('Absolute', 'Relative path', 'Plain Name')[/green] [dim]($base/$(plain_name or $scene-$date))[/dim]\")]=None,\n        time:       Annotated[float, Option(\"--time\",       \"-t\", help=\"[green](\ud83d\udfe2 Export )[/green] The duration of exported videos [dim](Loop duration)[/dim] [medium_purple3](defaults to 10 or longest module's duration)[/medium_purple3]\")]=None,\n        tempo:      Annotated[float, Option(\"--tempo\",      \"-T\", help=\"[green](\ud83d\udfe2 Export )[/green] Set the time speed factor of the Scene [yellow](Final duration is stretched by [italic]1/tempo[/italic])[/yellow] [dim](1 on init)[/dim]\")]=None,\n        repeat:     Annotated[int,   Option(\"--repeat\",           help=\"[green](\ud83d\udfe2 Export )[/green] Number of exported videos loop copies [yellow](Final duration is stretched by [italic]repeat[/italic])[/yellow] [dim](1 on init)[/dim]\")]=None,\n        format:     Annotated[str,   Option(\"--format\",     \"-F\", help=\"[green](\ud83d\udfe2 Export )[/green] Output video container [green]('mp4', 'mkv', 'webm', 'avi, '...')[/green] [yellow](Overrides --output one)[/yellow]\")]=\"mp4\",\n        base:       Annotated[Path,  Option(\"--base\",       \"-D\", help=\"[green](\ud83d\udfe2 Export )[/green] Output file base directory\")]=Broken.PROJECT.DIRECTORIES.DATA,\n        vcodec:     Annotated[str,   Option(\"--vcodec\",     \"-c\", help=\"[green](\ud83d\udfe2 Export )[/green] Video codec [green]('h264', 'h264-nvenc', 'h265, 'hevc-nvenc', 'vp9', 'av1-{aom,svt,nvenc,rav1e}')[/green]\")]=\"h264\",\n        acodec:     Annotated[str,   Option(\"--acodec\",     \"-a\", help=\"[green](\ud83d\udfe2 Export )[/green] Audio codec [green]('aac', 'mp3', 'flac', 'wav', 'opus', 'ogg', 'copy', 'none', 'empty')[/green]\")]=\"copy\",\n        batch:      Annotated[str,   Option(\"--batch\",      \"-b\", help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] [dim][WIP] Hyphenated indices range to export multiple videos, if implemented. (1,5-7,10)[/dim]\")]=\"0\",\n        benchmark:  Annotated[bool,  Option(\"--benchmark\",  \"-B\", help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Benchmark the Scene's speed on raw rendering [medium_purple3](Use SKIP_GPU=1 for CPU only benchmark)[/medium_purple3]\")]=False,\n        raw:        Annotated[bool,  Option(\"--raw\",              help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Send raw OpenGL frames before GPU SSAA to FFmpeg [medium_purple3](Enabled if SSAA &lt; 1)[/medium_purple3] [dim](CPU Downsampling)[/dim]\")]=False,\n        open:       Annotated[bool,  Option(\"--open\",             help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Open the directory of video exports after all rendering finishes\")]=False,\n    ) -&gt; Optional[List[Path]]:\n        \"\"\"\n        Main event loop of this ShaderFlow Scene. Start a realtime window, exports to video, stress test speeds\n\n        \u2022 Note: For advanced video or audio codec configuration, modify it on 'self.ffmpeg' maybe inheriting this base class\n        \"\"\"\n        outputs: List[Path] = []\n\n        from arrow import now as arrow_now\n        export_started = arrow_now().format(\"YYYY-MM-DD HH-mm-ss\")\n\n        # Maybe update indices of exporting videos\n        self.export_batch  = hyphen_range(batch) or self.export_batch\n        self.export_format = format\n        self.export_base   = base\n\n        for index in self.export_batch:\n            self.export_index = index\n            self.exporting  = (render or bool(output))\n            self.rendering  = (self.exporting or benchmark)\n            self.realtime   = (not self.rendering)\n            self.benchmark  = benchmark\n            self.headless   = (self.rendering)\n            self.fps        = (fps or self.monitor_framerate)\n            self.title      = f\"ShaderFlow | {self.__name__}\"\n            self.quality    = quality or self.quality\n            self.repeat     = repeat or self.repeat\n            self.ssaa       = ssaa or self.ssaa\n            self.fullscreen = fullscreen\n            self.time       = 0\n            self.tempo.set(tempo or self.tempo.value)\n\n            for module in self.modules:\n                module.setup()\n\n            self.relay(ShaderMessage.Shader.Compile)\n            self.set_duration(time)\n\n            # Maybe keep or force aspect ratio, and find best resolution\n            width, height = self.resize(width=width, height=height, scale=scale, aspect_ratio=aspect)\n\n            # Optimization: Save bandwidth by piping native frames on ssaa &lt; 1\n            if self.rendering and (raw or self.ssaa &lt; 1):\n                self.resolution = self.render_resolution\n                self.ssaa = 1\n\n            # Configure FFmpeg and Popen it\n            if (self.rendering):\n                export = Path(output or f\"({export_started}) {self.__name__}\")\n                export = export if export.is_absolute() else (self.export_base/export)\n                export = export.with_suffix(\".\" + (self.export_format or export.suffix).replace(\".\", \"\"))\n                export = self.export_name(export)\n\n                self.ffmpeg = (BrokenFFmpeg(time=self.runtime).quiet()\n                    .pipe_input(pixel_format=(\"rgba\" if self.alpha else \"rgb24\"),\n                        width=self.width, height=self.height, framerate=self.fps)\n                    .scale(width=width, height=height)\n                    .output(path=export)\n                )\n\n                # Apply default good codec options on the video\n                self.ffmpeg.apply_vcodec_str(vcodec)\n                self.ffmpeg.apply_acodec_str(acodec)\n\n                for module in self.modules:\n                    if module is self: continue\n                    module.ffmpeg(self.ffmpeg)\n\n                if self.exporting:\n                    buffer = self.opengl.buffer(reserve=self._final.texture.size_t)\n                    self.ffmpeg = self.ffmpeg.popen(stdin=PIPE)\n\n                # Status tracker\n                status = DotMap(\n                    start=perf_counter(),\n                    bar=tqdm.tqdm(\n                        total=self.total_frames,\n                        desc=f\"Scene #{self.export_index} ({type(self).__name__}) \u2192 Video\",\n                        dynamic_ncols=True,\n                        colour=\"#43BFEF\",\n                        leave=False,\n                        unit=\" frames\",\n                        mininterval=1/30,\n                        maxinterval=0.1,\n                        smoothing=0.1,\n                    )\n                )\n\n            # Some scenes might take a while to setup\n            self.visible = not self.headless\n\n            if (self.backend == WindowBackend.GLFW and maximize):\n                glfw.maximize_window(self.window._window)\n\n            # Add self.next to the event loop\n            self.vsync = self.scheduler.new(\n                task=self.next,\n                frequency=self.fps,\n                freewheel=self.rendering,\n                precise=True,\n            )\n\n            # Main rendering loop\n            while (self.rendering) or (not self.quit()):\n                task = self.scheduler.next()\n\n                # Only continue if exporting\n                if (task.output is not self):\n                    continue\n                if self.realtime:\n                    continue\n                status.bar.update(1)\n\n                # Write a new frame to FFmpeg\n                if self.exporting:\n                    self._final.texture.fbo().read_into(buffer)\n                    turbopipe.pipe(buffer, self.ffmpeg.stdin.fileno())\n\n                # Finish exporting condition\n                if (status.bar.n &lt; self.total_frames):\n                    continue\n                status.bar.close()\n\n                if self.exporting:\n                    log.info(\"Waiting for FFmpeg process to finish (Queued writes, codecs lookahead, buffers, etc)\")\n                    turbopipe.close()\n                    self.ffmpeg.stdin.close()\n                    outputs.append(export)\n\n                # Repeat the video N times\n                if (self.repeat &gt; 1):\n                    log.info(f\"Repeating video ({self.repeat-1} times)\")\n                    export.rename(temporary := export.with_stem(f\"{export.stem}-repeat\"))\n                    (BrokenFFmpeg(stream_loop=(self.repeat-1)).quiet().copy_audio().copy_video()\n                        .input(temporary).output(export, pixel_format=None).run())\n                    temporary.unlink()\n\n                # Log stats\n                status.took = (perf_counter() - status.start)\n                log.info(f\"Finished rendering ({export})\", echo=not self.benchmark)\n                log.info((\n                    f\"\u2022 Stats: \"\n                    f\"(Took {status.took:.2f} s) at \"\n                    f\"({self.frame/status.took:.2f} FPS | \"\n                    f\"{self.runtime/status.took:.2f} x Realtime) with \"\n                    f\"({status.bar.n} Total Frames)\"\n                ))\n\n                if self.benchmark:\n                    return None\n                break\n\n        BrokenPath.open_in_file_explorer(outputs[0].parent) if open else None\n        return outputs\n\n    # ---------------------------------------------------------------------------------------------|\n    # Module\n\n    def handle(self, message: ShaderMessage) -&gt; None:\n\n        if isinstance(message, ShaderMessage.Window.Close):\n            log.info(f\"{self.who} Received Window Close Event\")\n            self.quit(True)\n\n        elif isinstance(message, ShaderMessage.Keyboard.KeyDown):\n            if message.key == ShaderKeyboard.Keys.O:\n                log.info(f\"{self.who} (O  ) Resetting the Scene\")\n                for module in self.modules:\n                    module.setup()\n                self.time = 0\n\n            elif message.key == ShaderKeyboard.Keys.R:\n                log.info(f\"{self.who} (R  ) Reloading Shaders\")\n                for module in self.modules:\n                    if isinstance(module, ShaderObject):\n                        module.compile()\n\n            elif message.key == ShaderKeyboard.Keys.TAB:\n                log.info(f\"{self.who} (TAB) Toggling Menu\")\n                self.render_ui = not self.render_ui\n\n            elif message.key == ShaderKeyboard.Keys.F1:\n                log.info(f\"{self.who} (F1 ) Toggling Exclusive Mode\")\n                self.exclusive = not self.exclusive\n\n            elif message.key == ShaderKeyboard.Keys.F2:\n                import arrow\n                time  = arrow.now().format(\"YYYY-MM-DD_HH-mm-ss\")\n                image = PIL.Image.frombytes(\"RGB\", self.resolution, self.read_screen())\n                image = image.transpose(PIL.Image.FLIP_TOP_BOTTOM)\n                path  = Broken.PROJECT.DIRECTORIES.SCREENSHOTS/f\"({time}) {self.__name__}.png\"\n                log.minor(f\"{self.who} (F2 ) Saving Screenshot to ({path})\")\n                BrokenThread.new(target=image.save, fp=path)\n\n            elif message.key == ShaderKeyboard.Keys.F11:\n                log.info(f\"{self.who} (F11) Toggling Fullscreen\")\n                self.fullscreen = not self.fullscreen\n\n        elif isinstance(message, (ShaderMessage.Mouse.Drag, ShaderMessage.Mouse.Position)):\n            self.mouse_gluv = (message.u, message.v)\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        yield ShaderVariable(\"uniform\", \"float\", \"iTime\",        self.time)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDuration\",    self.duration)\n        yield ShaderVariable(\"uniform\", \"float\", \"iDeltaTime\",   self.dt)\n        yield ShaderVariable(\"uniform\", \"vec2\",  \"iResolution\",  self.resolution)\n        yield ShaderVariable(\"uniform\", \"float\", \"iWantAspect\",  self.aspect_ratio)\n        yield ShaderVariable(\"uniform\", \"float\", \"iQuality\",     self.quality/100)\n        yield ShaderVariable(\"uniform\", \"float\", \"iSSAA\",        self.ssaa)\n        yield ShaderVariable(\"uniform\", \"float\", \"iFrameRate\",   self.fps)\n        yield ShaderVariable(\"uniform\", \"int\",   \"iFrame\",       self.frame)\n        yield ShaderVariable(\"uniform\", \"bool\",  \"iRealtime\",    self.realtime)\n        yield ShaderVariable(\"uniform\", \"vec2\",  \"iMouse\",       self.mouse_gluv)\n        yield ShaderVariable(\"uniform\", \"bool\",  \"iMouseInside\", self.mouse_inside)\n        for i in range(1, 6):\n            yield ShaderVariable(\"uniform\", \"bool\", f\"iMouse{i}\", self.mouse_buttons[i])\n\n    # ---------------------------------------------------------------------------------------------|\n    # Internal window events\n\n    def __window_resize__(self, width: int, height: int) -&gt; None:\n\n        # Don't listen to resizes when exporting, as the final resolution might be\n        # greater than the monitor and the window will resize down to fit\n        if self.exporting:\n            return\n        self.imgui.resize(width, height)\n        self._width, self._height = width, height\n        self.relay(ShaderMessage.Shader.RecreateTextures)\n\n    def __window_close__(self) -&gt; None:\n        self.relay(ShaderMessage.Window.Close())\n\n    def __window_iconify__(self, state: bool) -&gt; None:\n        self.relay(ShaderMessage.Window.Iconify(state=state))\n\n    def __window_files_dropped_event__(self, *stuff: list[str]) -&gt; None:\n        self.relay(ShaderMessage.Window.FileDrop(files=stuff[1]))\n\n    # # Keyboard related events\n\n    def __window_key_event__(self, key: int, action: int, modifiers: int) -&gt; None:\n        self.imgui.key_event(key, action, modifiers)\n        if self.imguio.want_capture_keyboard and self.render_ui:\n            return\n        if action == ShaderKeyboard.Keys.ACTION_PRESS:\n            self.relay(ShaderMessage.Keyboard.KeyDown(key=key, modifiers=modifiers))\n        elif action == ShaderKeyboard.Keys.ACTION_RELEASE:\n            self.relay(ShaderMessage.Keyboard.KeyUp(key=key, modifiers=modifiers))\n        self.relay(ShaderMessage.Keyboard.Press(key=key, action=action, modifiers=modifiers))\n\n    def __window_unicode_char_entered__(self, char: str) -&gt; None:\n        if self.imguio.want_capture_keyboard and self.render_ui:\n            return\n        self.relay(ShaderMessage.Keyboard.Unicode(char=char))\n\n    # # Mouse related events\n\n    mouse_gluv: Tuple[float, float] = Factory(lambda: (0, 0))\n\n    def __xy2uv__(self, x: int=0, y: int=0) -&gt; dict[str, float]:\n        \"\"\"Convert a XY pixel coordinate into a Center-UV normalized coordinate\"\"\"\n        return dict(\n            u=2*(x/self.width  - 0.5),\n            v=2*(y/self.height - 0.5)*(-1),\n            x=x, y=y,\n        )\n\n    def __dxdy2dudv__(self, dx: int=0, dy: int=0) -&gt; dict[str, float]:\n        \"\"\"Convert a dx dy pixel coordinate into a Center-UV normalized coordinate\"\"\"\n        return dict(\n            du=2*(dx/self.width)*(self.width/self.height),\n            dv=2*(dy/self.height)*(-1),\n            dx=dx, dy=dy,\n        )\n\n    mouse_buttons: Dict[int, bool] = Factory(lambda: {k: False for k in range(1, 6)})\n\n    def __window_mouse_press_event__(self, x: int, y: int, button: int) -&gt; None:\n        self.imgui.mouse_press_event(x, y, button)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n        self.mouse_buttons[button] = True\n        self.relay(ShaderMessage.Mouse.Press(\n            **self.__xy2uv__(x, y),\n            button=button\n        ))\n\n    def __window_mouse_release_event__(self, x: int, y: int, button: int) -&gt; None:\n        self.imgui.mouse_release_event(x, y, button)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n        self.mouse_buttons[button] = False\n        self.relay(ShaderMessage.Mouse.Release(\n            **self.__xy2uv__(x, y),\n            button=button\n        ))\n\n    mouse_inside: bool = False\n\n    def __window_mouse_enter_event__(self, inside: bool) -&gt; None:\n        self.mouse_inside = inside\n        self.relay(ShaderMessage.Mouse.Enter(state=inside))\n\n    def __window_mouse_scroll_event__(self, dx: int, dy: int) -&gt; None:\n        self.imgui.mouse_scroll_event(dx, dy)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n        elif self.keyboard(ShaderKeyboard.Keys.LEFT_ALT):\n            self.tempo.target += (dy)*0.2\n            return\n        self.relay(ShaderMessage.Mouse.Scroll(\n            **self.__dxdy2dudv__(dx=dx, dy=dy)\n        ))\n\n    def __window_mouse_position_event__(self, x: int, y: int, dx: int, dy: int) -&gt; None:\n        self.imgui.mouse_position_event(x, y, dx, dy)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n        self.relay(ShaderMessage.Mouse.Position(\n            **self.__dxdy2dudv__(dx=dx, dy=dy),\n            **self.__xy2uv__(x=x, y=y)\n        ))\n\n    _mouse_drag_time_factor: float = 4\n    \"\"\"How much seconds to scroll in time when the mouse moves the full window height\"\"\"\n\n    def __window_mouse_drag_event__(self, x: int, y: int, dx: int, dy: int) -&gt; None:\n        self.imgui.mouse_drag_event(x, y, dx, dy)\n        if self.imguio.want_capture_mouse and self.render_ui:\n            return\n\n        # Rotate the camera on Shift\n        if self.keyboard(ShaderKeyboard.Keys.LEFT_CTRL):\n            cx, cy = (x-self.width/2), (y-self.height/2)\n            angle = math.atan2(cy+dy, cx+dx) - math.atan2(cy, cx)\n            if (abs(angle) &gt; math.pi): angle -= 2*math.pi\n            self.camera.rotate(self.camera.base_z, angle=math.degrees(angle))\n            return\n\n        elif self.exclusive:\n            self.camera.apply_zoom(-dy/500)\n            self.camera.rotate(self.camera.base_z, angle=-dx/10)\n            return\n\n        # Time Travel on Alt\n        elif self.keyboard(ShaderKeyboard.Keys.LEFT_ALT):\n            self.time -= self._mouse_drag_time_factor * (dy/self.height)\n            return\n\n        self.relay(ShaderMessage.Mouse.Drag(\n            **self.__dxdy2dudv__(dx=dx, dy=dy),\n            **self.__xy2uv__(x=x, y=y)\n        ))\n\n    # ---------------------------------------------------------------------------------------------|\n    # Todo: Move UI to own class: For main menu, settings, exporting, etc\n\n    render_ui: bool = False\n    \"\"\"Whether to render the Main UI\"\"\"\n\n    # Fixme: Move to somewhere better\n    def _render_ui(self):\n        if not self.render_ui:\n            return\n\n        self._final.texture.fbo().use()\n        imgui.push_style_var(imgui.STYLE_WINDOW_BORDERSIZE, 0.0)\n        imgui.push_style_var(imgui.STYLE_WINDOW_ROUNDING, 8)\n        imgui.push_style_var(imgui.STYLE_TAB_ROUNDING, 8)\n        imgui.push_style_var(imgui.STYLE_GRAB_ROUNDING, 8)\n        imgui.push_style_var(imgui.STYLE_FRAME_ROUNDING, 8)\n        imgui.push_style_var(imgui.STYLE_CHILD_ROUNDING, 8)\n        imgui.push_style_color(imgui.COLOR_FRAME_BACKGROUND, 0.1, 0.1, 0.1, 0.5)\n        imgui.new_frame()\n        imgui.set_next_window_position(0, 0)\n        imgui.set_next_window_bg_alpha(0.6)\n        imgui.begin(f\"{self.__name__}\", False, imgui.WINDOW_NO_MOVE | imgui.WINDOW_NO_RESIZE | imgui.WINDOW_NO_COLLAPSE  | imgui.WINDOW_ALWAYS_AUTO_RESIZE)\n\n        # Render every module\n        for module in self.modules:\n            if imgui.tree_node(f\"{module.uuid:&gt;2} - {type(module).__name__.replace('ShaderFlow', '')}\", imgui.TREE_NODE_BULLET | imgui.TREE_NODE_DEFAULT_OPEN):\n                module.__shaderflow_ui__()\n                imgui.spacing()\n                imgui.tree_pop()\n\n        imgui.end()\n        imgui.pop_style_color()\n        imgui.pop_style_var(6)\n        imgui.render()\n        self.imgui.render(imgui.get_draw_data())\n\n    def __ui__(self) -&gt; None:\n\n        # Render status\n        imgui.text(f\"Resolution: {self.render_resolution} -&gt; {self.resolution} @ {self.ssaa:.2f}x SSAA\")\n\n        # Framerate\n        imgui.spacing()\n        if (state := imgui.slider_float(\"Framerate\", self.fps, 10, 240, \"%.0f\"))[0]:\n            self.fps = round(state[1])\n        for fps in (options := [24, 30, 60, 120, 144, 240]):\n            if (state := imgui.button(f\"{fps} Hz\")):\n                self.fps = fps\n            if fps != options[-1]:\n                imgui.same_line()\n\n        # Temporal\n        imgui.spacing()\n        if (state := imgui.slider_float(\"Time Scale\", self.tempo.target, -2, 2, \"%.2f\"))[0]:\n            self.tempo.target = state[1]\n        for scale in (options := [-10, -5, -2, -1, 0, 1, 2, 5, 10]):\n            if (state := imgui.button(f\"{scale}x\")):\n                self.tempo.target = scale\n            if scale != options[-1]:\n                imgui.same_line()\n\n        # SSAA\n        imgui.spacing()\n        if (state := imgui.slider_float(\"SSAA\", self.ssaa, 0.01, 2, \"%.2f\"))[0]:\n            self.ssaa = state[1]\n        for ssaa in (options := [0.1, 0.25, 0.5, 1.0, 1.25, 1.5, 2.0]):\n            if (state := imgui.button(f\"{ssaa}x\")):\n                self.ssaa = ssaa\n            if ssaa != options[-1]:\n                imgui.same_line()\n\n        # Quality\n        imgui.spacing()\n        if (state := imgui.slider_float(\"Quality\", self.quality, 0, 100, \"%.0f%%\"))[0]:\n            self.quality = state[1]\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__name__","title":"<code>__name__ = 'Scene'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.modules","title":"<code>modules: Deque[ShaderModule] = Factory(deque)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Deque of all Modules on the Scene, not a set for order preservation</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.scheduler","title":"<code>scheduler: BrokenScheduler = Factory(BrokenScheduler)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.vsync","title":"<code>vsync: BrokenTask = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.frametimer","title":"<code>frametimer: ShaderFrametimer = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.keyboard","title":"<code>keyboard: ShaderKeyboard = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.camera","title":"<code>camera: ShaderCamera = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.ffmpeg","title":"<code>ffmpeg: BrokenFFmpeg = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.shader","title":"<code>shader: ShaderObject = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The main ShaderObject of the Scene, the visible content of the Window</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.alpha","title":"<code>alpha: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Makes the final texture have an alpha channel, useful for transparent windows. Exporting videos might fail, perhaps output a Chroma Key compatible video - add this to the shader: - <code>fragColor.rgb = mix(vec3(0, 1, 0), fragColor.rgb, fragColor.a);</code></p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.quality","title":"<code>quality: float = field(default=50, converter=lambda x: clamp(x, 0, 100))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rendering Quality, if implemented - either on the GPU Shader or CPU Python side</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.typer","title":"<code>typer: BrokenTyper = Factory(lambda: BrokenTyper(chain=True))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>This Scene's BrokenTyper instance for the CLI. Commands are added by any module in the <code>self.commands</code> method. The <code>self.main</code> is always added to it</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __post__(self):\n    self.typer.description = (self.typer.description or self.__class__.__doc__)\n    self.typer._panel = \"\ud83d\udd25 Scene commands\"\n    self.typer.command(self.main, context=True)\n    self.build()\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.cli","title":"<code>cli(*args: List[Union[Any, str]])</code>","text":"<p>Interpret a list of arguments as actions, defined by the Scene's <code>self.commands</code> plus the <code>main</code> method. Must not start with <code>sys.executable</code>, so send <code>sys.argv[1:]</code> or direct</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def cli(self, *args: List[Union[Any, str]]):\n    \"\"\"Interpret a list of arguments as actions, defined by the Scene's `self.commands` plus\n    the `main` method. Must not start with `sys.executable`, so send `sys.argv[1:]` or direct\"\"\"\n    self.typer(flatten(args))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.build","title":"<code>build()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>@OnceTracker.decorator\ndef build(self):\n    imgui.create_context()\n    self.imguio = imgui.get_io()\n    self.imguio.font_global_scale = 1\n    self.imguio.fonts.add_font_from_file_ttf(\n        str(Broken.BROKEN.RESOURCES.FONTS/\"DejaVuSans.ttf\"),\n        16*self.imguio.font_global_scale,\n    )\n\n    # Default modules\n    self.init_window()\n    self.frametimer = ShaderFrametimer(scene=self)\n    self.keyboard = ShaderKeyboard(scene=self)\n    self.camera = ShaderCamera(scene=self)\n\n    # Create the SSAA Workaround engines\n    self._final = ShaderObject(scene=self, name=\"iFinal\")\n    self._final.texture.components = 3 + int(self.alpha)\n    self._final.texture.dtype = \"f1\"\n    self._final.texture.final = True\n    self._final.texture.track = True\n    self._final.fragment = (SHADERFLOW.RESOURCES.FRAGMENT/\"Final.glsl\")\n    self.shader = ShaderObject(scene=self, name=\"iScreen\")\n    self.shader.texture.track = True\n    self.shader.texture.repeat(False)\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.time","title":"<code>time: Seconds = field(default=0.0, converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current time in seconds. Ideally, everything should depend on time, for flexibility</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.tempo","title":"<code>tempo: float = Factory(lambda: DynamicNumber(value=1, frequency=3))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Time scale factor, used for <code>dt</code>, which integrates to <code>time</code></p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.runtime","title":"<code>runtime: Seconds = field(default=10.0, converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The longest module duration; overriden by the user; or default length of 10s</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.fps","title":"<code>fps: Hertz = field(default=60.0, converter=lambda x: max(float(x), 1.0))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target frames per second rendering speed</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.dt","title":"<code>dt: Seconds = field(default=0.0, converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Virtual delta time since last frame, time scaled by <code>tempo</code>. Use <code>self.rdt</code> for real delta</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.rdt","title":"<code>rdt: Seconds = field(default=0.0, converter=float)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Real life, physical delta time since last frame. Use <code>self.dt</code> for time scaled version</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.tau","title":"<code>tau: float</code>  <code>property</code>","text":"<p>Normalized time value relative to runtime between 0 and 1</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.cycle","title":"<code>cycle: float</code>  <code>property</code>","text":"<p>A number from 0 to 2pi that ends on the runtime ('normalized angular time')</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.frametime","title":"<code>frametime: Seconds</code>  <code>property</code> <code>writable</code>","text":"<p>Ideal time between two frames. This value is coupled with <code>fps</code></p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.frame","title":"<code>frame: int</code>  <code>property</code> <code>writable</code>","text":"<p>Current frame being rendered. This value is coupled with 'time' and 'fps'</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.duration","title":"<code>duration: Seconds</code>  <code>property</code>","text":"<p>Alias to self.runtime. Set both with <code>.set_duration()</code></p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.set_duration","title":"<code>set_duration(override: Seconds = None, *, minimum: Seconds = 10) -&gt; Seconds</code>","text":"<p>Either force the runtime to be 'override' or find the longest module lower bounded</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def set_duration(self, override: Seconds=None, *, minimum: Seconds=10) -&gt; Seconds:\n    \"\"\"Either force the runtime to be 'override' or find the longest module lower bounded\"\"\"\n    self.runtime = (override or minimum)\n    for module in (not bool(override)) * self.modules:\n        self.runtime = max(self.runtime, module.duration)\n    self.runtime /= self.tempo.value\n    return self.runtime\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.total_frames","title":"<code>total_frames: int</code>  <code>property</code>","text":"<p>The total frames this scene should render when exporting, if 'runtime' isn't changed</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.title","title":"<code>title: str</code>  <code>property</code> <code>writable</code>","text":"<p>Realtime window 'title' property</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.resizable","title":"<code>resizable: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Realtime window 'is resizable' property</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.visible","title":"<code>visible: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Realtime window 'is visible' property</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.fullscreen","title":"<code>fullscreen: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Window 'is fullscreen' property</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.exclusive","title":"<code>exclusive: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Window 'mouse exclusivity' property: Is the mouse cursor be locked to the window</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.monitor","title":"<code>monitor: int = os.getenv('MONITOR', 0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.glfw_monitor","title":"<code>glfw_monitor: Optional[glfw._GLFWmonitor]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.glfw_video_mode","title":"<code>glfw_video_mode: Optional[Dict]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.monitor_framerate","title":"<code>monitor_framerate: float</code>  <code>property</code>","text":"<p>Note: Defaults to 60 if no monitor is found</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.monitor_size","title":"<code>monitor_size: Optional[Tuple[int, int]]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.monitor_width","title":"<code>monitor_width: Optional[int]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.monitor_height","title":"<code>monitor_height: Optional[int]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.scale","title":"<code>scale: float</code>  <code>property</code> <code>writable</code>","text":"<p>Resolution scale factor, the <code>self.width</code> and <code>self.height</code> are multiplied by this</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.width","title":"<code>width: int</code>  <code>property</code> <code>writable</code>","text":"<p>Rendering width (horizontal size) of the Scene in pixels</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.height","title":"<code>height: int</code>  <code>property</code> <code>writable</code>","text":"<p>Rendering height (vertical size) of the Scene in pixels</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.ssaa","title":"<code>ssaa: float</code>  <code>property</code> <code>writable</code>","text":"<p>Fractional Super Sampling Anti-Aliasing (SSAA) factor. Improves the image quality (&gt;1) by rendering at a higher resolution and then downsampling, resulting in smoother edges at a significant GPU computational cost of O(N^2). Values lower than 1 (yield worse quality, but) are useful when the GPU can't keep up: when the resolution is too high or FPS is too low</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.resolution","title":"<code>resolution: Tuple[int, int]</code>  <code>property</code> <code>writable</code>","text":"<p>The resolution the Scene is rendering in pixels</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.render_resolution","title":"<code>render_resolution: Tuple[int, int]</code>  <code>property</code>","text":"<p>Internal 'true' rendering resolution for SSAA. Same as <code>self.resolution*self.ssaa</code></p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.aspect_ratio","title":"<code>aspect_ratio: float</code>  <code>property</code> <code>writable</code>","text":"<p>Either the forced <code>self._aspect_ratio</code> or dynamic from <code>self.width/self.height</code>. When set and resizing, the logic of <code>BrokenResolution.fit</code> is applied to enforce ratios</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.resize","title":"<code>resize(width: Union[int, float] = Unchanged, height: Union[int, float] = Unchanged, *, aspect_ratio: Union[Unchanged, float, str] = Unchanged, scale: float = Unchanged) -&gt; Tuple[int, int]</code>","text":"<p>Resize the true final rendering resolution of the Scene. Rounded to nearest multiple of 2, so FFmpeg is happy, and limited by the monitor resolution if realtime</p> <p>Parameters:</p> <ul> <li> <code>width</code>             (<code>Union[int, float]</code>, default:                 <code>Unchanged</code> )         \u2013          <p>New width of the Scene, None to not change</p> </li> <li> <code>height</code>             (<code>Union[int, float]</code>, default:                 <code>Unchanged</code> )         \u2013          <p>New height of the Scene, None to not change</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (            <code>Tuple[int, int]</code> )        \u2013          <p>Fluent interface</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def resize(self,\n    width: Union[int, float]=Unchanged,\n    height: Union[int, float]=Unchanged,\n    *,\n    aspect_ratio: Union[Unchanged, float, str]=Unchanged,\n    scale: float=Unchanged\n) -&gt; Tuple[int, int]:\n    \"\"\"\n    Resize the true final rendering resolution of the Scene. Rounded to nearest multiple of 2,\n    so FFmpeg is happy, and limited by the monitor resolution if realtime\n\n    Args:\n        width:  New width of the Scene, None to not change\n        height: New height of the Scene, None to not change\n\n    Returns:\n        Self: Fluent interface\n    \"\"\"\n\n    # Maybe update auxiliary properties\n    self.aspect_ratio = (aspect_ratio or self._aspect_ratio)\n    self._scale = (scale or self._scale)\n\n    # The parameters aren't trivial. The idea is to fit resolution from the scale-less components,\n    # so scaling isn't carried over, then to apply scaling (self.resolution)\n    resolution = BrokenResolution.fit(\n        old=(self._width, self._height),\n        new=(width, height),\n        max=(self.monitor_size),\n        ar=self._aspect_ratio\n    )\n\n    # Optimization: Only resize when resolution changes\n    if (resolution != (self.width, self.height)):\n        self._width, self._height = resolution\n        self.window.size = self.resolution\n        self.relay(ShaderMessage.Shader.RecreateTextures)\n        log.info(f\"{self.who} Resized Window to {self.resolution}\")\n\n    return self.resolution\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.backend","title":"<code>backend: WindowBackend = WindowBackend.get(os.getenv('WINDOW_BACKEND', WindowBackend.GLFW))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The ModernGL Window Backend. Cannot be changed after creation. Can also be set with the environment variable <code>WINDOW_BACKEND=&lt;backend&gt;</code>, where <code>backend = {glfw, headless}</code></p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.opengl","title":"<code>opengl: moderngl.Context = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ModernGL Context of this Scene. The thread accessing this MUST own or ENTER its context for creating, changing, deleting objects; more often than not, it's the Main thread</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.window","title":"<code>window: ModernglWindow = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ModernGL Window instance at <code>site-packages/moderngl_window.context.&lt;self.backend&gt;.Window</code></p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.imgui","title":"<code>imgui: ModernglImgui = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ModernGL Imgui integration class bound to the Window</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.imguio","title":"<code>imguio: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Imgui IO object</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.init_window","title":"<code>init_window() -&gt; None</code>","text":"<p>Create the window and the OpenGL context</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def init_window(self) -&gt; None:\n    \"\"\"Create the window and the OpenGL context\"\"\"\n    if self.window:\n        raise RuntimeError(\"Window backend cannot be changed after creation\")\n\n    # Use EGL for creating a OpenGL context, allows true headless with GPU acceleration\n    # Comments 2 and 6: (https://forums.developer.nvidia.com/t/81412)\n    # Note: For the cloud, see (https://brokensrc.dev/get/docker/)\n    backend = \"egl\" if (os.getenv(\"WINDOW_EGL\", \"1\") == \"1\") else None\n\n    # Dynamically import the ModernGL Window Backend and instantiate it. Vsync is on our side \ud83d\ude09\n    module = f\"moderngl_window.context.{denum(self.backend).lower()}\"\n    self.window = importlib.import_module(module).Window(\n        size=self.resolution,\n        title=self.title,\n        resizable=self.resizable,\n        visible=self.visible,\n        fullscreen=self.fullscreen,\n        vsync=False,\n        backend=backend\n    )\n    ShaderKeyboard.set_keymap(self.window.keys)\n    self.imgui  = ModernglImgui(self.window)\n    self.opengl = self.window.ctx\n\n    # Bind window events to relay\n    self.window.resize_func               = self.__window_resize__\n    self.window.close_func                = self.__window_close__\n    self.window.iconify_func              = self.__window_iconify__\n    self.window.key_event_func            = self.__window_key_event__\n    self.window.mouse_position_event_func = self.__window_mouse_position_event__\n    self.window.mouse_press_event_func    = self.__window_mouse_press_event__\n    self.window.mouse_release_event_func  = self.__window_mouse_release_event__\n    self.window.mouse_drag_event_func     = self.__window_mouse_drag_event__\n    self.window.mouse_scroll_event_func   = self.__window_mouse_scroll_event__\n    self.window.unicode_char_entered_func = self.__window_unicode_char_entered__\n    self.window.files_dropped_event_func  = self.__window_files_dropped_event__\n\n    if (self.backend == WindowBackend.GLFW):\n        BrokenThread.new(target=self.window.set_icon, icon_path=Broken.PROJECT.RESOURCES.ICON, daemon=True)\n        glfw.set_cursor_enter_callback(self.window._window, lambda _, enter: self.__window_mouse_enter_event__(inside=enter))\n        glfw.set_drop_callback(self.window._window, self.__window_files_dropped_event__)\n        ShaderKeyboard.Keys.LEFT_SHIFT = glfw.KEY_LEFT_SHIFT\n        ShaderKeyboard.Keys.LEFT_CTRL  = glfw.KEY_LEFT_CONTROL\n        ShaderKeyboard.Keys.LEFT_ALT   = glfw.KEY_LEFT_ALT\n\n    log.info(f\"OpenGL Renderer: {self.opengl.info['GL_RENDERER']}\")\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.read_screen","title":"<code>read_screen() -&gt; bytes</code>","text":"<p>Take a screenshot of the screen and return raw bytes. Length <code>width*height*components</code></p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def read_screen(self) -&gt; bytes:\n    \"\"\"Take a screenshot of the screen and return raw bytes. Length `width*height*components`\"\"\"\n    return self.window.fbo.read(viewport=(0, 0, self.width, self.height))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.directory","title":"<code>directory: Path</code>  <code>property</code>","text":"<p>Path of the current Scene file Python script. This works by searching up the call stack for the first context whose filename isn't the local file (of ShaderFlow.Scene)</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.read_file","title":"<code>read_file(file: Path, bytes: bool = False) -&gt; Union[str, bytes]</code>","text":"<p>Read a file relative to the current Scene Python script</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>Path</code>)         \u2013          <p>File to read, relative to the current Scene script directory</p> </li> <li> <code>bytes</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to read the file as bytes, defaults to text</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[str, bytes]</code>         \u2013          <p>File contents as text or bytes</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def read_file(self, file: Path, bytes: bool=False) -&gt; Union[str, bytes]:\n    \"\"\"\n    Read a file relative to the current Scene Python script\n\n    Args:\n        file:  File to read, relative to the current Scene script directory\n        bytes: Whether to read the file as bytes, defaults to text\n\n    Returns:\n        File contents as text or bytes\n    \"\"\"\n    file = (self.directory/file)\n    log.info(f\"{self.who} Reading file ({file})\")\n    return LoaderBytes(file) if bytes else LoaderString(file)\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.quit","title":"<code>quit: PlainTracker = Factory(lambda: PlainTracker(False))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Should the scene end the main event loop? Use as <code>if scene.quit():</code></p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.next","title":"<code>next(dt: float) -&gt; Self</code>","text":"<p>Integrate time, update all modules and render the next frame</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def next(self, dt: float) -&gt; Self:\n    \"\"\"Integrate time, update all modules and render the next frame\"\"\"\n\n    # Fixme: Windows: https://github.com/glfw/glfw/pull/1426\n    # Immediately swap the buffer with previous frame for vsync\n    self.window.swap_buffers()\n\n    # Temporal logic\n    dt = min(dt, 1)\n    self.tempo.next(dt=abs(dt))\n    self.vsync.fps = self.fps\n    self.dt    = dt * self.tempo\n    self.rdt   = dt\n    self.time += self.dt\n\n    # Note: Updates in reverse order of addition (child -&gt; parent)\n    # Note: Update non-engine first, as the pipeline might change\n    for module in self.modules:\n        if not isinstance(module, ShaderObject):\n            module.update()\n    for module in reversed(self.modules):\n        if isinstance(module, ShaderObject):\n            module.update()\n\n    self._render_ui()\n    return self\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.exporting","title":"<code>exporting: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Is this Scene exporting to a video file?</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.rendering","title":"<code>rendering: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Either Exporting, Rendering or Benchmarking. 'Not Realtime' mode</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.realtime","title":"<code>realtime: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Running with a window and user interaction</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.headless","title":"<code>headless: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Running Headlessly, without a window and user interaction</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.benchmark","title":"<code>benchmark: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Stress test the rendering speed of the Scene</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.repeat","title":"<code>repeat: int = field(default=1, converter=int)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of times to loop the exported video. One '1' is no repeat, two '2' doubles the length. Ideally have seamless transitions on the shader based on self.tau and/or/no audio input</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.export_batch","title":"<code>export_batch: Iterable[int] = field(factory=lambda: [0], converter=lambda x: list(x) or [0])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Batch indices iterable to export</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.export_index","title":"<code>export_index: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Current Batch exporting video index</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.export_format","title":"<code>export_format: str = field(default='mp4', converter=lambda x: str(denum(x)))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The last (or only) video export format (extension) to use</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.export_base","title":"<code>export_base: Path = field(default=Broken.PROJECT.DIRECTORIES.DATA, converter=lambda x: Path(x))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The last (or only) video export base directory. Videos should render to (base/name) if $name is plain, that is, the path isn't absolute</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.export_name","title":"<code>export_name(path: Path) -&gt; Path</code>  <code>abstractmethod</code>","text":"<p>Change the video file name being exported based on the current batch index. By default, the name is unchanged in single export, else the stem is appended with the batch index</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>@abstractmethod\ndef export_name(self, path: Path) -&gt; Path:\n    \"\"\"Change the video file name being exported based on the current batch index. By default,\n    the name is unchanged in single export, else the stem is appended with the batch index\"\"\"\n    if (len(self.export_batch) &gt; 1):\n        return path.with_stem(f\"{path.stem}_{self.export_index}\")\n    return path\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.main","title":"<code>main(width: Annotated[int, Option(--width, -w, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Width  of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1920 on init)[/dim]')] = None, height: Annotated[int, Option(--height, -h, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Height of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1080 on init)[/dim]')] = None, scale: Annotated[float, Option(--scale, -x, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Post-multiply width and height by a scale factor [medium_purple3](None to keep)[/medium_purple3] [dim](1.0 on init)[dim]')] = None, aspect: Annotated[str, Option(--ar, -R, help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Force resolution aspect ratio [green](Examples: '16:9', '16/9', '1.777')[/green] [medium_purple3](None for dynamic)[/medium_purple3]\")] = None, fps: Annotated[float, Option(--fps, -f, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Target frames per second [medium_purple3](Defaults to the monitor framerate on realtime else 60)[/medium_purple3]')] = None, fullscreen: Annotated[bool, Option(--fullscreen, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in fullscreen mode [medium_purple3](Toggle with F11)[/medium_purple3]')] = False, maximize: Annotated[bool, Option(--maximize, -M, help='[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in maximized mode')] = False, quality: Annotated[float, Option(--quality, -q, help='[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Shader quality level [green](0-100%)[/green] [yellow](If supported by the shader)[/yellow] [medium_purple3](None to keep, default 50%)[/medium_purple3]')] = None, ssaa: Annotated[float, Option(--ssaa, -s, help='[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Fractional super sampling anti aliasing factor [yellow](O(N^2) GPU cost)[/yellow] [medium_purple3](None to keep, default 1.0)[/medium_purple3]')] = None, render: Annotated[bool, Option(--render, -r, help='[green](\ud83d\udfe2 Export )[/green] Export the Scene to a video file [medium_purple3](defined on --output, and implicit if so)[/medium_purple3]')] = False, output: Annotated[str, Option(--output, -o, help=\"[green](\ud83d\udfe2 Export )[/green] Output file name [green]('Absolute', 'Relative path', 'Plain Name')[/green] [dim]($base/$(plain_name or $scene-$date))[/dim]\")] = None, time: Annotated[float, Option(--time, -t, help=\"[green](\ud83d\udfe2 Export )[/green] The duration of exported videos [dim](Loop duration)[/dim] [medium_purple3](defaults to 10 or longest module's duration)[/medium_purple3]\")] = None, tempo: Annotated[float, Option(--tempo, -T, help='[green](\ud83d\udfe2 Export )[/green] Set the time speed factor of the Scene [yellow](Final duration is stretched by [italic]1/tempo[/italic])[/yellow] [dim](1 on init)[/dim]')] = None, repeat: Annotated[int, Option(--repeat, help='[green](\ud83d\udfe2 Export )[/green] Number of exported videos loop copies [yellow](Final duration is stretched by [italic]repeat[/italic])[/yellow] [dim](1 on init)[/dim]')] = None, format: Annotated[str, Option(--format, -F, help=\"[green](\ud83d\udfe2 Export )[/green] Output video container [green]('mp4', 'mkv', 'webm', 'avi, '...')[/green] [yellow](Overrides --output one)[/yellow]\")] = 'mp4', base: Annotated[Path, Option(--base, -D, help='[green](\ud83d\udfe2 Export )[/green] Output file base directory')] = Broken.PROJECT.DIRECTORIES.DATA, vcodec: Annotated[str, Option(--vcodec, -c, help=\"[green](\ud83d\udfe2 Export )[/green] Video codec [green]('h264', 'h264-nvenc', 'h265, 'hevc-nvenc', 'vp9', 'av1-{aom,svt,nvenc,rav1e}')[/green]\")] = 'h264', acodec: Annotated[str, Option(--acodec, -a, help=\"[green](\ud83d\udfe2 Export )[/green] Audio codec [green]('aac', 'mp3', 'flac', 'wav', 'opus', 'ogg', 'copy', 'none', 'empty')[/green]\")] = 'copy', batch: Annotated[str, Option(--batch, -b, help='[bold][blue](\ud83d\udd35 Special)[/blue][/bold] [dim][WIP] Hyphenated indices range to export multiple videos, if implemented. (1,5-7,10)[/dim]')] = '0', benchmark: Annotated[bool, Option(--benchmark, -B, help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Benchmark the Scene's speed on raw rendering [medium_purple3](Use SKIP_GPU=1 for CPU only benchmark)[/medium_purple3]\")] = False, raw: Annotated[bool, Option(--raw, help='[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Send raw OpenGL frames before GPU SSAA to FFmpeg [medium_purple3](Enabled if SSAA &lt; 1)[/medium_purple3] [dim](CPU Downsampling)[/dim]')] = False, open: Annotated[bool, Option(--open, help='[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Open the directory of video exports after all rendering finishes')] = False) -&gt; Optional[List[Path]]</code>","text":"<p>Main event loop of this ShaderFlow Scene. Start a realtime window, exports to video, stress test speeds</p> <p>\u2022 Note: For advanced video or audio codec configuration, modify it on 'self.ffmpeg' maybe inheriting this base class</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def main(self,\n    width:      Annotated[int,   Option(\"--width\",      \"-w\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Width  of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1920 on init)[/dim]\")]=None,\n    height:     Annotated[int,   Option(\"--height\",     \"-h\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Height of the rendering resolution [medium_purple3](None to keep or find by Aspect Ratio)[/medium_purple3] [dim](1080 on init)[/dim]\")]=None,\n    scale:      Annotated[float, Option(\"--scale\",      \"-x\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Post-multiply width and height by a scale factor [medium_purple3](None to keep)[/medium_purple3] [dim](1.0 on init)[dim]\")]=None,\n    aspect:     Annotated[str,   Option(\"--ar\",         \"-R\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Force resolution aspect ratio [green](Examples: '16:9', '16/9', '1.777')[/green] [medium_purple3](None for dynamic)[/medium_purple3]\")]=None,\n    fps:        Annotated[float, Option(\"--fps\",        \"-f\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Target frames per second [medium_purple3](Defaults to the monitor framerate on realtime else 60)[/medium_purple3]\")]=None,\n    fullscreen: Annotated[bool,  Option(\"--fullscreen\",       help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in fullscreen mode [medium_purple3](Toggle with F11)[/medium_purple3]\")]=False,\n    maximize:   Annotated[bool,  Option(\"--maximize\",   \"-M\", help=\"[bold][red](\ud83d\udd34 Basic  )[/red][/bold] Start the real time window in maximized mode\")]=False,\n    quality:    Annotated[float, Option(\"--quality\",    \"-q\", help=\"[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Shader quality level [green](0-100%)[/green] [yellow](If supported by the shader)[/yellow] [medium_purple3](None to keep, default 50%)[/medium_purple3]\")]=None,\n    ssaa:       Annotated[float, Option(\"--ssaa\",       \"-s\", help=\"[bold][yellow](\ud83d\udfe1 Quality)[/yellow][/bold] Fractional super sampling anti aliasing factor [yellow](O(N^2) GPU cost)[/yellow] [medium_purple3](None to keep, default 1.0)[/medium_purple3]\")]=None,\n    render:     Annotated[bool,  Option(\"--render\",     \"-r\", help=\"[green](\ud83d\udfe2 Export )[/green] Export the Scene to a video file [medium_purple3](defined on --output, and implicit if so)[/medium_purple3]\")]=False,\n    output:     Annotated[str,   Option(\"--output\",     \"-o\", help=\"[green](\ud83d\udfe2 Export )[/green] Output file name [green]('Absolute', 'Relative path', 'Plain Name')[/green] [dim]($base/$(plain_name or $scene-$date))[/dim]\")]=None,\n    time:       Annotated[float, Option(\"--time\",       \"-t\", help=\"[green](\ud83d\udfe2 Export )[/green] The duration of exported videos [dim](Loop duration)[/dim] [medium_purple3](defaults to 10 or longest module's duration)[/medium_purple3]\")]=None,\n    tempo:      Annotated[float, Option(\"--tempo\",      \"-T\", help=\"[green](\ud83d\udfe2 Export )[/green] Set the time speed factor of the Scene [yellow](Final duration is stretched by [italic]1/tempo[/italic])[/yellow] [dim](1 on init)[/dim]\")]=None,\n    repeat:     Annotated[int,   Option(\"--repeat\",           help=\"[green](\ud83d\udfe2 Export )[/green] Number of exported videos loop copies [yellow](Final duration is stretched by [italic]repeat[/italic])[/yellow] [dim](1 on init)[/dim]\")]=None,\n    format:     Annotated[str,   Option(\"--format\",     \"-F\", help=\"[green](\ud83d\udfe2 Export )[/green] Output video container [green]('mp4', 'mkv', 'webm', 'avi, '...')[/green] [yellow](Overrides --output one)[/yellow]\")]=\"mp4\",\n    base:       Annotated[Path,  Option(\"--base\",       \"-D\", help=\"[green](\ud83d\udfe2 Export )[/green] Output file base directory\")]=Broken.PROJECT.DIRECTORIES.DATA,\n    vcodec:     Annotated[str,   Option(\"--vcodec\",     \"-c\", help=\"[green](\ud83d\udfe2 Export )[/green] Video codec [green]('h264', 'h264-nvenc', 'h265, 'hevc-nvenc', 'vp9', 'av1-{aom,svt,nvenc,rav1e}')[/green]\")]=\"h264\",\n    acodec:     Annotated[str,   Option(\"--acodec\",     \"-a\", help=\"[green](\ud83d\udfe2 Export )[/green] Audio codec [green]('aac', 'mp3', 'flac', 'wav', 'opus', 'ogg', 'copy', 'none', 'empty')[/green]\")]=\"copy\",\n    batch:      Annotated[str,   Option(\"--batch\",      \"-b\", help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] [dim][WIP] Hyphenated indices range to export multiple videos, if implemented. (1,5-7,10)[/dim]\")]=\"0\",\n    benchmark:  Annotated[bool,  Option(\"--benchmark\",  \"-B\", help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Benchmark the Scene's speed on raw rendering [medium_purple3](Use SKIP_GPU=1 for CPU only benchmark)[/medium_purple3]\")]=False,\n    raw:        Annotated[bool,  Option(\"--raw\",              help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Send raw OpenGL frames before GPU SSAA to FFmpeg [medium_purple3](Enabled if SSAA &lt; 1)[/medium_purple3] [dim](CPU Downsampling)[/dim]\")]=False,\n    open:       Annotated[bool,  Option(\"--open\",             help=\"[bold][blue](\ud83d\udd35 Special)[/blue][/bold] Open the directory of video exports after all rendering finishes\")]=False,\n) -&gt; Optional[List[Path]]:\n    \"\"\"\n    Main event loop of this ShaderFlow Scene. Start a realtime window, exports to video, stress test speeds\n\n    \u2022 Note: For advanced video or audio codec configuration, modify it on 'self.ffmpeg' maybe inheriting this base class\n    \"\"\"\n    outputs: List[Path] = []\n\n    from arrow import now as arrow_now\n    export_started = arrow_now().format(\"YYYY-MM-DD HH-mm-ss\")\n\n    # Maybe update indices of exporting videos\n    self.export_batch  = hyphen_range(batch) or self.export_batch\n    self.export_format = format\n    self.export_base   = base\n\n    for index in self.export_batch:\n        self.export_index = index\n        self.exporting  = (render or bool(output))\n        self.rendering  = (self.exporting or benchmark)\n        self.realtime   = (not self.rendering)\n        self.benchmark  = benchmark\n        self.headless   = (self.rendering)\n        self.fps        = (fps or self.monitor_framerate)\n        self.title      = f\"ShaderFlow | {self.__name__}\"\n        self.quality    = quality or self.quality\n        self.repeat     = repeat or self.repeat\n        self.ssaa       = ssaa or self.ssaa\n        self.fullscreen = fullscreen\n        self.time       = 0\n        self.tempo.set(tempo or self.tempo.value)\n\n        for module in self.modules:\n            module.setup()\n\n        self.relay(ShaderMessage.Shader.Compile)\n        self.set_duration(time)\n\n        # Maybe keep or force aspect ratio, and find best resolution\n        width, height = self.resize(width=width, height=height, scale=scale, aspect_ratio=aspect)\n\n        # Optimization: Save bandwidth by piping native frames on ssaa &lt; 1\n        if self.rendering and (raw or self.ssaa &lt; 1):\n            self.resolution = self.render_resolution\n            self.ssaa = 1\n\n        # Configure FFmpeg and Popen it\n        if (self.rendering):\n            export = Path(output or f\"({export_started}) {self.__name__}\")\n            export = export if export.is_absolute() else (self.export_base/export)\n            export = export.with_suffix(\".\" + (self.export_format or export.suffix).replace(\".\", \"\"))\n            export = self.export_name(export)\n\n            self.ffmpeg = (BrokenFFmpeg(time=self.runtime).quiet()\n                .pipe_input(pixel_format=(\"rgba\" if self.alpha else \"rgb24\"),\n                    width=self.width, height=self.height, framerate=self.fps)\n                .scale(width=width, height=height)\n                .output(path=export)\n            )\n\n            # Apply default good codec options on the video\n            self.ffmpeg.apply_vcodec_str(vcodec)\n            self.ffmpeg.apply_acodec_str(acodec)\n\n            for module in self.modules:\n                if module is self: continue\n                module.ffmpeg(self.ffmpeg)\n\n            if self.exporting:\n                buffer = self.opengl.buffer(reserve=self._final.texture.size_t)\n                self.ffmpeg = self.ffmpeg.popen(stdin=PIPE)\n\n            # Status tracker\n            status = DotMap(\n                start=perf_counter(),\n                bar=tqdm.tqdm(\n                    total=self.total_frames,\n                    desc=f\"Scene #{self.export_index} ({type(self).__name__}) \u2192 Video\",\n                    dynamic_ncols=True,\n                    colour=\"#43BFEF\",\n                    leave=False,\n                    unit=\" frames\",\n                    mininterval=1/30,\n                    maxinterval=0.1,\n                    smoothing=0.1,\n                )\n            )\n\n        # Some scenes might take a while to setup\n        self.visible = not self.headless\n\n        if (self.backend == WindowBackend.GLFW and maximize):\n            glfw.maximize_window(self.window._window)\n\n        # Add self.next to the event loop\n        self.vsync = self.scheduler.new(\n            task=self.next,\n            frequency=self.fps,\n            freewheel=self.rendering,\n            precise=True,\n        )\n\n        # Main rendering loop\n        while (self.rendering) or (not self.quit()):\n            task = self.scheduler.next()\n\n            # Only continue if exporting\n            if (task.output is not self):\n                continue\n            if self.realtime:\n                continue\n            status.bar.update(1)\n\n            # Write a new frame to FFmpeg\n            if self.exporting:\n                self._final.texture.fbo().read_into(buffer)\n                turbopipe.pipe(buffer, self.ffmpeg.stdin.fileno())\n\n            # Finish exporting condition\n            if (status.bar.n &lt; self.total_frames):\n                continue\n            status.bar.close()\n\n            if self.exporting:\n                log.info(\"Waiting for FFmpeg process to finish (Queued writes, codecs lookahead, buffers, etc)\")\n                turbopipe.close()\n                self.ffmpeg.stdin.close()\n                outputs.append(export)\n\n            # Repeat the video N times\n            if (self.repeat &gt; 1):\n                log.info(f\"Repeating video ({self.repeat-1} times)\")\n                export.rename(temporary := export.with_stem(f\"{export.stem}-repeat\"))\n                (BrokenFFmpeg(stream_loop=(self.repeat-1)).quiet().copy_audio().copy_video()\n                    .input(temporary).output(export, pixel_format=None).run())\n                temporary.unlink()\n\n            # Log stats\n            status.took = (perf_counter() - status.start)\n            log.info(f\"Finished rendering ({export})\", echo=not self.benchmark)\n            log.info((\n                f\"\u2022 Stats: \"\n                f\"(Took {status.took:.2f} s) at \"\n                f\"({self.frame/status.took:.2f} FPS | \"\n                f\"{self.runtime/status.took:.2f} x Realtime) with \"\n                f\"({status.bar.n} Total Frames)\"\n            ))\n\n            if self.benchmark:\n                return None\n            break\n\n    BrokenPath.open_in_file_explorer(outputs[0].parent) if open else None\n    return outputs\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.handle","title":"<code>handle(message: ShaderMessage) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def handle(self, message: ShaderMessage) -&gt; None:\n\n    if isinstance(message, ShaderMessage.Window.Close):\n        log.info(f\"{self.who} Received Window Close Event\")\n        self.quit(True)\n\n    elif isinstance(message, ShaderMessage.Keyboard.KeyDown):\n        if message.key == ShaderKeyboard.Keys.O:\n            log.info(f\"{self.who} (O  ) Resetting the Scene\")\n            for module in self.modules:\n                module.setup()\n            self.time = 0\n\n        elif message.key == ShaderKeyboard.Keys.R:\n            log.info(f\"{self.who} (R  ) Reloading Shaders\")\n            for module in self.modules:\n                if isinstance(module, ShaderObject):\n                    module.compile()\n\n        elif message.key == ShaderKeyboard.Keys.TAB:\n            log.info(f\"{self.who} (TAB) Toggling Menu\")\n            self.render_ui = not self.render_ui\n\n        elif message.key == ShaderKeyboard.Keys.F1:\n            log.info(f\"{self.who} (F1 ) Toggling Exclusive Mode\")\n            self.exclusive = not self.exclusive\n\n        elif message.key == ShaderKeyboard.Keys.F2:\n            import arrow\n            time  = arrow.now().format(\"YYYY-MM-DD_HH-mm-ss\")\n            image = PIL.Image.frombytes(\"RGB\", self.resolution, self.read_screen())\n            image = image.transpose(PIL.Image.FLIP_TOP_BOTTOM)\n            path  = Broken.PROJECT.DIRECTORIES.SCREENSHOTS/f\"({time}) {self.__name__}.png\"\n            log.minor(f\"{self.who} (F2 ) Saving Screenshot to ({path})\")\n            BrokenThread.new(target=image.save, fp=path)\n\n        elif message.key == ShaderKeyboard.Keys.F11:\n            log.info(f\"{self.who} (F11) Toggling Fullscreen\")\n            self.fullscreen = not self.fullscreen\n\n    elif isinstance(message, (ShaderMessage.Mouse.Drag, ShaderMessage.Mouse.Position)):\n        self.mouse_gluv = (message.u, message.v)\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    yield ShaderVariable(\"uniform\", \"float\", \"iTime\",        self.time)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDuration\",    self.duration)\n    yield ShaderVariable(\"uniform\", \"float\", \"iDeltaTime\",   self.dt)\n    yield ShaderVariable(\"uniform\", \"vec2\",  \"iResolution\",  self.resolution)\n    yield ShaderVariable(\"uniform\", \"float\", \"iWantAspect\",  self.aspect_ratio)\n    yield ShaderVariable(\"uniform\", \"float\", \"iQuality\",     self.quality/100)\n    yield ShaderVariable(\"uniform\", \"float\", \"iSSAA\",        self.ssaa)\n    yield ShaderVariable(\"uniform\", \"float\", \"iFrameRate\",   self.fps)\n    yield ShaderVariable(\"uniform\", \"int\",   \"iFrame\",       self.frame)\n    yield ShaderVariable(\"uniform\", \"bool\",  \"iRealtime\",    self.realtime)\n    yield ShaderVariable(\"uniform\", \"vec2\",  \"iMouse\",       self.mouse_gluv)\n    yield ShaderVariable(\"uniform\", \"bool\",  \"iMouseInside\", self.mouse_inside)\n    for i in range(1, 6):\n        yield ShaderVariable(\"uniform\", \"bool\", f\"iMouse{i}\", self.mouse_buttons[i])\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_resize__","title":"<code>__window_resize__(width: int, height: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_resize__(self, width: int, height: int) -&gt; None:\n\n    # Don't listen to resizes when exporting, as the final resolution might be\n    # greater than the monitor and the window will resize down to fit\n    if self.exporting:\n        return\n    self.imgui.resize(width, height)\n    self._width, self._height = width, height\n    self.relay(ShaderMessage.Shader.RecreateTextures)\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_close__","title":"<code>__window_close__() -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_close__(self) -&gt; None:\n    self.relay(ShaderMessage.Window.Close())\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_iconify__","title":"<code>__window_iconify__(state: bool) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_iconify__(self, state: bool) -&gt; None:\n    self.relay(ShaderMessage.Window.Iconify(state=state))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_files_dropped_event__","title":"<code>__window_files_dropped_event__(*stuff: list[str]) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_files_dropped_event__(self, *stuff: list[str]) -&gt; None:\n    self.relay(ShaderMessage.Window.FileDrop(files=stuff[1]))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_key_event__","title":"<code>__window_key_event__(key: int, action: int, modifiers: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_key_event__(self, key: int, action: int, modifiers: int) -&gt; None:\n    self.imgui.key_event(key, action, modifiers)\n    if self.imguio.want_capture_keyboard and self.render_ui:\n        return\n    if action == ShaderKeyboard.Keys.ACTION_PRESS:\n        self.relay(ShaderMessage.Keyboard.KeyDown(key=key, modifiers=modifiers))\n    elif action == ShaderKeyboard.Keys.ACTION_RELEASE:\n        self.relay(ShaderMessage.Keyboard.KeyUp(key=key, modifiers=modifiers))\n    self.relay(ShaderMessage.Keyboard.Press(key=key, action=action, modifiers=modifiers))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_unicode_char_entered__","title":"<code>__window_unicode_char_entered__(char: str) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_unicode_char_entered__(self, char: str) -&gt; None:\n    if self.imguio.want_capture_keyboard and self.render_ui:\n        return\n    self.relay(ShaderMessage.Keyboard.Unicode(char=char))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.mouse_gluv","title":"<code>mouse_gluv: Tuple[float, float] = Factory(lambda: (0, 0))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__xy2uv__","title":"<code>__xy2uv__(x: int = 0, y: int = 0) -&gt; dict[str, float]</code>","text":"<p>Convert a XY pixel coordinate into a Center-UV normalized coordinate</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __xy2uv__(self, x: int=0, y: int=0) -&gt; dict[str, float]:\n    \"\"\"Convert a XY pixel coordinate into a Center-UV normalized coordinate\"\"\"\n    return dict(\n        u=2*(x/self.width  - 0.5),\n        v=2*(y/self.height - 0.5)*(-1),\n        x=x, y=y,\n    )\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__dxdy2dudv__","title":"<code>__dxdy2dudv__(dx: int = 0, dy: int = 0) -&gt; dict[str, float]</code>","text":"<p>Convert a dx dy pixel coordinate into a Center-UV normalized coordinate</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __dxdy2dudv__(self, dx: int=0, dy: int=0) -&gt; dict[str, float]:\n    \"\"\"Convert a dx dy pixel coordinate into a Center-UV normalized coordinate\"\"\"\n    return dict(\n        du=2*(dx/self.width)*(self.width/self.height),\n        dv=2*(dy/self.height)*(-1),\n        dx=dx, dy=dy,\n    )\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.mouse_buttons","title":"<code>mouse_buttons: Dict[int, bool] = Factory(lambda: {k: Falsefor k in range(1, 6)})</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_mouse_press_event__","title":"<code>__window_mouse_press_event__(x: int, y: int, button: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_press_event__(self, x: int, y: int, button: int) -&gt; None:\n    self.imgui.mouse_press_event(x, y, button)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n    self.mouse_buttons[button] = True\n    self.relay(ShaderMessage.Mouse.Press(\n        **self.__xy2uv__(x, y),\n        button=button\n    ))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_mouse_release_event__","title":"<code>__window_mouse_release_event__(x: int, y: int, button: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_release_event__(self, x: int, y: int, button: int) -&gt; None:\n    self.imgui.mouse_release_event(x, y, button)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n    self.mouse_buttons[button] = False\n    self.relay(ShaderMessage.Mouse.Release(\n        **self.__xy2uv__(x, y),\n        button=button\n    ))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.mouse_inside","title":"<code>mouse_inside: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_mouse_enter_event__","title":"<code>__window_mouse_enter_event__(inside: bool) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_enter_event__(self, inside: bool) -&gt; None:\n    self.mouse_inside = inside\n    self.relay(ShaderMessage.Mouse.Enter(state=inside))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_mouse_scroll_event__","title":"<code>__window_mouse_scroll_event__(dx: int, dy: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_scroll_event__(self, dx: int, dy: int) -&gt; None:\n    self.imgui.mouse_scroll_event(dx, dy)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n    elif self.keyboard(ShaderKeyboard.Keys.LEFT_ALT):\n        self.tempo.target += (dy)*0.2\n        return\n    self.relay(ShaderMessage.Mouse.Scroll(\n        **self.__dxdy2dudv__(dx=dx, dy=dy)\n    ))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_mouse_position_event__","title":"<code>__window_mouse_position_event__(x: int, y: int, dx: int, dy: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_position_event__(self, x: int, y: int, dx: int, dy: int) -&gt; None:\n    self.imgui.mouse_position_event(x, y, dx, dy)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n    self.relay(ShaderMessage.Mouse.Position(\n        **self.__dxdy2dudv__(dx=dx, dy=dy),\n        **self.__xy2uv__(x=x, y=y)\n    ))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__window_mouse_drag_event__","title":"<code>__window_mouse_drag_event__(x: int, y: int, dx: int, dy: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __window_mouse_drag_event__(self, x: int, y: int, dx: int, dy: int) -&gt; None:\n    self.imgui.mouse_drag_event(x, y, dx, dy)\n    if self.imguio.want_capture_mouse and self.render_ui:\n        return\n\n    # Rotate the camera on Shift\n    if self.keyboard(ShaderKeyboard.Keys.LEFT_CTRL):\n        cx, cy = (x-self.width/2), (y-self.height/2)\n        angle = math.atan2(cy+dy, cx+dx) - math.atan2(cy, cx)\n        if (abs(angle) &gt; math.pi): angle -= 2*math.pi\n        self.camera.rotate(self.camera.base_z, angle=math.degrees(angle))\n        return\n\n    elif self.exclusive:\n        self.camera.apply_zoom(-dy/500)\n        self.camera.rotate(self.camera.base_z, angle=-dx/10)\n        return\n\n    # Time Travel on Alt\n    elif self.keyboard(ShaderKeyboard.Keys.LEFT_ALT):\n        self.time -= self._mouse_drag_time_factor * (dy/self.height)\n        return\n\n    self.relay(ShaderMessage.Mouse.Drag(\n        **self.__dxdy2dudv__(dx=dx, dy=dy),\n        **self.__xy2uv__(x=x, y=y)\n    ))\n</code></pre>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.render_ui","title":"<code>render_ui: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to render the Main UI</p>"},{"location":"shaderflow/reference/scene/#Scene.ShaderScene.__ui__","title":"<code>__ui__() -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Scene.py</code> Python<pre><code>def __ui__(self) -&gt; None:\n\n    # Render status\n    imgui.text(f\"Resolution: {self.render_resolution} -&gt; {self.resolution} @ {self.ssaa:.2f}x SSAA\")\n\n    # Framerate\n    imgui.spacing()\n    if (state := imgui.slider_float(\"Framerate\", self.fps, 10, 240, \"%.0f\"))[0]:\n        self.fps = round(state[1])\n    for fps in (options := [24, 30, 60, 120, 144, 240]):\n        if (state := imgui.button(f\"{fps} Hz\")):\n            self.fps = fps\n        if fps != options[-1]:\n            imgui.same_line()\n\n    # Temporal\n    imgui.spacing()\n    if (state := imgui.slider_float(\"Time Scale\", self.tempo.target, -2, 2, \"%.2f\"))[0]:\n        self.tempo.target = state[1]\n    for scale in (options := [-10, -5, -2, -1, 0, 1, 2, 5, 10]):\n        if (state := imgui.button(f\"{scale}x\")):\n            self.tempo.target = scale\n        if scale != options[-1]:\n            imgui.same_line()\n\n    # SSAA\n    imgui.spacing()\n    if (state := imgui.slider_float(\"SSAA\", self.ssaa, 0.01, 2, \"%.2f\"))[0]:\n        self.ssaa = state[1]\n    for ssaa in (options := [0.1, 0.25, 0.5, 1.0, 1.25, 1.5, 2.0]):\n        if (state := imgui.button(f\"{ssaa}x\")):\n            self.ssaa = ssaa\n        if ssaa != options[-1]:\n            imgui.same_line()\n\n    # Quality\n    imgui.spacing()\n    if (state := imgui.slider_float(\"Quality\", self.quality, 0, 100, \"%.0f%%\"))[0]:\n        self.quality = state[1]\n</code></pre>"},{"location":"shaderflow/reference/shader/","title":"Shader","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/shader/#Shader","title":"<code>Shader</code>","text":""},{"location":"shaderflow/reference/shader/#Shader.WATCHDOG","title":"<code>Shader.WATCHDOG = watchdog.observers.Observer()</code>  <code>module-attribute</code>","text":""},{"location":"shaderflow/reference/shader/#Shader.ShaderDumper","title":"<code>Shader.ShaderDumper</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>@define\nclass ShaderDumper:\n    shader: ShaderObject # Fixme: Extending a parent class with refactored functionality\n    \"\"\"Parent ShaderObject instance\"\"\"\n\n    error: str\n    \"\"\"str(_moderngl.Error) exception\"\"\"\n\n    fragment: str\n    \"\"\"Potentially faulty Fragment shader\"\"\"\n\n    vertex: str\n    \"\"\"Potentially faulty Vertex shader\"\"\"\n\n    context: int = 5\n    \"\"\"Number of lines to show before and after the faulty line\"\"\"\n\n    _parser = re.compile(r\"^0\\((\\d+)\\)\\s*:\\s*error\\s* (\\w+):\\s(.*)\", re.MULTILINE)\n\n    @property\n    def code(self) -&gt; str:\n        \"\"\"Simple heuristic to choose what shader cause the error\"\"\"\n        if (\"fragment_shader\" in self.error):\n            return self.fragment\n        elif (\"vertex_shader\" in self.error):\n            return self.vertex\n        raise RuntimeError(f\"Cannot determine shader from error: {self.error}\")\n\n    @property\n    def lines(self) -&gt; List[str]:\n        return self.code.splitlines()\n\n    def dump(self):\n        directory = Broken.PROJECT.DIRECTORIES.DUMP\n        log.error(f\"{self.shader.who} Dumping shaders to {directory}\")\n        (directory/f\"{self.shader.uuid}.frag\").write_text(self.fragment, encoding=\"utf-8\")\n        (directory/f\"{self.shader.uuid}.vert\").write_text(self.vertex, encoding=\"utf-8\")\n        (directory/f\"{self.shader.uuid}-error.md\" ).write_text(self.error, encoding=\"utf-8\")\n\n        # Visual only: Print highlighted code panels of all errors\n        for match in ShaderDumper._parser.finditer(self.error):\n            lineno, errno, message = match.groups()\n            lineno = int(lineno)\n            start  = max(0, lineno - self.context - 1)\n            end    = min(len(self.lines), lineno + self.context)\n            code   = []\n\n            for i, line in enumerate(self.lines[start:end]):\n                div = (\"&gt;\" if (i == lineno) else \"|\")\n                code.append(f\"({i+start+1:3d}) {div} {line}\")\n\n            rich.print(Panel(\n                Syntax(code='\\n'.join(code), lexer=\"glsl\"),\n                title=f\"({errno} at Module #{self.shader.uuid}, Line {lineno}): {message}\",\n            ))\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderDumper.shader","title":"<code>shader: ShaderObject</code>  <code>instance-attribute</code>","text":"<p>Parent ShaderObject instance</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderDumper.error","title":"<code>error: str</code>  <code>instance-attribute</code>","text":"<p>str(_moderngl.Error) exception</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderDumper.fragment","title":"<code>fragment: str</code>  <code>instance-attribute</code>","text":"<p>Potentially faulty Fragment shader</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderDumper.vertex","title":"<code>vertex: str</code>  <code>instance-attribute</code>","text":"<p>Potentially faulty Vertex shader</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderDumper.context","title":"<code>context: int = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of lines to show before and after the faulty line</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderDumper.code","title":"<code>code: str</code>  <code>property</code>","text":"<p>Simple heuristic to choose what shader cause the error</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderDumper.lines","title":"<code>lines: List[str]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/shader/#Shader.ShaderDumper.dump","title":"<code>dump()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def dump(self):\n    directory = Broken.PROJECT.DIRECTORIES.DUMP\n    log.error(f\"{self.shader.who} Dumping shaders to {directory}\")\n    (directory/f\"{self.shader.uuid}.frag\").write_text(self.fragment, encoding=\"utf-8\")\n    (directory/f\"{self.shader.uuid}.vert\").write_text(self.vertex, encoding=\"utf-8\")\n    (directory/f\"{self.shader.uuid}-error.md\" ).write_text(self.error, encoding=\"utf-8\")\n\n    # Visual only: Print highlighted code panels of all errors\n    for match in ShaderDumper._parser.finditer(self.error):\n        lineno, errno, message = match.groups()\n        lineno = int(lineno)\n        start  = max(0, lineno - self.context - 1)\n        end    = min(len(self.lines), lineno + self.context)\n        code   = []\n\n        for i, line in enumerate(self.lines[start:end]):\n            div = (\"&gt;\" if (i == lineno) else \"|\")\n            code.append(f\"({i+start+1:3d}) {div} {line}\")\n\n        rich.print(Panel(\n            Syntax(code='\\n'.join(code), lexer=\"glsl\"),\n            title=f\"({errno} at Module #{self.shader.uuid}, Line {lineno}): {message}\",\n        ))\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject","title":"<code>Shader.ShaderObject</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>@define\nclass ShaderObject(ShaderModule):\n    version: int = 330\n    \"\"\"OpenGL Version to use for the shader. Must be &lt;= than the Window Backend version\"\"\"\n\n    program: moderngl.Program = None\n    \"\"\"ModernGL 'Compiled Shaders' object\"\"\"\n\n    vao: moderngl.VertexArray = None\n    \"\"\"Buffer object for the vertices of the shader\"\"\"\n\n    vbo: moderngl.Buffer = None\n    \"\"\"Buffer object for the vertices of the shader\"\"\"\n\n    texture: ShaderTexture = None\n    \"\"\"ShaderTexture Module that this Shader renders to in layers and temporal\"\"\"\n\n    clear: bool = False\n    \"\"\"Clear the Final Texture before rendering\"\"\"\n\n    instances: int = 1\n    \"\"\"Number of gl_InstanceID's to render\"\"\"\n\n    vertices: List[float] = Factory(list)\n    \"\"\"Vertices of the shader. More often than not, a Fullscreen Quad\"\"\"\n\n    vertex_variables: Set[ShaderVariable] = Factory(set)\n    \"\"\"Variables metaprogramming that will be added to the Vertex Shader\"\"\"\n\n    fragment_variables: Set[ShaderVariable] = Factory(set)\n    \"\"\"Variables metaprogramming that will be added to the Fragment Shader\"\"\"\n\n    def __post__(self):\n        \"\"\"Set default values for some variables\"\"\"\n        self.texture = ShaderTexture(scene=self.scene, name=self.name, track=True)\n        self.fragment_variable(\"out vec4 fragColor\")\n        self.vertex_variable(\"in vec2 vertex_position\")\n        self.vertex_variable(\"in vec2 vertex_gluv\")\n        self.passthrough(\"flat int instance\")\n        self.passthrough(\"vec2 gluv\")\n        self.passthrough(\"vec2 stuv\")\n        self.passthrough(\"vec2 astuv\")\n        self.passthrough(\"vec2 agluv\")\n        self.passthrough(\"vec2 fragCoord\")\n        self.passthrough(\"vec2 glxy\")\n        self.passthrough(\"vec2 stxy\")\n\n        # Add a fullscreen center-(0, 0) uv rectangle\n        for x, y in itertools.product((-1, 1), (-1, 1)):\n            self.add_vertice(x=x, y=y, u=x, v=y)\n\n        # Load default vertex and fragment shaders\n        self.vertex   = (SHADERFLOW.RESOURCES.VERTEX/  \"Default.glsl\")\n        self.fragment = (SHADERFLOW.RESOURCES.FRAGMENT/\"Default.glsl\")\n\n    def add_vertice(self, x: float=0, y: float=0, u: float=0, v: float=0) -&gt; Self:\n        self.vertices.extend((x, y, u, v))\n        return self\n\n    def clear_vertices(self) -&gt; Self:\n        self.vertices = []\n\n    def vertex_variable(self, variable: ShaderVariable) -&gt; Self:\n        self.vertex_variables.add(ShaderVariable.smart(variable))\n\n    def fragment_variable(self, variable: ShaderVariable) -&gt; Self:\n        self.fragment_variables.add(ShaderVariable.smart(variable))\n\n    def common_variable(self, variable: ShaderVariable) -&gt; Self:\n        self.vertex_variable(variable)\n        self.fragment_variable(variable)\n\n    def passthrough(self, variable: ShaderVariable) -&gt; Self:\n        variable = ShaderVariable.smart(variable)\n        self.vertex_variable(variable.copy(direction=\"out\"))\n        self.fragment_variable(variable.copy(direction=\"in\"))\n\n    @property\n    def vao_definition(self) -&gt; Tuple[str]:\n        \"\"\"(\"2f 2f\", \"render_vertex\", \"coords_vertex\")\"\"\"\n        sizes, names = [], []\n        for variable in self.vertex_variables:\n            if variable.direction == ShaderVariableDirection.In.value:\n                sizes.append(variable.size_string)\n                names.append(variable.name)\n        return (\" \".join(sizes), *names)\n\n    def _build_shader(self, content: str, variables: Iterable[ShaderVariable]) -&gt; str:\n        \"\"\"Build the final shader from the contents provided\"\"\"\n        shader = []\n\n        @contextlib.contextmanager\n        def section(name: str=\"\"):\n            shader.append(\"\\n\\n// \" + \"-\"*96 + \"|\")\n            shader.append(f\"// ShaderFlow Section: ({name})\\n\")\n            yield\n\n        shader.append(f\"#version {self.version}\")\n\n        # Add variable definitions\n        with section(\"Variables\"):\n            for variable in variables:\n                shader.append(variable.declaration)\n\n        with section(\"Include - ShaderFlow\"):\n            shader.append(SHADERFLOW.RESOURCES.SHADERS_INCLUDE/\"ShaderFlow.glsl\")\n\n        # Add all modules includes to the shader\n        for module in self.scene.modules:\n            for defines in module.defines():\n                shader.append(defines)\n\n            for include in filter(None, module.includes()):\n                with section(f\"Include - {module.who}\"):\n                    shader.append(include)\n\n        # Add shader content itself\n        with section(\"Content\"):\n            shader.append(content)\n\n        return '\\n'.join(map(LoaderString, shader))\n\n    # # Vertex shader content\n\n    def _watchshader(self, path: Path) -&gt; None:\n\n        @define(eq=False)\n        class Handler(watchdog.events.FileSystemEventHandler):\n            shader: ShaderObject\n            def on_modified(self, event):\n                if self.shader.scene.rendering:\n                    return\n                self.shader.scene.scheduler.once(self.shader.compile)\n\n        # Add the Shader Path to the watchdog for changes. Only ignore 'File Too Long'\n        # exceptions when non-path strings as we can't get max len easily per system\n        try:\n            if (path := BrokenPath(path).valid()):\n                WATCHDOG.schedule(Handler(self), path)\n        except OSError as error:\n            if error.errno != errno.ENAMETOOLONG:\n                raise error\n\n    _vertex: Union[Path, str] = \"\"\n    \"\"\"The 'User Content' of the Vertex Shader, interted after the Metaprogramming.\n    A Path value will be watched for changes and shaders will be automatically reloaded\"\"\"\n\n    def make_vertex(self, content: str) -&gt; Self:\n        return self._build_shader(LoaderString(content), self.vertex_variables)\n\n    @property\n    def vertex(self) -&gt; str:\n        return self.make_vertex(self._vertex)\n\n    @vertex.setter\n    def vertex(self, value: Union[Path, str]):\n        self._watchshader(value)\n        self._vertex = value\n\n    # # Fragment shader content\n\n    _fragment: Union[Path, str] = \"\"\n    \"\"\"The 'User Content' of the Fragment Shader, interted after the Metaprogramming.\n    A Path value will be watched for changes and shaders will be automatically reloaded\"\"\"\n\n    def make_fragment(self, content: str) -&gt; Self:\n        return self._build_shader(LoaderString(content), self.fragment_variables)\n\n    @property\n    def fragment(self) -&gt; str:\n        return self.make_fragment(self._fragment)\n\n    @fragment.setter\n    def fragment(self, value: Union[Path, str]):\n        self._watchshader(value)\n        self._fragment = value\n\n    # # Uniforms\n\n    def set_uniform(self, name: str, value: Any=None) -&gt; None:\n        if (self.program is None):\n            raise RuntimeError(f\"Shader {self.who} hasn't been compiled yet\")\n        if (value is not None) and (uniform := self.program.get(name, None)):\n            uniform.value = denum(value)\n\n    def get_uniform(self, name: str) -&gt; Any | None:\n        return self.program.get(name, None)\n\n    # # Rendering\n\n    def _full_pipeline(self) -&gt; Iterable[ShaderVariable]:\n        for module in self.scene.modules:\n            yield from module.pipeline()\n\n    def compile(self, _vertex: str=None, _fragment: str=None) -&gt; Self:\n        log.info(f\"{self.who} Compiling shaders\")\n\n        # Add pipeline variable definitions\n        for variable in self._full_pipeline():\n            self.common_variable(variable)\n\n        # Metaprogram either injected or proper shaders\n        fragment = self.make_fragment(_fragment or self._fragment)\n        vertex = self.make_vertex(_vertex or self._vertex)\n\n        try:\n            self.program = self.scene.opengl.program(vertex, fragment)\n        except _moderngl.Error as error:\n            ShaderDumper(\n                shader=self,\n                error=str(error),\n                vertex=vertex,\n                fragment=fragment\n            ).dump()\n\n            if (_vertex or _fragment):\n                raise RuntimeError(log.error(\"Recursion on Missing Texture Shader Loading\"))\n\n            log.error(f\"{self.who} Error compiling shaders, loading missing texture shader\")\n            self.compile(\n                _vertex  =LoaderString(SHADERFLOW.RESOURCES.VERTEX/\"Default.glsl\"),\n                _fragment=LoaderString(SHADERFLOW.RESOURCES.FRAGMENT/\"Missing.glsl\")\n            )\n\n        # Render the vertices that are defined on the shader\n        self.vbo = self.scene.opengl.buffer(numpy.array(self.vertices, dtype=\"f4\"))\n        self.vao = self.scene.opengl.vertex_array(\n            self.program, [(self.vbo, *self.vao_definition)],\n            skip_errors=True\n        )\n\n        return self\n\n    # # Module\n\n    def update(self) -&gt; None:\n        if (self.program is None):\n            self.compile()\n        self.render()\n\n    SKIP_GPU: bool = (os.getenv(\"SKIP_GPU\", \"0\") == \"1\")\n    \"\"\"Do not render shaders, useful for benchmarking raw Python performance\"\"\"\n\n    def render_fbo(self, fbo: moderngl.Framebuffer, clear: bool=True) -&gt; None:\n        if self.SKIP_GPU:\n            return\n        fbo.use()\n        clear or fbo.clear()\n        self.vao.render(\n            moderngl.TRIANGLE_STRIP,\n            instances=self.instances\n        )\n\n    def use_pipeline(self, pipeline: Iterable[ShaderVariable]) -&gt; None:\n        for index, variable in enumerate(pipeline):\n            # if variable not in self.fragment_variables:\n            #     self.load_shaders()\n            if (variable.type == \"sampler2D\"):\n                self.set_uniform(variable.name, index)\n                variable.value.use(index)\n                continue\n            self.set_uniform(variable.name, variable.value)\n\n    def render(self) -&gt; None:\n\n        # Optimization: Final shader doesn't need the full pipeline\n        if self.texture.final:\n            self.use_pipeline(self.scene.shader.texture.pipeline())\n            self.set_uniform(\"iFlip\", self.scene.rendering)\n            self.render_fbo(self.texture.fbo(), clear=False)\n            return\n\n        self.use_pipeline(self._full_pipeline())\n\n        # Optimization: Only the iLayer uniform changes\n        for layer, box in enumerate(self.texture.row(0)):\n            self.set_uniform(\"iLayer\", layer)\n            self.render_fbo(fbo=box.fbo, clear=box.clear)\n\n        self.texture.roll()\n\n    def handle(self, message: ShaderMessage) -&gt; None:\n        if isinstance(message, ShaderMessage.Shader.Compile):\n            self.compile()\n\n        elif isinstance(message, ShaderMessage.Shader.Render):\n            self.render()\n\n            # Fixme: Should this be on a proper User Interface class?\n            if self.texture.final:\n                self.scene._render_ui()\n\n    def __ui__(self) -&gt; None:\n        if imgui.button(\"Reload\"):\n            self.compile()\n        imgui.same_line()\n        if imgui.button(\"Dump\"):\n            self.dump_shaders()\n        if imgui.tree_node(\"Pipeline\"):\n            for variable in self._full_pipeline():\n                imgui.text(f\"{variable.name.ljust(16)}: {variable.value}\")\n            imgui.tree_pop()\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.version","title":"<code>version: int = 330</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>OpenGL Version to use for the shader. Must be &lt;= than the Window Backend version</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.program","title":"<code>program: moderngl.Program = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ModernGL 'Compiled Shaders' object</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.vao","title":"<code>vao: moderngl.VertexArray = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Buffer object for the vertices of the shader</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.vbo","title":"<code>vbo: moderngl.Buffer = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Buffer object for the vertices of the shader</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.texture","title":"<code>texture: ShaderTexture = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ShaderTexture Module that this Shader renders to in layers and temporal</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.clear","title":"<code>clear: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Clear the Final Texture before rendering</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.instances","title":"<code>instances: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of gl_InstanceID's to render</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.vertices","title":"<code>vertices: List[float] = Factory(list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vertices of the shader. More often than not, a Fullscreen Quad</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.vertex_variables","title":"<code>vertex_variables: Set[ShaderVariable] = Factory(set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Variables metaprogramming that will be added to the Vertex Shader</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.fragment_variables","title":"<code>fragment_variables: Set[ShaderVariable] = Factory(set)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Variables metaprogramming that will be added to the Fragment Shader</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.__post__","title":"<code>__post__()</code>","text":"<p>Set default values for some variables</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def __post__(self):\n    \"\"\"Set default values for some variables\"\"\"\n    self.texture = ShaderTexture(scene=self.scene, name=self.name, track=True)\n    self.fragment_variable(\"out vec4 fragColor\")\n    self.vertex_variable(\"in vec2 vertex_position\")\n    self.vertex_variable(\"in vec2 vertex_gluv\")\n    self.passthrough(\"flat int instance\")\n    self.passthrough(\"vec2 gluv\")\n    self.passthrough(\"vec2 stuv\")\n    self.passthrough(\"vec2 astuv\")\n    self.passthrough(\"vec2 agluv\")\n    self.passthrough(\"vec2 fragCoord\")\n    self.passthrough(\"vec2 glxy\")\n    self.passthrough(\"vec2 stxy\")\n\n    # Add a fullscreen center-(0, 0) uv rectangle\n    for x, y in itertools.product((-1, 1), (-1, 1)):\n        self.add_vertice(x=x, y=y, u=x, v=y)\n\n    # Load default vertex and fragment shaders\n    self.vertex   = (SHADERFLOW.RESOURCES.VERTEX/  \"Default.glsl\")\n    self.fragment = (SHADERFLOW.RESOURCES.FRAGMENT/\"Default.glsl\")\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.add_vertice","title":"<code>add_vertice(x: float = 0, y: float = 0, u: float = 0, v: float = 0) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def add_vertice(self, x: float=0, y: float=0, u: float=0, v: float=0) -&gt; Self:\n    self.vertices.extend((x, y, u, v))\n    return self\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.clear_vertices","title":"<code>clear_vertices() -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def clear_vertices(self) -&gt; Self:\n    self.vertices = []\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.vertex_variable","title":"<code>vertex_variable(variable: ShaderVariable) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def vertex_variable(self, variable: ShaderVariable) -&gt; Self:\n    self.vertex_variables.add(ShaderVariable.smart(variable))\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.fragment_variable","title":"<code>fragment_variable(variable: ShaderVariable) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def fragment_variable(self, variable: ShaderVariable) -&gt; Self:\n    self.fragment_variables.add(ShaderVariable.smart(variable))\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.common_variable","title":"<code>common_variable(variable: ShaderVariable) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def common_variable(self, variable: ShaderVariable) -&gt; Self:\n    self.vertex_variable(variable)\n    self.fragment_variable(variable)\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.passthrough","title":"<code>passthrough(variable: ShaderVariable) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def passthrough(self, variable: ShaderVariable) -&gt; Self:\n    variable = ShaderVariable.smart(variable)\n    self.vertex_variable(variable.copy(direction=\"out\"))\n    self.fragment_variable(variable.copy(direction=\"in\"))\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.vao_definition","title":"<code>vao_definition: Tuple[str]</code>  <code>property</code>","text":"<p>(\"2f 2f\", \"render_vertex\", \"coords_vertex\")</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.make_vertex","title":"<code>make_vertex(content: str) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def make_vertex(self, content: str) -&gt; Self:\n    return self._build_shader(LoaderString(content), self.vertex_variables)\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.vertex","title":"<code>vertex: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.make_fragment","title":"<code>make_fragment(content: str) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def make_fragment(self, content: str) -&gt; Self:\n    return self._build_shader(LoaderString(content), self.fragment_variables)\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.fragment","title":"<code>fragment: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.set_uniform","title":"<code>set_uniform(name: str, value: Any = None) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def set_uniform(self, name: str, value: Any=None) -&gt; None:\n    if (self.program is None):\n        raise RuntimeError(f\"Shader {self.who} hasn't been compiled yet\")\n    if (value is not None) and (uniform := self.program.get(name, None)):\n        uniform.value = denum(value)\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.get_uniform","title":"<code>get_uniform(name: str) -&gt; Any | None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def get_uniform(self, name: str) -&gt; Any | None:\n    return self.program.get(name, None)\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.compile","title":"<code>compile(_vertex: str = None, _fragment: str = None) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def compile(self, _vertex: str=None, _fragment: str=None) -&gt; Self:\n    log.info(f\"{self.who} Compiling shaders\")\n\n    # Add pipeline variable definitions\n    for variable in self._full_pipeline():\n        self.common_variable(variable)\n\n    # Metaprogram either injected or proper shaders\n    fragment = self.make_fragment(_fragment or self._fragment)\n    vertex = self.make_vertex(_vertex or self._vertex)\n\n    try:\n        self.program = self.scene.opengl.program(vertex, fragment)\n    except _moderngl.Error as error:\n        ShaderDumper(\n            shader=self,\n            error=str(error),\n            vertex=vertex,\n            fragment=fragment\n        ).dump()\n\n        if (_vertex or _fragment):\n            raise RuntimeError(log.error(\"Recursion on Missing Texture Shader Loading\"))\n\n        log.error(f\"{self.who} Error compiling shaders, loading missing texture shader\")\n        self.compile(\n            _vertex  =LoaderString(SHADERFLOW.RESOURCES.VERTEX/\"Default.glsl\"),\n            _fragment=LoaderString(SHADERFLOW.RESOURCES.FRAGMENT/\"Missing.glsl\")\n        )\n\n    # Render the vertices that are defined on the shader\n    self.vbo = self.scene.opengl.buffer(numpy.array(self.vertices, dtype=\"f4\"))\n    self.vao = self.scene.opengl.vertex_array(\n        self.program, [(self.vbo, *self.vao_definition)],\n        skip_errors=True\n    )\n\n    return self\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.update","title":"<code>update() -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def update(self) -&gt; None:\n    if (self.program is None):\n        self.compile()\n    self.render()\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.SKIP_GPU","title":"<code>SKIP_GPU: bool = os.getenv('SKIP_GPU', '0') == '1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Do not render shaders, useful for benchmarking raw Python performance</p>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.render_fbo","title":"<code>render_fbo(fbo: moderngl.Framebuffer, clear: bool = True) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def render_fbo(self, fbo: moderngl.Framebuffer, clear: bool=True) -&gt; None:\n    if self.SKIP_GPU:\n        return\n    fbo.use()\n    clear or fbo.clear()\n    self.vao.render(\n        moderngl.TRIANGLE_STRIP,\n        instances=self.instances\n    )\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.use_pipeline","title":"<code>use_pipeline(pipeline: Iterable[ShaderVariable]) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def use_pipeline(self, pipeline: Iterable[ShaderVariable]) -&gt; None:\n    for index, variable in enumerate(pipeline):\n        # if variable not in self.fragment_variables:\n        #     self.load_shaders()\n        if (variable.type == \"sampler2D\"):\n            self.set_uniform(variable.name, index)\n            variable.value.use(index)\n            continue\n        self.set_uniform(variable.name, variable.value)\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.render","title":"<code>render() -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def render(self) -&gt; None:\n\n    # Optimization: Final shader doesn't need the full pipeline\n    if self.texture.final:\n        self.use_pipeline(self.scene.shader.texture.pipeline())\n        self.set_uniform(\"iFlip\", self.scene.rendering)\n        self.render_fbo(self.texture.fbo(), clear=False)\n        return\n\n    self.use_pipeline(self._full_pipeline())\n\n    # Optimization: Only the iLayer uniform changes\n    for layer, box in enumerate(self.texture.row(0)):\n        self.set_uniform(\"iLayer\", layer)\n        self.render_fbo(fbo=box.fbo, clear=box.clear)\n\n    self.texture.roll()\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.handle","title":"<code>handle(message: ShaderMessage) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def handle(self, message: ShaderMessage) -&gt; None:\n    if isinstance(message, ShaderMessage.Shader.Compile):\n        self.compile()\n\n    elif isinstance(message, ShaderMessage.Shader.Render):\n        self.render()\n\n        # Fixme: Should this be on a proper User Interface class?\n        if self.texture.final:\n            self.scene._render_ui()\n</code></pre>"},{"location":"shaderflow/reference/shader/#Shader.ShaderObject.__ui__","title":"<code>__ui__() -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Shader.py</code> Python<pre><code>def __ui__(self) -&gt; None:\n    if imgui.button(\"Reload\"):\n        self.compile()\n    imgui.same_line()\n    if imgui.button(\"Dump\"):\n        self.dump_shaders()\n    if imgui.tree_node(\"Pipeline\"):\n        for variable in self._full_pipeline():\n            imgui.text(f\"{variable.name.ljust(16)}: {variable.value}\")\n        imgui.tree_pop()\n</code></pre>"},{"location":"shaderflow/reference/texture/","title":"Texture","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/texture/#Texture","title":"<code>Texture</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType","title":"<code>Texture.TextureType</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>class TextureType(BrokenEnum):\n\n    # Float\n    f1 = numpy.uint8\n    \"\"\"Alias for uint8, GL_UNSIGNED_BYTE\"\"\"\n    f2 = numpy.float16\n    \"\"\"Float16 bits = 2 bytes, GL_HALF_FLOAT\"\"\"\n    f4 = numpy.float32\n    \"\"\"Float32 bits = 4 bytes, GL_FLOAT\"\"\"\n\n    # # Integers\n\n    # Normal\n    u1 = numpy.uint8\n    u2 = numpy.uint16\n    u4 = numpy.uint32\n    i1 = numpy.int8\n    i2 = numpy.int16\n    i4 = numpy.int32\n\n    # Normalized\n    nu1 = numpy.uint8\n    nu2 = numpy.uint16\n    nu4 = numpy.uint32\n    ni1 = numpy.int8\n    ni2 = numpy.int16\n    ni4 = numpy.int32\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.TextureType.f1","title":"<code>f1 = numpy.uint8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Alias for uint8, GL_UNSIGNED_BYTE</p>"},{"location":"shaderflow/reference/texture/#Texture.TextureType.f2","title":"<code>f2 = numpy.float16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Float16 bits = 2 bytes, GL_HALF_FLOAT</p>"},{"location":"shaderflow/reference/texture/#Texture.TextureType.f4","title":"<code>f4 = numpy.float32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Float32 bits = 4 bytes, GL_FLOAT</p>"},{"location":"shaderflow/reference/texture/#Texture.TextureType.u1","title":"<code>u1 = numpy.uint8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.u2","title":"<code>u2 = numpy.uint16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.u4","title":"<code>u4 = numpy.uint32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.i1","title":"<code>i1 = numpy.int8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.i2","title":"<code>i2 = numpy.int16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.i4","title":"<code>i4 = numpy.int32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.nu1","title":"<code>nu1 = numpy.uint8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.nu2","title":"<code>nu2 = numpy.uint16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.nu4","title":"<code>nu4 = numpy.uint32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.ni1","title":"<code>ni1 = numpy.int8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.ni2","title":"<code>ni2 = numpy.int16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureType.ni4","title":"<code>ni4 = numpy.int32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureFilter","title":"<code>Texture.TextureFilter</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>class TextureFilter(BrokenEnum):\n    # Fixme: Disallow bad combinations of filter and types\n    Nearest = \"nearest\"\n    Linear  = \"linear\"\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.TextureFilter.Nearest","title":"<code>Nearest = 'nearest'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureFilter.Linear","title":"<code>Linear = 'linear'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.Anisotropy","title":"<code>Texture.Anisotropy</code>","text":"<p>Anisotropy levels to use on textures</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>class Anisotropy(BrokenEnum):\n    \"\"\"Anisotropy levels to use on textures\"\"\"\n    x1  = 1\n    x2  = 2\n    x4  = 4\n    x8  = 8\n    x16 = 16\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.Anisotropy.x1","title":"<code>x1 = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.Anisotropy.x2","title":"<code>x2 = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.Anisotropy.x4","title":"<code>x4 = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.Anisotropy.x8","title":"<code>x8 = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.Anisotropy.x16","title":"<code>x16 = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureBox","title":"<code>Texture.TextureBox</code>","text":"<p>Holds a Framebuffer and bound Texture on the TextureMatrix</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>@define\nclass TextureBox:\n    \"\"\"Holds a Framebuffer and bound Texture on the TextureMatrix\"\"\"\n    texture: moderngl.Texture = None\n    fbo:     moderngl.Framebuffer = None\n    clear:   bool  = False\n    data:    bytes = None\n    empty:   bool  = True\n\n    def release(self) -&gt; Self:\n        (self.texture or Ignore()).release()\n        (self.fbo     or Ignore()).release()\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.TextureBox.texture","title":"<code>texture: moderngl.Texture = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureBox.fbo","title":"<code>fbo: moderngl.Framebuffer = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureBox.clear","title":"<code>clear: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureBox.data","title":"<code>data: bytes = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureBox.empty","title":"<code>empty: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.TextureBox.release","title":"<code>release() -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def release(self) -&gt; Self:\n    (self.texture or Ignore()).release()\n    (self.fbo     or Ignore()).release()\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture","title":"<code>Texture.ShaderTexture</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>@define\nclass ShaderTexture(ShaderModule):\n    name: str = None\n\n    def __post__(self):\n        self.make()\n        self.apply()\n\n    # ------------------------------------------|\n    # Special\n\n    final: bool = field(default=False, converter=bool)\n    \"\"\"Is this bound to the final FSSAA ShaderObject?\"\"\"\n\n    _track: bool = field(default=False, converter=bool)\n    \"\"\"Should this ShaderTexture match the resolution of the Scene?\"\"\"\n\n    @property\n    def track(self) -&gt; bool:\n        return self._track\n\n    @track.setter\n    def track(self, value: bool):\n        if (self._track == value):\n            return\n        self._track = value\n        self.make()\n\n    # ------------------------------------------|\n\n    # Filter\n\n    _filter: TextureFilter = TextureFilter.Linear\n\n    @property\n    def filter(self) -&gt; TextureFilter:\n        return TextureFilter.get(self._filter)\n\n    @filter.setter\n    def filter(self, value: TextureFilter):\n        self._filter = TextureFilter.get(value)\n        self.apply()\n\n    # Anisotropy\n\n    _anisotropy: Anisotropy = Anisotropy.x16\n\n    @property\n    def anisotropy(self) -&gt; Anisotropy:\n        return Anisotropy.get(self._anisotropy)\n\n    @anisotropy.setter\n    def anisotropy(self, value: Anisotropy):\n        self._anisotropy = Anisotropy.get(value)\n        self.apply()\n\n    # Mipmaps\n\n    _mipmaps: bool = field(default=False, converter=bool)\n\n    @property\n    def mipmaps(self) -&gt; bool:\n        return self._mipmaps\n\n    @mipmaps.setter\n    def mipmaps(self, value: bool):\n        if (self._mipmaps == value):\n            return\n        self._mipmaps = value\n        self.apply()\n\n    # ModernGL Filter\n\n    @property\n    def moderngl_filter(self) -&gt; int:\n        return dict(\n            linear=moderngl.LINEAR,\n            nearest=moderngl.NEAREST,\n            linear_mipmap=moderngl.LINEAR_MIPMAP_LINEAR,\n            nearest_mipmap=moderngl.NEAREST_MIPMAP_NEAREST,\n        ).get(self.filter.value + (\"_mipmap\"*self.mipmaps))\n\n    # Dtype\n\n    _dtype: TextureType = TextureType.f4\n\n    @property\n    def dtype(self) -&gt; TextureType:\n        return TextureType.get(self._dtype)\n\n    @dtype.setter\n    def dtype(self, value: TextureType):\n        self._dtype = TextureType.get(value)\n        self.make()\n\n    # Repeat X\n\n    _repeat_x: bool = field(default=True, converter=bool)\n\n    @property\n    def repeat_x(self) -&gt; bool:\n        return self._repeat_x\n\n    @repeat_x.setter\n    def repeat_x(self, value: bool):\n        if (self._repeat_x == value):\n            return\n        self._repeat_x = value\n        self.apply()\n\n    # Repeat Y\n\n    _repeat_y: bool = field(default=True, converter=bool)\n\n    @property\n    def repeat_y(self) -&gt; bool:\n        return self._repeat_y\n\n    @repeat_y.setter\n    def repeat_y(self, value: bool):\n        if (self._repeat_y == value):\n            return\n        self._repeat_y = value\n        self.apply()\n\n    # Repeat XY\n\n    def repeat(self, value: bool) -&gt; Self:\n        self.repeat_x = self.repeat_y = bool(value)\n        return self.apply()\n\n    # ------------------------------------------|\n\n    # Width\n\n    _width: int = field(default=1, converter=int)\n\n    @property\n    def width(self) -&gt; int:\n        if not self.track:\n            return self._width\n        return self.resolution[0]\n\n    @width.setter\n    def width(self, value: int):\n        value = int(value)\n        if (self._width == value):\n            return\n        self._width = value\n        self.make()\n\n    # Height\n\n    _height: int = field(default=1, converter=int)\n\n    @property\n    def height(self) -&gt; int:\n        if not self.track:\n            return self._height\n        return self.resolution[1]\n\n    @height.setter\n    def height(self, value: int):\n        value = int(value)\n        if (self._height == value):\n            return\n        self._height = value\n        self.make()\n\n    # Size (Width, Height)\n\n    @property\n    def resolution(self) -&gt; Tuple[int, int]:\n        if not self.track:\n            return (self.width, self.height)\n        if self.final:\n            return self.scene.resolution\n        return self.scene.render_resolution\n\n    @resolution.setter\n    def resolution(self, value: Tuple[int, int]):\n        if not self.track:\n            self.width, self.height = value\n\n    @property\n    def size(self) -&gt; Tuple[int, int]:\n        return self.resolution\n\n    @size.setter\n    def size(self, value: Tuple[int, int]):\n        self.resolution = value\n\n    @property\n    def aspect_ratio(self) -&gt; float:\n        return self.width/(self.height or 1)\n\n    # Components\n\n    _components: int = field(default=4, converter=int)\n\n    @property\n    def components(self) -&gt; int:\n        \"\"\"Number of color channels per pixel (1 Grayscale, 2 RG, 3 RGB, 4 RGBA)\"\"\"\n        return self._components\n\n    @components.setter\n    def components(self, value: int):\n        if (self._components == value):\n            return\n        self._components = value\n        self.make()\n\n    # Bytes size and Zero filling\n\n    @property\n    def zeros(self) -&gt; numpy.ndarray:\n        return numpy.zeros((*self.size, self.components), dtype=self.dtype.value)\n\n    @property\n    def size_t(self) -&gt; int:\n        \"\"\"Size of the texture data in bytes (width * height * components)\"\"\"\n        return self.width * self.height * self.components\n\n    # ------------------------------------------|\n\n    # Matrix\n\n    _matrix: Deque[Deque[TextureBox]] = Factory(deque)\n    \"\"\"Matrix of previous frames (temporal) and their layers (layers)\"\"\"\n\n    @property\n    def matrix(self) -&gt; Deque[Deque[TextureBox]]:\n        return self._matrix\n\n    # Temporal\n\n    _temporal: int = field(default=1, converter=int)\n    \"\"\"Number of previous frames to be stored\"\"\"\n\n    @property\n    def temporal(self) -&gt; int:\n        return self._temporal\n\n    @temporal.setter\n    def temporal(self, value: int):\n        if (self._temporal == value):\n            return\n        self._temporal = value\n        self.make()\n\n    # Layers\n\n    _layers: int = field(default=1, converter=int)\n    \"\"\"Number of layers to be stored, useful in single-shader multipass\"\"\"\n\n    @property\n    def layers(self) -&gt; int:\n        return self._layers\n\n    @layers.setter\n    def layers(self, value: int):\n        if (self._layers == value):\n            return\n        self._layers = value\n        self.make()\n\n    # ------------------------------------------|\n\n    def _pop_fill(self, list: Union[List, Deque], fill: Type[Any], length: int) -&gt; List:\n        \"\"\"Pop right or fill until a list's length is met\"\"\"\n        while len(list) &gt; length:\n            list.pop()\n        while len(list) &lt; length:\n            list.append(fill())\n        return list\n\n    def _populate(self) -&gt; Iterable[Tuple[int, int, TextureBox]]:\n        self._pop_fill(self.matrix, deque, self.temporal)\n        for row in self.matrix:\n            self._pop_fill(row, TextureBox, self.layers)\n        return self.boxes\n\n    @property\n    def boxes(self) -&gt; Iterable[Tuple[int, int, TextureBox]]:\n        for t, temporal in enumerate(self.matrix):\n            for b, box in enumerate(temporal):\n                yield (t, b, box)\n\n    def row(self, n: int=0) -&gt; Iterable[TextureBox]:\n        yield from self.matrix[n]\n\n    def make(self) -&gt; Self:\n        if (max(self.size) &gt; (limit := self.scene.opengl.info['GL_MAX_VIEWPORT_DIMS'][0])):\n            raise Exception(f\"Texture size too large for this OpenGL context: {self.size} &gt; {limit}\")\n\n        # Recreate texture boxes to match new length\n        for (_, _, box) in self.boxes:\n            box.release()\n        for (_, _, box) in self._populate():\n            box.texture = self.scene.opengl.texture(\n                components=self.components,\n                dtype=self.dtype.name,\n                size=self.size,\n            )\n            box.fbo = self.scene.opengl.framebuffer(\n                color_attachments=[box.texture]\n            )\n        return self.apply()\n\n    def apply(self) -&gt; Self:\n        for (_, _, box) in self.boxes:\n            if self.mipmaps:\n                box.texture.build_mipmaps()\n            box.texture.filter     = (self.moderngl_filter, self.moderngl_filter)\n            box.texture.anisotropy = self.anisotropy.value\n            box.texture.repeat_x   = self.repeat_x\n            box.texture.repeat_y   = self.repeat_y\n        return self\n\n    def box(self, temporal: int=0, layer: int=-1) -&gt; Optional[TextureBox]:\n        \"\"\"Note: Points to the current final box\"\"\"\n        if (self.temporal &lt;= temporal):\n            return None\n        if (self.layers &lt;= layer):\n            return None\n        return self.matrix[temporal][layer]\n\n    def fbo(self) -&gt; moderngl.Framebuffer:\n        \"\"\"Final and most Recent FBO of this Texture\"\"\"\n        if self.final and self.scene.realtime:\n            return self.scene.window.fbo\n        return self.box().fbo\n\n    def texture(self) -&gt; moderngl.Texture:\n        \"\"\"Final and most Recent Texture of this Texture\"\"\"\n        return self.box().texture\n\n    def roll(self, n: int=1) -&gt; Self:\n        \"\"\"Rotate the temporal layers by $n times\"\"\"\n        self.matrix.rotate(n)\n        return self\n\n    # ------------------------------------------|\n    # Input and Output\n\n    def from_image(self, image: LoadableImage) -&gt; Self:\n        image = LoaderImage(image)\n        image = image.transpose(PIL.Image.FLIP_TOP_BOTTOM)\n        self.width, self.height = image.size\n        self.components = len(image.getbands())\n        self.dtype = TextureType.get(numpy.array(image).dtype.str[1:].replace(\"u\", \"f\"))\n        self.make()\n        self.write(image.tobytes())\n        return self\n\n    def from_numpy(self, data: numpy.ndarray) -&gt; Self:\n        size = data.shape\n        if len(size) == 3:\n            components = size[2]\n            size = size[:2][::-1]\n        else:\n            components = 1\n        self.dtype = TextureType.get(data.dtype)\n        self.width, self.height = size\n        self.components = components\n        self.make()\n        self.write(numpy.flip(data, axis=0).tobytes())\n        return self\n\n    def write(self,\n        data: bytes=None,\n        *,\n        temporal: int=0,\n        layer: int=-1,\n        viewport: Tuple[int, int, int, int]=None,\n    ) -&gt; Self:\n        box = self.box(temporal, layer)\n        box.texture.write(data, viewport=viewport)\n        if not viewport:\n            box.data = bytes(data)\n        box.empty = False\n        return self\n\n    def clear(self, temporal: int=0, layer: int=-1) -&gt; Self:\n        return self.write(self.zeros, temporal=temporal, layer=layer)\n\n    def is_empty(self, temporal: int=0, layer: int=-1) -&gt; bool:\n        return self.box(temporal, layer).empty\n\n    # ------------------------------------------|\n\n    @property\n    def bytes_per_pixel(self) -&gt; int:\n        return self.dtype.value().nbytes * self.components\n\n    def sample_xy(self, x: float, y: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n        \"\"\"Get the Pixel at a XY coordinate: Origin at Top Right (0, 0); Bottom Left (width, height)\"\"\"\n        box   = self.box(temporal=temporal, layer=layer)\n        data  = (box.data or box.texture.read())\n        start = int((y*self.width + x) * self.bytes_per_pixel)\n        return numpy.frombuffer(data, dtype=self.dtype.value)[start:start + self.bytes_per_pixel]\n\n    def sample_stxy(self, x: float, y: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n        \"\"\"Get the Pixel at a XY coordinate: Origin at Bottom left (0, 0); Top right (width, height)\"\"\"\n        return self.sample_xy(x=x, y=(self.height - y - 1), temporal=temporal, layer=layer)\n\n    def sample_glxy(self, x: float, y: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n        \"\"\"Get the Pixel at a XY coordinate: Origin at Center (0, 0); Any Edge either (\u00b1w/2, 0), (0, \u00b1h/2)\"\"\"\n        return self.sample_xy(x=int(x + (self.width/2)), y=int(y + (self.height/2)), temporal=temporal, layer=layer)\n\n    def sample_uv(self, u: float, v: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n        \"\"\"Get the Pixel at a UV coordinate: Origin at Top Right (0, 0); Bottom Left (1, 1)\"\"\"\n        return self.sample_xy(u*self.width, v*self.height, temporal=temporal, layer=layer)\n\n    def sample_stuv(self, u: float, v: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n        \"\"\"Get the Pixel at a UV coordinate: Origin at Bottom Left (0, 0); Top Right (1, 1)\"\"\"\n        return self.sample_uv(u=u, v=(1-v), temporal=temporal, layer=layer)\n\n    def sample_gluv(self, u: float, v: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n        \"\"\"Get the Pixel at a UV coordinate: Origin at Center (0, 0); Any Edge either (\u00b11, 0), (0, \u00b11)\"\"\"\n        return self.sample_uv(u=(u/2 + 0.5), v=(v/2 + 0.5), temporal=temporal, layer=layer)\n\n    # ------------------------------------------|\n    # Module\n\n    def _coord2name(self, old: int, layer: int) -&gt; str:\n        return f\"{self.name}{old}x{layer}\"\n\n    def defines(self) -&gt; Iterable[str]:\n        if not self.name:\n            return\n\n        # Define last frames as plain name (iTex0x(-1) -&gt; iTex, iTex1x(-1) -&gt; iTex1)\n        for temporal in range(self.temporal):\n            yield f\"#define {self.name}{temporal or ''} {self.name}{temporal}x{self.layers-1}\"\n\n        # Function to sample a dynamic temporal, layer\n        yield f\"\\nvec4 {self.name}Texture(int temporal, int layer, vec2 astuv) {{\"\n        yield \"    if (false) return vec4(0);\"\n        for temporal in range(self.temporal):\n            for layer in range(self.layers):\n                yield f\"    else if (temporal == {temporal} &amp;&amp; layer == {layer}) return texture({self._coord2name(temporal, layer)}, astuv);\"\n        yield \"    else {return vec4(0);}\"\n        yield \"}\"\n\n    def handle(self, message: ShaderMessage):\n        if self.track:\n            if isinstance(message, ShaderMessage.Shader.RecreateTextures):\n                self.make()\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        if not self.name:\n            return\n        yield ShaderVariable(\"uniform\", \"int\", \"iLayer\", None)\n        yield ShaderVariable(\"uniform\", \"vec2\",  f\"{self.name}Size\",        self.size)\n        yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}AspectRatio\", self.aspect_ratio)\n        yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Layers\",      self.layers)\n        yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Temporal\",    self.temporal)\n        for (t, b, box) in self.boxes:\n            yield ShaderVariable(\"uniform\", \"sampler2D\", self._coord2name(t, b), box.texture)\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.name","title":"<code>name: str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def __post__(self):\n    self.make()\n    self.apply()\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.final","title":"<code>final: bool = field(default=False, converter=bool)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Is this bound to the final FSSAA ShaderObject?</p>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.track","title":"<code>track: bool</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.filter","title":"<code>filter: TextureFilter</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.anisotropy","title":"<code>anisotropy: Anisotropy</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.mipmaps","title":"<code>mipmaps: bool</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.moderngl_filter","title":"<code>moderngl_filter: int</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.dtype","title":"<code>dtype: TextureType</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.repeat_x","title":"<code>repeat_x: bool</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.repeat_y","title":"<code>repeat_y: bool</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.repeat","title":"<code>repeat(value: bool) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def repeat(self, value: bool) -&gt; Self:\n    self.repeat_x = self.repeat_y = bool(value)\n    return self.apply()\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.width","title":"<code>width: int</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.height","title":"<code>height: int</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.resolution","title":"<code>resolution: Tuple[int, int]</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.size","title":"<code>size: Tuple[int, int]</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.aspect_ratio","title":"<code>aspect_ratio: float</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.components","title":"<code>components: int</code>  <code>property</code> <code>writable</code>","text":"<p>Number of color channels per pixel (1 Grayscale, 2 RG, 3 RGB, 4 RGBA)</p>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.zeros","title":"<code>zeros: numpy.ndarray</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.size_t","title":"<code>size_t: int</code>  <code>property</code>","text":"<p>Size of the texture data in bytes (width * height * components)</p>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.matrix","title":"<code>matrix: Deque[Deque[TextureBox]]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.temporal","title":"<code>temporal: int</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.layers","title":"<code>layers: int</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.boxes","title":"<code>boxes: Iterable[Tuple[int, int, TextureBox]]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.row","title":"<code>row(n: int = 0) -&gt; Iterable[TextureBox]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def row(self, n: int=0) -&gt; Iterable[TextureBox]:\n    yield from self.matrix[n]\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.make","title":"<code>make() -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def make(self) -&gt; Self:\n    if (max(self.size) &gt; (limit := self.scene.opengl.info['GL_MAX_VIEWPORT_DIMS'][0])):\n        raise Exception(f\"Texture size too large for this OpenGL context: {self.size} &gt; {limit}\")\n\n    # Recreate texture boxes to match new length\n    for (_, _, box) in self.boxes:\n        box.release()\n    for (_, _, box) in self._populate():\n        box.texture = self.scene.opengl.texture(\n            components=self.components,\n            dtype=self.dtype.name,\n            size=self.size,\n        )\n        box.fbo = self.scene.opengl.framebuffer(\n            color_attachments=[box.texture]\n        )\n    return self.apply()\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.apply","title":"<code>apply() -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def apply(self) -&gt; Self:\n    for (_, _, box) in self.boxes:\n        if self.mipmaps:\n            box.texture.build_mipmaps()\n        box.texture.filter     = (self.moderngl_filter, self.moderngl_filter)\n        box.texture.anisotropy = self.anisotropy.value\n        box.texture.repeat_x   = self.repeat_x\n        box.texture.repeat_y   = self.repeat_y\n    return self\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.box","title":"<code>box(temporal: int = 0, layer: int = -1) -&gt; Optional[TextureBox]</code>","text":"<p>Note: Points to the current final box</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def box(self, temporal: int=0, layer: int=-1) -&gt; Optional[TextureBox]:\n    \"\"\"Note: Points to the current final box\"\"\"\n    if (self.temporal &lt;= temporal):\n        return None\n    if (self.layers &lt;= layer):\n        return None\n    return self.matrix[temporal][layer]\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.fbo","title":"<code>fbo() -&gt; moderngl.Framebuffer</code>","text":"<p>Final and most Recent FBO of this Texture</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def fbo(self) -&gt; moderngl.Framebuffer:\n    \"\"\"Final and most Recent FBO of this Texture\"\"\"\n    if self.final and self.scene.realtime:\n        return self.scene.window.fbo\n    return self.box().fbo\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.texture","title":"<code>texture() -&gt; moderngl.Texture</code>","text":"<p>Final and most Recent Texture of this Texture</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def texture(self) -&gt; moderngl.Texture:\n    \"\"\"Final and most Recent Texture of this Texture\"\"\"\n    return self.box().texture\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.roll","title":"<code>roll(n: int = 1) -&gt; Self</code>","text":"<p>Rotate the temporal layers by $n times</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def roll(self, n: int=1) -&gt; Self:\n    \"\"\"Rotate the temporal layers by $n times\"\"\"\n    self.matrix.rotate(n)\n    return self\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.from_image","title":"<code>from_image(image: LoadableImage) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def from_image(self, image: LoadableImage) -&gt; Self:\n    image = LoaderImage(image)\n    image = image.transpose(PIL.Image.FLIP_TOP_BOTTOM)\n    self.width, self.height = image.size\n    self.components = len(image.getbands())\n    self.dtype = TextureType.get(numpy.array(image).dtype.str[1:].replace(\"u\", \"f\"))\n    self.make()\n    self.write(image.tobytes())\n    return self\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.from_numpy","title":"<code>from_numpy(data: numpy.ndarray) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def from_numpy(self, data: numpy.ndarray) -&gt; Self:\n    size = data.shape\n    if len(size) == 3:\n        components = size[2]\n        size = size[:2][::-1]\n    else:\n        components = 1\n    self.dtype = TextureType.get(data.dtype)\n    self.width, self.height = size\n    self.components = components\n    self.make()\n    self.write(numpy.flip(data, axis=0).tobytes())\n    return self\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.write","title":"<code>write(data: bytes = None, *, temporal: int = 0, layer: int = -1, viewport: Tuple[int, int, int, int] = None) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def write(self,\n    data: bytes=None,\n    *,\n    temporal: int=0,\n    layer: int=-1,\n    viewport: Tuple[int, int, int, int]=None,\n) -&gt; Self:\n    box = self.box(temporal, layer)\n    box.texture.write(data, viewport=viewport)\n    if not viewport:\n        box.data = bytes(data)\n    box.empty = False\n    return self\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.clear","title":"<code>clear(temporal: int = 0, layer: int = -1) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def clear(self, temporal: int=0, layer: int=-1) -&gt; Self:\n    return self.write(self.zeros, temporal=temporal, layer=layer)\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.is_empty","title":"<code>is_empty(temporal: int = 0, layer: int = -1) -&gt; bool</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def is_empty(self, temporal: int=0, layer: int=-1) -&gt; bool:\n    return self.box(temporal, layer).empty\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.bytes_per_pixel","title":"<code>bytes_per_pixel: int</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.sample_xy","title":"<code>sample_xy(x: float, y: float, temporal: int = 0, layer: int = -1) -&gt; numpy.ndarray</code>","text":"<p>Get the Pixel at a XY coordinate: Origin at Top Right (0, 0); Bottom Left (width, height)</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def sample_xy(self, x: float, y: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n    \"\"\"Get the Pixel at a XY coordinate: Origin at Top Right (0, 0); Bottom Left (width, height)\"\"\"\n    box   = self.box(temporal=temporal, layer=layer)\n    data  = (box.data or box.texture.read())\n    start = int((y*self.width + x) * self.bytes_per_pixel)\n    return numpy.frombuffer(data, dtype=self.dtype.value)[start:start + self.bytes_per_pixel]\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.sample_stxy","title":"<code>sample_stxy(x: float, y: float, temporal: int = 0, layer: int = -1) -&gt; numpy.ndarray</code>","text":"<p>Get the Pixel at a XY coordinate: Origin at Bottom left (0, 0); Top right (width, height)</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def sample_stxy(self, x: float, y: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n    \"\"\"Get the Pixel at a XY coordinate: Origin at Bottom left (0, 0); Top right (width, height)\"\"\"\n    return self.sample_xy(x=x, y=(self.height - y - 1), temporal=temporal, layer=layer)\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.sample_glxy","title":"<code>sample_glxy(x: float, y: float, temporal: int = 0, layer: int = -1) -&gt; numpy.ndarray</code>","text":"<p>Get the Pixel at a XY coordinate: Origin at Center (0, 0); Any Edge either (\u00b1w/2, 0), (0, \u00b1h/2)</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def sample_glxy(self, x: float, y: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n    \"\"\"Get the Pixel at a XY coordinate: Origin at Center (0, 0); Any Edge either (\u00b1w/2, 0), (0, \u00b1h/2)\"\"\"\n    return self.sample_xy(x=int(x + (self.width/2)), y=int(y + (self.height/2)), temporal=temporal, layer=layer)\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.sample_uv","title":"<code>sample_uv(u: float, v: float, temporal: int = 0, layer: int = -1) -&gt; numpy.ndarray</code>","text":"<p>Get the Pixel at a UV coordinate: Origin at Top Right (0, 0); Bottom Left (1, 1)</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def sample_uv(self, u: float, v: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n    \"\"\"Get the Pixel at a UV coordinate: Origin at Top Right (0, 0); Bottom Left (1, 1)\"\"\"\n    return self.sample_xy(u*self.width, v*self.height, temporal=temporal, layer=layer)\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.sample_stuv","title":"<code>sample_stuv(u: float, v: float, temporal: int = 0, layer: int = -1) -&gt; numpy.ndarray</code>","text":"<p>Get the Pixel at a UV coordinate: Origin at Bottom Left (0, 0); Top Right (1, 1)</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def sample_stuv(self, u: float, v: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n    \"\"\"Get the Pixel at a UV coordinate: Origin at Bottom Left (0, 0); Top Right (1, 1)\"\"\"\n    return self.sample_uv(u=u, v=(1-v), temporal=temporal, layer=layer)\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.sample_gluv","title":"<code>sample_gluv(u: float, v: float, temporal: int = 0, layer: int = -1) -&gt; numpy.ndarray</code>","text":"<p>Get the Pixel at a UV coordinate: Origin at Center (0, 0); Any Edge either (\u00b11, 0), (0, \u00b11)</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def sample_gluv(self, u: float, v: float, temporal: int=0, layer: int=-1) -&gt; numpy.ndarray:\n    \"\"\"Get the Pixel at a UV coordinate: Origin at Center (0, 0); Any Edge either (\u00b11, 0), (0, \u00b11)\"\"\"\n    return self.sample_uv(u=(u/2 + 0.5), v=(v/2 + 0.5), temporal=temporal, layer=layer)\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.defines","title":"<code>defines() -&gt; Iterable[str]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def defines(self) -&gt; Iterable[str]:\n    if not self.name:\n        return\n\n    # Define last frames as plain name (iTex0x(-1) -&gt; iTex, iTex1x(-1) -&gt; iTex1)\n    for temporal in range(self.temporal):\n        yield f\"#define {self.name}{temporal or ''} {self.name}{temporal}x{self.layers-1}\"\n\n    # Function to sample a dynamic temporal, layer\n    yield f\"\\nvec4 {self.name}Texture(int temporal, int layer, vec2 astuv) {{\"\n    yield \"    if (false) return vec4(0);\"\n    for temporal in range(self.temporal):\n        for layer in range(self.layers):\n            yield f\"    else if (temporal == {temporal} &amp;&amp; layer == {layer}) return texture({self._coord2name(temporal, layer)}, astuv);\"\n    yield \"    else {return vec4(0);}\"\n    yield \"}\"\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.handle","title":"<code>handle(message: ShaderMessage)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def handle(self, message: ShaderMessage):\n    if self.track:\n        if isinstance(message, ShaderMessage.Shader.RecreateTextures):\n            self.make()\n</code></pre>"},{"location":"shaderflow/reference/texture/#Texture.ShaderTexture.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Texture.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    if not self.name:\n        return\n    yield ShaderVariable(\"uniform\", \"int\", \"iLayer\", None)\n    yield ShaderVariable(\"uniform\", \"vec2\",  f\"{self.name}Size\",        self.size)\n    yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}AspectRatio\", self.aspect_ratio)\n    yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Layers\",      self.layers)\n    yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Temporal\",    self.temporal)\n    for (t, b, box) in self.boxes:\n        yield ShaderVariable(\"uniform\", \"sampler2D\", self._coord2name(t, b), box.texture)\n</code></pre>"},{"location":"shaderflow/reference/variable/","title":"Variable","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/variable/#Variable","title":"<code>Variable</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableQualifier","title":"<code>Variable.ShaderVariableQualifier</code>","text":"<p>Guidance enum for GLSL variable qualifiers options</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Variable.py</code> Python<pre><code>class ShaderVariableQualifier(BrokenEnum):\n    \"\"\"Guidance enum for GLSL variable qualifiers options\"\"\"\n    Uniform   = \"uniform\"\n    Attribute = \"attribute\"\n    Varying   = \"varying\"\n</code></pre>"},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableQualifier.Uniform","title":"<code>Uniform = 'uniform'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableQualifier.Attribute","title":"<code>Attribute = 'attribute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableQualifier.Varying","title":"<code>Varying = 'varying'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType","title":"<code>Variable.ShaderVariableType</code>","text":"<p>Guidance enum for GLSL variable types</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Variable.py</code> Python<pre><code>class ShaderVariableType(BrokenEnum):\n    \"\"\"Guidance enum for GLSL variable types\"\"\"\n    Float     = \"float\"\n    Int       = \"int\"\n    Bool      = \"bool\"\n    Vec2      = \"vec2\"\n    Vec3      = \"vec3\"\n    Vec4      = \"vec4\"\n    Mat2      = \"mat2\"\n    Mat3      = \"mat3\"\n    Mat4      = \"mat4\"\n    Sampler2D = \"sampler2D\"\n</code></pre>"},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Float","title":"<code>Float = 'float'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Int","title":"<code>Int = 'int'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Bool","title":"<code>Bool = 'bool'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Vec2","title":"<code>Vec2 = 'vec2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Vec3","title":"<code>Vec3 = 'vec3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Vec4","title":"<code>Vec4 = 'vec4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Mat2","title":"<code>Mat2 = 'mat2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Mat3","title":"<code>Mat3 = 'mat3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Mat4","title":"<code>Mat4 = 'mat4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableType.Sampler2D","title":"<code>Sampler2D = 'sampler2D'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableInterpolation","title":"<code>Variable.ShaderVariableInterpolation</code>","text":"<p>Guidance enum for GLSL variable interpolation options</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Variable.py</code> Python<pre><code>class ShaderVariableInterpolation(BrokenEnum):\n    \"\"\"Guidance enum for GLSL variable interpolation options\"\"\"\n    Flat          = \"flat\"\n    Smooth        = \"smooth\"\n    NoPerspective = \"noperspective\"\n</code></pre>"},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableInterpolation.Flat","title":"<code>Flat = 'flat'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableInterpolation.Smooth","title":"<code>Smooth = 'smooth'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableInterpolation.NoPerspective","title":"<code>NoPerspective = 'noperspective'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableDirection","title":"<code>Variable.ShaderVariableDirection</code>","text":"<p>Guidance enum for GLSL variable direction options</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Variable.py</code> Python<pre><code>class ShaderVariableDirection(BrokenEnum):\n    \"\"\"Guidance enum for GLSL variable direction options\"\"\"\n    In  = \"in\"\n    Out = \"out\"\n</code></pre>"},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableDirection.In","title":"<code>In = 'in'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariableDirection.Out","title":"<code>Out = 'out'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable","title":"<code>Variable.ShaderVariable</code>","text":"<p>Metaprogramming class to define a shader variable</p> <p>\"uniform vec2 resolution;\" \u2022 interpolation: \"flat\", \"smooth\", \"noperspective\" (smooth) \u2022 qualifier: \"uniform\" \u2022 type:      \"vec2\" \u2022 name:      \"resolution\" \u2022 value:     Any (of self.size)</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Variable.py</code> Python<pre><code>@define(eq=False)\nclass ShaderVariable(BrokenFluentBuilder):\n    \"\"\"\n    Metaprogramming class to define a shader variable\n\n    \"uniform vec2 resolution;\"\n    \u2022 interpolation: \"flat\", \"smooth\", \"noperspective\" (smooth)\n    \u2022 qualifier: \"uniform\"\n    \u2022 type:      \"vec2\"\n    \u2022 name:      \"resolution\"\n    \u2022 value:     Any (of self.size)\n    \"\"\"\n    qualifier:     ShaderVariableQualifier     = None\n    type:          ShaderVariableType          = None\n    name:          str                         = None\n    value:         Any                         = None\n    direction:     ShaderVariableDirection     = None\n    interpolation: ShaderVariableInterpolation = None\n\n    def __hash__(self) -&gt; int:\n        return hash(self.name)\n\n    def __eq__(self, other: ShaderVariable) -&gt; bool:\n        return self.name == other.name\n\n    @property\n    def size_string(self) -&gt; str:\n        \"\"\"Get the size string for this variable\"\"\"\n        return {\n            ShaderVariableType.Float: \"f\",\n            ShaderVariableType.Int:   \"i\",\n            ShaderVariableType.Bool:  \"i\",\n            ShaderVariableType.Vec2:  \"2f\",\n            ShaderVariableType.Vec3:  \"3f\",\n            ShaderVariableType.Vec4:  \"4f\",\n        }.get(ShaderVariableType.get(self.type))\n\n    # # To string methods\n\n    @property\n    def declaration(self) -&gt; str:\n        \"\"\"String to declared this variable in GLSL\"\"\"\n        return (\" \".join(filter(None, (\n            self.interpolation,\n            self.direction,\n            self.qualifier,\n            self.type,\n            self.name,\n        )))).strip() + \";\"\n\n    @staticmethod\n    def smart(definition: str | ShaderVariable) -&gt; ShaderVariable:\n        \"\"\"Smartly creates variables from item or list of variables or string definition\"\"\"\n\n        # Return if already instance of self\n        if isinstance(definition, ShaderVariable):\n            return definition\n\n        # Attempt to smartly parse the string\n        elif isinstance(definition, str):\n            variable = ShaderVariable()\n            string = definition.replace(\";\", \"\").strip().split()\n\n            # Iterate on each line item split, attribute if an option, else name\n            for i, item in enumerate(string):\n\n                # Match against known types on enums\n                if item in ShaderVariableDirection.values():\n                    variable.direction = item\n                elif item in ShaderVariableQualifier.values():\n                    variable.qualifier = item\n                elif item in ShaderVariableType.values():\n                    variable.type = item\n                elif item in ShaderVariableInterpolation.values():\n                    variable.interpolation = item\n\n                # Item -2 can be a custom type which is not in the enum\n                elif i == len(string) - 2:\n                    variable.type = item\n\n                # Item -1 is assumed to be the name\n                elif i == len(string) - 1:\n                    variable.name = item\n\n                # Unknown item\n                else:\n                    log.warning(f\"Unknown item ({item}) on ShaderVariable Smart from ({string})\")\n\n        return variable\n</code></pre>"},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.qualifier","title":"<code>qualifier: ShaderVariableQualifier = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.type","title":"<code>type: ShaderVariableType = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.name","title":"<code>name: str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.value","title":"<code>value: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.direction","title":"<code>direction: ShaderVariableDirection = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.interpolation","title":"<code>interpolation: ShaderVariableInterpolation = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Variable.py</code> Python<pre><code>def __hash__(self) -&gt; int:\n    return hash(self.name)\n</code></pre>"},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.__eq__","title":"<code>__eq__(other: ShaderVariable) -&gt; bool</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Variable.py</code> Python<pre><code>def __eq__(self, other: ShaderVariable) -&gt; bool:\n    return self.name == other.name\n</code></pre>"},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.size_string","title":"<code>size_string: str</code>  <code>property</code>","text":"<p>Get the size string for this variable</p>"},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.declaration","title":"<code>declaration: str</code>  <code>property</code>","text":"<p>String to declared this variable in GLSL</p>"},{"location":"shaderflow/reference/variable/#Variable.ShaderVariable.smart","title":"<code>smart(definition: str | ShaderVariable) -&gt; ShaderVariable</code>  <code>staticmethod</code>","text":"<p>Smartly creates variables from item or list of variables or string definition</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Variable.py</code> Python<pre><code>@staticmethod\ndef smart(definition: str | ShaderVariable) -&gt; ShaderVariable:\n    \"\"\"Smartly creates variables from item or list of variables or string definition\"\"\"\n\n    # Return if already instance of self\n    if isinstance(definition, ShaderVariable):\n        return definition\n\n    # Attempt to smartly parse the string\n    elif isinstance(definition, str):\n        variable = ShaderVariable()\n        string = definition.replace(\";\", \"\").strip().split()\n\n        # Iterate on each line item split, attribute if an option, else name\n        for i, item in enumerate(string):\n\n            # Match against known types on enums\n            if item in ShaderVariableDirection.values():\n                variable.direction = item\n            elif item in ShaderVariableQualifier.values():\n                variable.qualifier = item\n            elif item in ShaderVariableType.values():\n                variable.type = item\n            elif item in ShaderVariableInterpolation.values():\n                variable.interpolation = item\n\n            # Item -2 can be a custom type which is not in the enum\n            elif i == len(string) - 2:\n                variable.type = item\n\n            # Item -1 is assumed to be the name\n            elif i == len(string) - 1:\n                variable.name = item\n\n            # Unknown item\n            else:\n                log.warning(f\"Unknown item ({item}) on ShaderVariable Smart from ({string})\")\n\n    return variable\n</code></pre>"},{"location":"shaderflow/reference/common/imgui/","title":"Imgui","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/common/imgui/#Common.Imgui","title":"<code>Common.Imgui</code>","text":""},{"location":"shaderflow/reference/common/notes/","title":"Notes","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/common/notes/#Common.Notes","title":"<code>Common.Notes</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.PIANO_NOTES","title":"<code>Common.Notes.PIANO_NOTES = 'C C# D D# E F F# G G# A A# B'.split()</code>  <code>module-attribute</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote","title":"<code>Common.Notes.BrokenPianoNote</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@define(eq=False)\nclass BrokenPianoNote(BrokenFluentBuilder):\n    note:     int   = 60\n    start:    float = 0\n    end:      float = 0\n    channel:  int   = 0\n    velocity: int   = 100\n    tuning:   float = 440\n\n    def __hash__(self):\n        return hash((self.note, self.start, self.end, self.channel, self.velocity))\n\n    def idk_hash(self):\n        return hash((self.note, self.channel))\n\n    def __eq__(self, other):\n        return hash(self) == hash(other)\n\n    # # Initialization\n\n    @classmethod\n    @functools.lru_cache\n    def from_index(cls, note: int, **kwargs) -&gt; Self:\n        return cls(note=note, **kwargs)\n\n    @classmethod\n    @functools.lru_cache\n    def from_name(cls, name: str, **kwargs) -&gt; Self:\n        return cls(note=BrokenPianoNote.name_to_index(name), **kwargs)\n\n    @classmethod\n    @functools.lru_cache\n    def from_frequency(cls, frequency: float, **kwargs) -&gt; Self:\n        return cls(note=BrokenPianoNote.frequency_to_index(frequency), **kwargs)\n\n    @classmethod\n    @functools.lru_cache\n    def get(cls, object: Any, **kwargs) -&gt; Self:\n        if isinstance(object, BrokenPianoNote):\n            return object(**kwargs)\n        elif isinstance(object, int):\n            return cls.from_index(object, **kwargs)\n        elif isinstance(object, str):\n            return cls.from_name(object, **kwargs)\n        elif isinstance(object, float):\n            return cls.from_frequency(object, **kwargs)\n        return cls(**kwargs)\n\n    # # Conversion\n\n    @staticmethod\n    @functools.lru_cache\n    def index_to_name(index: int) -&gt; str:\n        return f\"{PIANO_NOTES[index % 12]}{index//12 - 1}\"\n\n    @staticmethod\n    @functools.lru_cache\n    def index_to_frequency(index: int, *, tuning: float=440) -&gt; float:\n        return tuning * 2**((index - 69)/12)\n\n    @staticmethod\n    @functools.lru_cache\n    def name_to_index(name: str) -&gt; int:\n        note, octave = name[:-1].upper(), int(name[-1])\n        return PIANO_NOTES.index(note) + 12*(octave + 1)\n\n    @staticmethod\n    @functools.lru_cache\n    def name_to_frequency(name: str, *, tuning: float=440) -&gt; float:\n        return BrokenPianoNote.index_to_frequency(BrokenPianoNote.name_to_index(name), tuning=tuning)\n\n    @staticmethod\n    @functools.lru_cache\n    def frequency_to_index(frequency: float, *, tuning: float=440) -&gt; int:\n        return round(12*math.log2(frequency/tuning) + 69)\n\n    @staticmethod\n    @functools.lru_cache\n    def frequency_to_name(frequency: float, *, tuning: float=440) -&gt; str:\n        return BrokenPianoNote.index_to_name(BrokenPianoNote.frequency_to_index(frequency, tuning=tuning))\n\n    # # Utilities\n\n    @property\n    def frequency(self) -&gt; float:\n        return BrokenPianoNote.index_to_frequency(self.note, tuning=self.tuning)\n\n    @frequency.setter\n    def frequency(self, value: float):\n        self.note = BrokenPianoNote.frequency_to_index(value, tuning=self.tuning)\n\n    @property\n    def name(self) -&gt; str:\n        return BrokenPianoNote.index_to_name(self.note)\n\n    @name.setter\n    def name(self, value: str):\n        self.note = BrokenPianoNote.name_to_index(value)\n\n    # Black and White\n\n    def is_white(note: int) -&gt; bool:\n        return (note % 12) in {0, 2, 4, 5, 7, 9, 11}\n\n    def is_black(note: int) -&gt; bool:\n        return (note % 12) in {1, 3, 6, 8, 10}\n\n    @property\n    def white(self) -&gt; bool:\n        return BrokenPianoNote.is_white(self.note)\n\n    @property\n    def black(self) -&gt; bool:\n        return BrokenPianoNote.is_black(self.note)\n\n    # Temporal\n\n    @property\n    def duration(self):\n        return self.end - self.start\n\n    @duration.setter\n    def duration(self, value: float):\n        self.end = self.start + value\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.note","title":"<code>note: int = 60</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.start","title":"<code>start: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.end","title":"<code>end: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.channel","title":"<code>channel: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.velocity","title":"<code>velocity: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.tuning","title":"<code>tuning: float = 440</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>def __hash__(self):\n    return hash((self.note, self.start, self.end, self.channel, self.velocity))\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.idk_hash","title":"<code>idk_hash()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>def idk_hash(self):\n    return hash((self.note, self.channel))\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>def __eq__(self, other):\n    return hash(self) == hash(other)\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.from_index","title":"<code>from_index(note: int, **kwargs) -&gt; Self</code>  <code>cached</code> <code>classmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@classmethod\n@functools.lru_cache\ndef from_index(cls, note: int, **kwargs) -&gt; Self:\n    return cls(note=note, **kwargs)\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.from_name","title":"<code>from_name(name: str, **kwargs) -&gt; Self</code>  <code>cached</code> <code>classmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@classmethod\n@functools.lru_cache\ndef from_name(cls, name: str, **kwargs) -&gt; Self:\n    return cls(note=BrokenPianoNote.name_to_index(name), **kwargs)\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.from_frequency","title":"<code>from_frequency(frequency: float, **kwargs) -&gt; Self</code>  <code>cached</code> <code>classmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@classmethod\n@functools.lru_cache\ndef from_frequency(cls, frequency: float, **kwargs) -&gt; Self:\n    return cls(note=BrokenPianoNote.frequency_to_index(frequency), **kwargs)\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.get","title":"<code>get(object: Any, **kwargs) -&gt; Self</code>  <code>cached</code> <code>classmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@classmethod\n@functools.lru_cache\ndef get(cls, object: Any, **kwargs) -&gt; Self:\n    if isinstance(object, BrokenPianoNote):\n        return object(**kwargs)\n    elif isinstance(object, int):\n        return cls.from_index(object, **kwargs)\n    elif isinstance(object, str):\n        return cls.from_name(object, **kwargs)\n    elif isinstance(object, float):\n        return cls.from_frequency(object, **kwargs)\n    return cls(**kwargs)\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.index_to_name","title":"<code>index_to_name(index: int) -&gt; str</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef index_to_name(index: int) -&gt; str:\n    return f\"{PIANO_NOTES[index % 12]}{index//12 - 1}\"\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.index_to_frequency","title":"<code>index_to_frequency(index: int, *, tuning: float = 440) -&gt; float</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef index_to_frequency(index: int, *, tuning: float=440) -&gt; float:\n    return tuning * 2**((index - 69)/12)\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.name_to_index","title":"<code>name_to_index(name: str) -&gt; int</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef name_to_index(name: str) -&gt; int:\n    note, octave = name[:-1].upper(), int(name[-1])\n    return PIANO_NOTES.index(note) + 12*(octave + 1)\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.name_to_frequency","title":"<code>name_to_frequency(name: str, *, tuning: float = 440) -&gt; float</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef name_to_frequency(name: str, *, tuning: float=440) -&gt; float:\n    return BrokenPianoNote.index_to_frequency(BrokenPianoNote.name_to_index(name), tuning=tuning)\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.frequency_to_index","title":"<code>frequency_to_index(frequency: float, *, tuning: float = 440) -&gt; int</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef frequency_to_index(frequency: float, *, tuning: float=440) -&gt; int:\n    return round(12*math.log2(frequency/tuning) + 69)\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.frequency_to_name","title":"<code>frequency_to_name(frequency: float, *, tuning: float = 440) -&gt; str</code>  <code>cached</code> <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>@staticmethod\n@functools.lru_cache\ndef frequency_to_name(frequency: float, *, tuning: float=440) -&gt; str:\n    return BrokenPianoNote.index_to_name(BrokenPianoNote.frequency_to_index(frequency, tuning=tuning))\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.frequency","title":"<code>frequency: float</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.is_white","title":"<code>is_white(note: int) -&gt; bool</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>def is_white(note: int) -&gt; bool:\n    return (note % 12) in {0, 2, 4, 5, 7, 9, 11}\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.is_black","title":"<code>is_black(note: int) -&gt; bool</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Common/Notes.py</code> Python<pre><code>def is_black(note: int) -&gt; bool:\n    return (note % 12) in {1, 3, 6, 8, 10}\n</code></pre>"},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.white","title":"<code>white: bool</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.black","title":"<code>black: bool</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/common/notes/#Common.Notes.BrokenPianoNote.duration","title":"<code>duration</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/modules/audio/","title":"Audio","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio","title":"<code>Modules.Audio</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.fuzzy_string_search","title":"<code>Modules.Audio.fuzzy_string_search(string: str, choices: List[str], many: int = 1, minimum_score: int = 0) -&gt; list[tuple[str, int]]</code>","text":"<p>Fuzzy search a string in a list of strings, returns a list of matches</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def fuzzy_string_search(string: str, choices: List[str], many: int=1, minimum_score: int=0) -&gt; list[tuple[str, int]]:\n    \"\"\"Fuzzy search a string in a list of strings, returns a list of matches\"\"\"\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\")\n        import thefuzz.process\n        result = thefuzz.process.extract(string, choices, limit=many)\n        if many == 1:\n            return result[0]\n        return result\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.root_mean_square","title":"<code>Modules.Audio.root_mean_square(data) -&gt; float</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def root_mean_square(data) -&gt; float:\n    return numpy.sqrt(numpy.mean(numpy.square(data)))\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudioMode","title":"<code>Modules.Audio.BrokenAudioMode</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>class BrokenAudioMode(BrokenEnum):\n    Realtime = \"realtime\"\n    File     = \"file\"\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudioMode.Realtime","title":"<code>Realtime = 'realtime'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudioMode.File","title":"<code>File = 'file'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio","title":"<code>Modules.Audio.BrokenAudio</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>@define(slots=False)\nclass BrokenAudio:\n    mode: BrokenAudioMode = BrokenAudioMode.Realtime.field()\n    dtype: numpy.dtype = numpy.float32\n\n    data: numpy.ndarray = None\n    \"\"\"Progressive audio data, shape: (channels, samples)\"\"\"\n\n    tell: int = 0\n    \"\"\"The number of samples to read from the audio so far\"\"\"\n\n    def __post__(self):\n        BrokenThread.new(self._play_thread,   daemon=True)\n        BrokenThread.new(self._record_thread, daemon=True)\n        self.create_buffer()\n\n    @property\n    def buffer_size(self) -&gt; Samples:\n        return int(self.samplerate*self.buffer_seconds)\n\n    @property\n    def shape(self) -&gt; Tuple[Channels, Samples]:\n        return (self.channels, self.buffer_size)\n\n    def create_buffer(self):\n        self.data = numpy.zeros(self.shape, dtype=self.dtype)\n\n    def add_data(self, data: numpy.ndarray) -&gt; Optional[numpy.ndarray]:\n        \"\"\"\n        Roll the data to the left by the length of the new data; copy new data to the end\n        Note: Channel count must match the buffer's one\n\n        Args:\n            data: The new data of shape: (channels, length)\n\n        Returns:\n            The data that was written, if any\n        \"\"\"\n        if (data := numpy.array(data, dtype=self.dtype)).any():\n            length = data.shape[1]\n            self.data = numpy.roll(self.data, -length, axis=1)\n            self.data[:, -length:] = data\n            self.tell += length\n            return data\n\n    def get_data_between_samples(self, start: Samples, end: Samples) -&gt; numpy.ndarray:\n        return self.data[:, int(start):int(end)]\n\n    def get_data_between_seconds(self, start: Seconds, end: Seconds) -&gt; numpy.ndarray:\n        return self.get_data_between_samples(start*self.samplerate, end*self.samplerate)\n\n    def get_last_n_samples(self, n: Samples, *, offset: Samples=0) -&gt; numpy.ndarray:\n        return self.data[:, (-1)*(int(n+offset) + 1) : (-1)*(int(offset) + 1)]\n\n    def get_last_n_seconds(self, n: Seconds) -&gt; numpy.ndarray:\n        return self.get_last_n_samples(n*self.samplerate)\n\n    # ------------------------------------------|\n    # Sample Rate\n\n    _samplerate: Hertz = 44100\n\n    @property\n    def samplerate(self) -&gt; Hertz:\n        \"\"\"How many data points per second the audio is sampled at. Defaults to 44100\"\"\"\n        return self._samplerate or 44100\n\n    @samplerate.setter\n    def samplerate(self, value: Hertz):\n        self._samplerate = value\n        self.create_buffer()\n\n    # ------------------------------------------|\n    # Channels\n\n    _channels: int = 2\n\n    @property\n    def channels(self) -&gt; int:\n        \"\"\"Number of audio streams (channels). Two is stereo, one is mono. Defaults to 2\"\"\"\n        return self._channels or 2\n\n    @channels.setter\n    def channels(self, value: int):\n        self._channels = value\n        self.create_buffer()\n\n    # ------------------------------------------|\n    # History\n\n    _buffer_seconds: Seconds = 30.0\n\n    @property\n    def buffer_seconds(self) -&gt; Seconds:\n        \"\"\"Buffer length in seconds. Cheap on ram and fast, ideally have a decent side\"\"\"\n        # Note: To convince yourself, (48000 Hz) * (2 Channels) * (30 sec) * (f32=4 bytes) = 11 MB\n        return self._buffer_seconds\n\n    @buffer_seconds.setter\n    def buffer_seconds(self, value: Seconds):\n        self._buffer_seconds = value\n        self.create_buffer()\n\n    # ------------------------------------------|\n    # File\n\n    _file: Path = None\n    _file_reader: BrokenAudioReader = None\n    _file_stream: Generator[Tuple[Seconds, numpy.ndarray], None, Seconds] = None\n\n    @property\n    def file(self) -&gt; Path:\n        return self._file\n\n    @file.setter\n    def file(self, value: Path):\n        self._file = BrokenPath(value)\n        if self._file and not (self._file.exists()):\n            return log.minor(f\"Audio File doesn't exist ({value})\")\n        self.samplerate   = BrokenFFmpeg.get_audio_samplerate(self.file, echo=False)\n        self.channels     = BrokenFFmpeg.get_audio_channels(self.file, echo=False)\n        self._file_reader = BrokenAudioReader(path=self.file)\n        self._file_stream = self._file_reader.stream\n        self.mode         = BrokenAudioMode.File\n        self.close_recorder()\n\n    # ------------------------------------------|\n    # Soundcard\n\n    recorder_device: Any = None\n    recorder: Any = None\n\n    speaker_device: Any = None\n    speaker: Any = None\n\n    @staticmethod\n    def recorders() -&gt; Iterable[Any]:\n        yield from soundcard.all_microphones(include_loopback=True)\n\n    @staticmethod\n    def speakers() -&gt; Iterable[Any]:\n        yield from soundcard.all_speakers()\n\n    @staticmethod\n    def recorders_names() -&gt; Iterable[str]:\n        yield from map(lambda device: device.name, BrokenAudio.recorders())\n\n    @staticmethod\n    def speakers_names() -&gt; Iterable[str]:\n        yield from map(lambda device: device.name, BrokenAudio.speakers())\n\n    def list_recorders(self) -&gt; None:\n        \"\"\"List and print all available Audio recording devices\"\"\"\n        log.info(\"Recording Devices:\")\n        for i, device in enumerate(BrokenAudio.recorders()):\n            log.info(f\"\u2022 ({i:2d}) Recorder: '{device.name}'\")\n\n    def list_speakers(self) -&gt; None:\n        \"\"\"List and print all available Audio playback devices\"\"\"\n        log.info(\"Playback Devices:\")\n        for i, device in enumerate(BrokenAudio.speakers()):\n            log.info(f\"\u2022 ({i:2d}) Speaker: '{device.name}'\")\n\n    def __fuzzy__(self, name: str, devices: Iterable[str]) -&gt; Optional[str]:\n        device_name = fuzzy_string_search(name, devices)[0]\n        return next(filter(lambda x: x.name == device_name, devices), None)\n\n    def open_speaker(self,\n        name: str=None,\n        *,\n        samplerate: Hertz=None,\n    ) -&gt; Self:\n        \"\"\"\n        Open a SoundCard device for playing real-time audio.\n\n        Args:\n            name: The name of the device to open. If None, the default speaker is used. The search\n                is fuzzy, so the match does not need to be exact\n\n            samplerate: If None, gets self.samplerate\n\n        Returns:\n            Self, Fluent interface\n        \"\"\"\n        (self.speaker or Ignore()).__exit__(None, None, None)\n\n        # Search for the Speaker\n        if name is None:\n            self.speaker_device = soundcard.default_speaker()\n        else:\n            self.speaker_device = self.__fuzzy__(name, self.speakers_names)\n\n        # Open the speaker\n        log.info(f\"Opening Speaker with Device ({self.speaker_device})\")\n        self.speaker = self.speaker_device.player(\n            samplerate=samplerate or self.samplerate,\n        ).__enter__()\n        return self\n\n    def close_speaker(self) -&gt; Self:\n        (self.speaker or Ignore()).__exit__(None, None, None)\n        self.speaker = None\n        return self\n\n    def open_recorder(self,\n        name: str=None,\n        *,\n        samplerate: Hertz=44100,\n        channels: List[int]=None,\n        blocksize: int=512,\n    ) -&gt; Self:\n        \"\"\"\n        Open a SoundCard device for recording real-time audio. Specifics implementation adapted\n        from the `soundcard` library Source Code (docstring only)\n\n        Args:\n            name: The name of the device to open. If None, the first loopback device or default\n                microphone is used. The search is fuzzy, so the match does not need to be exact\n\n            samplerate: The desired sample rate of the audio\n\n            channels: Channels to read from the device.\n                \u2022 None: Record all available channels\n                \u2022 List[int]: Record only the specified channels\n                \u2022 -1: (Linux: Mono mix of all channels) (MacOS: Silence)\n\n            blocksize: Desired minimum latency in samples, and also the number of recorded\n                samples at a time. Lower values reduces latency and increases CPU usage, which\n                funnily enough might cause latency issues\n\n        Returns:\n            Self, Fluent interface\n        \"\"\"\n        self.close_recorder()\n\n        # Search for default loopback device\n        if name is None:\n            for device in self.recorders():\n                if device.isloopback:\n                    self.recorder_device = device\n                    break\n            self.recorder_device = (self.recorder_device or soundcard.default_microphone())\n        else:\n            self.recorder_device = self.__fuzzy__(name, self.recorders_names())\n\n        # Open the recorder\n        log.info(f\"Opening Recorder with Device ({self.recorder_device})\")\n        self.recorder = self.recorder_device.recorder(\n            samplerate=samplerate,\n            channels=channels,\n            blocksize=blocksize,\n        ).__enter__()\n\n        # Update properties\n        self.samplerate = getattr(self.recorder, \"_samplerate\", samplerate)\n        self.channels   = self.recorder_device.channels\n        self.mode       = BrokenAudioMode.Realtime\n        return self\n\n    def close_recorder(self) -&gt; Self:\n        (self.recorder or Ignore()).__exit__(None, None, None)\n        self.recorder = None\n        return self\n\n    def record(self, numframes: int=None) -&gt; Optional[numpy.ndarray]:\n        \"\"\"Record a number of samples from the recorder. 'None' records all\"\"\"\n        if not self.recorder:\n            return None\n        return self.add_data(self.recorder.record(numframes=numframes).T)\n\n    def _record_thread(self) -&gt; None:\n        while True:\n            if (self.record() is None):\n                time.sleep(0.01)\n\n    # # Playing\n\n    _play_queue: Deque[numpy.ndarray] = Factory(deque)\n\n    def play(self, data: numpy.ndarray) -&gt; None:\n        \"\"\"Add a numpy array to the play queue. for non-blocking playback\"\"\"\n        if not self.speaker_device:\n            return None\n        self._play_queue.append(data)\n\n    def _play_thread(self) -&gt; None:\n        while True:\n            if (self._play_queue and self.speaker):\n                self.speaker.play(self._play_queue.popleft().T)\n                continue\n            time.sleep(0.01)\n\n    # ------------------------------------------|\n    # Properties utils\n\n    @property\n    def stereo(self) -&gt; bool:\n        \"\"\"Is this Audio object stereo?\"\"\"\n        return (self.channels == 2)\n\n    @property\n    def mono(self) -&gt; bool:\n        \"\"\"Is this Audio object mono?\"\"\"\n        return (self.channels == 1)\n\n    @property\n    def duration(self) -&gt; Seconds:\n        if self.mode == BrokenAudioMode.Realtime:\n            return math.inf\n        if self.mode == BrokenAudioMode.File:\n            return BrokenFFmpeg.get_audio_duration(self.file)\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.mode","title":"<code>mode: BrokenAudioMode = BrokenAudioMode.Realtime.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.dtype","title":"<code>dtype: numpy.dtype = numpy.float32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.data","title":"<code>data: numpy.ndarray = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Progressive audio data, shape: (channels, samples)</p>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.tell","title":"<code>tell: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The number of samples to read from the audio so far</p>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def __post__(self):\n    BrokenThread.new(self._play_thread,   daemon=True)\n    BrokenThread.new(self._record_thread, daemon=True)\n    self.create_buffer()\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.buffer_size","title":"<code>buffer_size: Samples</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.shape","title":"<code>shape: Tuple[Channels, Samples]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.create_buffer","title":"<code>create_buffer()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def create_buffer(self):\n    self.data = numpy.zeros(self.shape, dtype=self.dtype)\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.add_data","title":"<code>add_data(data: numpy.ndarray) -&gt; Optional[numpy.ndarray]</code>","text":"<p>Roll the data to the left by the length of the new data; copy new data to the end Note: Channel count must match the buffer's one</p> <p>Parameters:</p> <ul> <li> <code>data</code>             (<code>numpy.ndarray</code>)         \u2013          <p>The new data of shape: (channels, length)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[numpy.ndarray]</code>         \u2013          <p>The data that was written, if any</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def add_data(self, data: numpy.ndarray) -&gt; Optional[numpy.ndarray]:\n    \"\"\"\n    Roll the data to the left by the length of the new data; copy new data to the end\n    Note: Channel count must match the buffer's one\n\n    Args:\n        data: The new data of shape: (channels, length)\n\n    Returns:\n        The data that was written, if any\n    \"\"\"\n    if (data := numpy.array(data, dtype=self.dtype)).any():\n        length = data.shape[1]\n        self.data = numpy.roll(self.data, -length, axis=1)\n        self.data[:, -length:] = data\n        self.tell += length\n        return data\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.get_data_between_samples","title":"<code>get_data_between_samples(start: Samples, end: Samples) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def get_data_between_samples(self, start: Samples, end: Samples) -&gt; numpy.ndarray:\n    return self.data[:, int(start):int(end)]\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.get_data_between_seconds","title":"<code>get_data_between_seconds(start: Seconds, end: Seconds) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def get_data_between_seconds(self, start: Seconds, end: Seconds) -&gt; numpy.ndarray:\n    return self.get_data_between_samples(start*self.samplerate, end*self.samplerate)\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.get_last_n_samples","title":"<code>get_last_n_samples(n: Samples, *, offset: Samples = 0) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def get_last_n_samples(self, n: Samples, *, offset: Samples=0) -&gt; numpy.ndarray:\n    return self.data[:, (-1)*(int(n+offset) + 1) : (-1)*(int(offset) + 1)]\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.get_last_n_seconds","title":"<code>get_last_n_seconds(n: Seconds) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def get_last_n_seconds(self, n: Seconds) -&gt; numpy.ndarray:\n    return self.get_last_n_samples(n*self.samplerate)\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.samplerate","title":"<code>samplerate: Hertz</code>  <code>property</code> <code>writable</code>","text":"<p>How many data points per second the audio is sampled at. Defaults to 44100</p>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.channels","title":"<code>channels: int</code>  <code>property</code> <code>writable</code>","text":"<p>Number of audio streams (channels). Two is stereo, one is mono. Defaults to 2</p>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.buffer_seconds","title":"<code>buffer_seconds: Seconds</code>  <code>property</code> <code>writable</code>","text":"<p>Buffer length in seconds. Cheap on ram and fast, ideally have a decent side</p>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.file","title":"<code>file: Path</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.recorder_device","title":"<code>recorder_device: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.recorder","title":"<code>recorder: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.speaker_device","title":"<code>speaker_device: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.speaker","title":"<code>speaker: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.recorders","title":"<code>recorders() -&gt; Iterable[Any]</code>  <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>@staticmethod\ndef recorders() -&gt; Iterable[Any]:\n    yield from soundcard.all_microphones(include_loopback=True)\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.speakers","title":"<code>speakers() -&gt; Iterable[Any]</code>  <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>@staticmethod\ndef speakers() -&gt; Iterable[Any]:\n    yield from soundcard.all_speakers()\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.recorders_names","title":"<code>recorders_names() -&gt; Iterable[str]</code>  <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>@staticmethod\ndef recorders_names() -&gt; Iterable[str]:\n    yield from map(lambda device: device.name, BrokenAudio.recorders())\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.speakers_names","title":"<code>speakers_names() -&gt; Iterable[str]</code>  <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>@staticmethod\ndef speakers_names() -&gt; Iterable[str]:\n    yield from map(lambda device: device.name, BrokenAudio.speakers())\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.list_recorders","title":"<code>list_recorders() -&gt; None</code>","text":"<p>List and print all available Audio recording devices</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def list_recorders(self) -&gt; None:\n    \"\"\"List and print all available Audio recording devices\"\"\"\n    log.info(\"Recording Devices:\")\n    for i, device in enumerate(BrokenAudio.recorders()):\n        log.info(f\"\u2022 ({i:2d}) Recorder: '{device.name}'\")\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.list_speakers","title":"<code>list_speakers() -&gt; None</code>","text":"<p>List and print all available Audio playback devices</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def list_speakers(self) -&gt; None:\n    \"\"\"List and print all available Audio playback devices\"\"\"\n    log.info(\"Playback Devices:\")\n    for i, device in enumerate(BrokenAudio.speakers()):\n        log.info(f\"\u2022 ({i:2d}) Speaker: '{device.name}'\")\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.__fuzzy__","title":"<code>__fuzzy__(name: str, devices: Iterable[str]) -&gt; Optional[str]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def __fuzzy__(self, name: str, devices: Iterable[str]) -&gt; Optional[str]:\n    device_name = fuzzy_string_search(name, devices)[0]\n    return next(filter(lambda x: x.name == device_name, devices), None)\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.open_speaker","title":"<code>open_speaker(name: str = None, *, samplerate: Hertz = None) -&gt; Self</code>","text":"<p>Open a SoundCard device for playing real-time audio.</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The name of the device to open. If None, the default speaker is used. The search is fuzzy, so the match does not need to be exact</p> </li> <li> <code>samplerate</code>             (<code>Hertz</code>, default:                 <code>None</code> )         \u2013          <p>If None, gets self.samplerate</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self, Fluent interface</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def open_speaker(self,\n    name: str=None,\n    *,\n    samplerate: Hertz=None,\n) -&gt; Self:\n    \"\"\"\n    Open a SoundCard device for playing real-time audio.\n\n    Args:\n        name: The name of the device to open. If None, the default speaker is used. The search\n            is fuzzy, so the match does not need to be exact\n\n        samplerate: If None, gets self.samplerate\n\n    Returns:\n        Self, Fluent interface\n    \"\"\"\n    (self.speaker or Ignore()).__exit__(None, None, None)\n\n    # Search for the Speaker\n    if name is None:\n        self.speaker_device = soundcard.default_speaker()\n    else:\n        self.speaker_device = self.__fuzzy__(name, self.speakers_names)\n\n    # Open the speaker\n    log.info(f\"Opening Speaker with Device ({self.speaker_device})\")\n    self.speaker = self.speaker_device.player(\n        samplerate=samplerate or self.samplerate,\n    ).__enter__()\n    return self\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.close_speaker","title":"<code>close_speaker() -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def close_speaker(self) -&gt; Self:\n    (self.speaker or Ignore()).__exit__(None, None, None)\n    self.speaker = None\n    return self\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.open_recorder","title":"<code>open_recorder(name: str = None, *, samplerate: Hertz = 44100, channels: List[int] = None, blocksize: int = 512) -&gt; Self</code>","text":"<p>Open a SoundCard device for recording real-time audio. Specifics implementation adapted from the <code>soundcard</code> library Source Code (docstring only)</p> <p>Parameters:</p> <ul> <li> <code>name</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The name of the device to open. If None, the first loopback device or default microphone is used. The search is fuzzy, so the match does not need to be exact</p> </li> <li> <code>samplerate</code>             (<code>Hertz</code>, default:                 <code>44100</code> )         \u2013          <p>The desired sample rate of the audio</p> </li> <li> <code>channels</code>             (<code>List[int]</code>, default:                 <code>None</code> )         \u2013          <p>Channels to read from the device. \u2022 None: Record all available channels \u2022 List[int]: Record only the specified channels \u2022 -1: (Linux: Mono mix of all channels) (MacOS: Silence)</p> </li> <li> <code>blocksize</code>             (<code>int</code>, default:                 <code>512</code> )         \u2013          <p>Desired minimum latency in samples, and also the number of recorded samples at a time. Lower values reduces latency and increases CPU usage, which funnily enough might cause latency issues</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self, Fluent interface</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def open_recorder(self,\n    name: str=None,\n    *,\n    samplerate: Hertz=44100,\n    channels: List[int]=None,\n    blocksize: int=512,\n) -&gt; Self:\n    \"\"\"\n    Open a SoundCard device for recording real-time audio. Specifics implementation adapted\n    from the `soundcard` library Source Code (docstring only)\n\n    Args:\n        name: The name of the device to open. If None, the first loopback device or default\n            microphone is used. The search is fuzzy, so the match does not need to be exact\n\n        samplerate: The desired sample rate of the audio\n\n        channels: Channels to read from the device.\n            \u2022 None: Record all available channels\n            \u2022 List[int]: Record only the specified channels\n            \u2022 -1: (Linux: Mono mix of all channels) (MacOS: Silence)\n\n        blocksize: Desired minimum latency in samples, and also the number of recorded\n            samples at a time. Lower values reduces latency and increases CPU usage, which\n            funnily enough might cause latency issues\n\n    Returns:\n        Self, Fluent interface\n    \"\"\"\n    self.close_recorder()\n\n    # Search for default loopback device\n    if name is None:\n        for device in self.recorders():\n            if device.isloopback:\n                self.recorder_device = device\n                break\n        self.recorder_device = (self.recorder_device or soundcard.default_microphone())\n    else:\n        self.recorder_device = self.__fuzzy__(name, self.recorders_names())\n\n    # Open the recorder\n    log.info(f\"Opening Recorder with Device ({self.recorder_device})\")\n    self.recorder = self.recorder_device.recorder(\n        samplerate=samplerate,\n        channels=channels,\n        blocksize=blocksize,\n    ).__enter__()\n\n    # Update properties\n    self.samplerate = getattr(self.recorder, \"_samplerate\", samplerate)\n    self.channels   = self.recorder_device.channels\n    self.mode       = BrokenAudioMode.Realtime\n    return self\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.close_recorder","title":"<code>close_recorder() -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def close_recorder(self) -&gt; Self:\n    (self.recorder or Ignore()).__exit__(None, None, None)\n    self.recorder = None\n    return self\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.record","title":"<code>record(numframes: int = None) -&gt; Optional[numpy.ndarray]</code>","text":"<p>Record a number of samples from the recorder. 'None' records all</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def record(self, numframes: int=None) -&gt; Optional[numpy.ndarray]:\n    \"\"\"Record a number of samples from the recorder. 'None' records all\"\"\"\n    if not self.recorder:\n        return None\n    return self.add_data(self.recorder.record(numframes=numframes).T)\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.play","title":"<code>play(data: numpy.ndarray) -&gt; None</code>","text":"<p>Add a numpy array to the play queue. for non-blocking playback</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def play(self, data: numpy.ndarray) -&gt; None:\n    \"\"\"Add a numpy array to the play queue. for non-blocking playback\"\"\"\n    if not self.speaker_device:\n        return None\n    self._play_queue.append(data)\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.stereo","title":"<code>stereo: bool</code>  <code>property</code>","text":"<p>Is this Audio object stereo?</p>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.mono","title":"<code>mono: bool</code>  <code>property</code>","text":"<p>Is this Audio object mono?</p>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.BrokenAudio.duration","title":"<code>duration: Seconds</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio","title":"<code>Modules.Audio.ShaderAudio</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>@define\nclass ShaderAudio(BrokenAudio, ShaderModule):\n\n    # Todo: Move to a ShaderAudioProcessing class\n    volume: ShaderDynamics = None\n    std:    ShaderDynamics = None\n    final:  bool = True\n\n    def __post__(self):\n        self.volume = ShaderDynamics(\n            scene=self.scene, name=f\"{self.name}Volume\",\n            frequency=2, zeta=1, response=0, value=0\n        )\n        self.std = ShaderDynamics(\n            scene=self.scene, name=f\"{self.name}STD\",\n            frequency=10, zeta=1, response=0, value=0\n        )\n\n    def commands(self):\n        return\n\n        # Common commands\n        self.scene.typer.command(self.list_recorders, panel=self.__class__.__name__)\n        self.scene.typer.command(self.list_speakers, panel=self.__class__.__name__)\n\n        # Proper commands\n        self.scene.typer.command(self.open_recorder, name=f\"{self.name}-recorder\", panel=f\"{self.__class__.__name__}: {self.name}\")\n        self.scene.typer.command(self.open_speaker, name=f\"{self.name}-speaker\", panel=f\"{self.__class__.__name__}: {self.name}\")\n\n    @property\n    def duration(self) -&gt; Seconds:\n        return BrokenFFmpeg.get_audio_duration(self.file) or self.scene.duration\n\n    def setup(self):\n        self.file = self.file\n        if (self.final and self.scene.realtime):\n            if (self.mode == BrokenAudioMode.File):\n                self.open_speaker()\n            else:\n                self.open_recorder()\n\n    def ffmpeg(self, ffmpeg: BrokenFFmpeg) -&gt; None:\n        if BrokenPath(self.file, valid=True):\n            ffmpeg.input(path=self.file)\n\n    def update(self):\n        try:\n            if self._file_stream:\n                self._file_reader.chunk = self.scene.rdt\n                data = next(self._file_stream).T\n                self.add_data(data)\n                self.play(data)\n        except StopIteration:\n            pass\n\n        self.volume.target = 2 * root_mean_square(self.get_last_n_seconds(0.1)) * (2**0.5)\n        self.std.target    = numpy.std(self.get_last_n_seconds(0.1))\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio.volume","title":"<code>volume: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio.std","title":"<code>std: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio.final","title":"<code>final: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def __post__(self):\n    self.volume = ShaderDynamics(\n        scene=self.scene, name=f\"{self.name}Volume\",\n        frequency=2, zeta=1, response=0, value=0\n    )\n    self.std = ShaderDynamics(\n        scene=self.scene, name=f\"{self.name}STD\",\n        frequency=10, zeta=1, response=0, value=0\n    )\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio.commands","title":"<code>commands()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def commands(self):\n    return\n\n    # Common commands\n    self.scene.typer.command(self.list_recorders, panel=self.__class__.__name__)\n    self.scene.typer.command(self.list_speakers, panel=self.__class__.__name__)\n\n    # Proper commands\n    self.scene.typer.command(self.open_recorder, name=f\"{self.name}-recorder\", panel=f\"{self.__class__.__name__}: {self.name}\")\n    self.scene.typer.command(self.open_speaker, name=f\"{self.name}-speaker\", panel=f\"{self.__class__.__name__}: {self.name}\")\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio.duration","title":"<code>duration: Seconds</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio.setup","title":"<code>setup()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def setup(self):\n    self.file = self.file\n    if (self.final and self.scene.realtime):\n        if (self.mode == BrokenAudioMode.File):\n            self.open_speaker()\n        else:\n            self.open_recorder()\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio.ffmpeg","title":"<code>ffmpeg(ffmpeg: BrokenFFmpeg) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def ffmpeg(self, ffmpeg: BrokenFFmpeg) -&gt; None:\n    if BrokenPath(self.file, valid=True):\n        ffmpeg.input(path=self.file)\n</code></pre>"},{"location":"shaderflow/reference/modules/audio/#Modules.Audio.ShaderAudio.update","title":"<code>update()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Audio.py</code> Python<pre><code>def update(self):\n    try:\n        if self._file_stream:\n            self._file_reader.chunk = self.scene.rdt\n            data = next(self._file_stream).T\n            self.add_data(data)\n            self.play(data)\n    except StopIteration:\n        pass\n\n    self.volume.target = 2 * root_mean_square(self.get_last_n_seconds(0.1)) * (2**0.5)\n    self.std.target    = numpy.std(self.get_last_n_seconds(0.1))\n</code></pre>"},{"location":"shaderflow/reference/modules/bouncing/","title":"Bouncing","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing","title":"<code>Modules.Bouncing</code>","text":""},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing","title":"<code>Modules.Bouncing.ShaderBouncing</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Bouncing.py</code> Python<pre><code>@define\nclass ShaderBouncing(ShaderModule):\n    name: str = \"iBounce\"\n    position: numpy.ndarray = None\n    velocity: numpy.ndarray = None\n    aspect_ratio: float = 1\n\n    def setup(self):\n        self.set_velocity_polar(1, random.uniform(0, TAU))\n        self.position = numpy.array((0.0, 0.0))\n\n    def update(self):\n        self.position += (self.velocity * self.scene.dt)\n\n        for i, limit in enumerate((self.aspect_ratio, 1)):\n            if abs(self.position[i]) &gt; limit:\n                self.velocity[i] = -self.velocity[i]\n                self.position[i] = clamp(self.position[i], -limit, limit)\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        yield ShaderVariable(\"uniform\", \"vec2\", f\"{self.name}Position\", self.position)\n        yield ShaderVariable(\"uniform\", \"vec2\", f\"{self.name}Velocity\", self.velocity)\n\n    # # Quality of Life\n\n    def set_velocity_polar(self, magnitude: float, angle: Degrees):\n        self.velocity = magnitude*numpy.array((cos(angle), sin(angle)))\n\n    @property\n    def x(self) -&gt; float:\n        return self.position[0]\n\n    @property\n    def y(self) -&gt; float:\n        return self.position[1]\n\n    @x.setter\n    def x(self, value: float):\n        self.position[0] = value\n\n    @y.setter\n    def y(self, value: float):\n        self.position[1] = value\n\n    # # Advanced\n\n    def advanced_ratios(self, image: LoadableImage, steps: int=1000) -&gt; ShaderTexture:\n        \"\"\"Get a texture of `aspect_ratio(angle)` from linspace(0, tau, steps)\"\"\"\n        ratios = numpy.zeros((steps, 1), dtype=numpy.float32)\n        image = numpy.array(LoaderImage(image))\n        width, height, _ = image.shape\n        bigger = max(width, height)\n\n        import cv2\n\n        # image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        image = image[:, :, 3]\n\n        # Make anew image with a centered raw copy\n        square = numpy.zeros((bigger, bigger), dtype=numpy.uint8)\n        x, y = (bigger-width)//2, (bigger-height)//2\n        square[x:x+width, y:y+height] = image\n\n        # Rotate the image and find its alpha content bounding box\n        for i, angle in enumerate(numpy.linspace(0, 360, steps)):\n            rotation = cv2.getRotationMatrix2D((bigger/2, bigger/2), angle, 1)\n            rotated  = cv2.warpAffine(square, rotation, (bigger, bigger))\n            thresh   = cv2.threshold(rotated, 4, 255, cv2.THRESH_BINARY)[1]\n            contours = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[0]\n            _, _, w, h = cv2.boundingRect(max(contours, key=cv2.contourArea))\n            ratios[i][0] = (w/h)\n\n        return ShaderTexture(\n            name=f\"{self.name}AspectRatio\",\n            scene=self.scene,\n            components=1,\n            width=steps,\n            height=1,\n        ).from_numpy(ratios)\n</code></pre>"},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.name","title":"<code>name: str = 'iBounce'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.position","title":"<code>position: numpy.ndarray = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.velocity","title":"<code>velocity: numpy.ndarray = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.aspect_ratio","title":"<code>aspect_ratio: float = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.setup","title":"<code>setup()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Bouncing.py</code> Python<pre><code>def setup(self):\n    self.set_velocity_polar(1, random.uniform(0, TAU))\n    self.position = numpy.array((0.0, 0.0))\n</code></pre>"},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.update","title":"<code>update()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Bouncing.py</code> Python<pre><code>def update(self):\n    self.position += (self.velocity * self.scene.dt)\n\n    for i, limit in enumerate((self.aspect_ratio, 1)):\n        if abs(self.position[i]) &gt; limit:\n            self.velocity[i] = -self.velocity[i]\n            self.position[i] = clamp(self.position[i], -limit, limit)\n</code></pre>"},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Bouncing.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    yield ShaderVariable(\"uniform\", \"vec2\", f\"{self.name}Position\", self.position)\n    yield ShaderVariable(\"uniform\", \"vec2\", f\"{self.name}Velocity\", self.velocity)\n</code></pre>"},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.set_velocity_polar","title":"<code>set_velocity_polar(magnitude: float, angle: Degrees)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Bouncing.py</code> Python<pre><code>def set_velocity_polar(self, magnitude: float, angle: Degrees):\n    self.velocity = magnitude*numpy.array((cos(angle), sin(angle)))\n</code></pre>"},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.x","title":"<code>x: float</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.y","title":"<code>y: float</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/modules/bouncing/#Modules.Bouncing.ShaderBouncing.advanced_ratios","title":"<code>advanced_ratios(image: LoadableImage, steps: int = 1000) -&gt; ShaderTexture</code>","text":"<p>Get a texture of <code>aspect_ratio(angle)</code> from linspace(0, tau, steps)</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Bouncing.py</code> Python<pre><code>def advanced_ratios(self, image: LoadableImage, steps: int=1000) -&gt; ShaderTexture:\n    \"\"\"Get a texture of `aspect_ratio(angle)` from linspace(0, tau, steps)\"\"\"\n    ratios = numpy.zeros((steps, 1), dtype=numpy.float32)\n    image = numpy.array(LoaderImage(image))\n    width, height, _ = image.shape\n    bigger = max(width, height)\n\n    import cv2\n\n    # image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    image = image[:, :, 3]\n\n    # Make anew image with a centered raw copy\n    square = numpy.zeros((bigger, bigger), dtype=numpy.uint8)\n    x, y = (bigger-width)//2, (bigger-height)//2\n    square[x:x+width, y:y+height] = image\n\n    # Rotate the image and find its alpha content bounding box\n    for i, angle in enumerate(numpy.linspace(0, 360, steps)):\n        rotation = cv2.getRotationMatrix2D((bigger/2, bigger/2), angle, 1)\n        rotated  = cv2.warpAffine(square, rotation, (bigger, bigger))\n        thresh   = cv2.threshold(rotated, 4, 255, cv2.THRESH_BINARY)[1]\n        contours = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[0]\n        _, _, w, h = cv2.boundingRect(max(contours, key=cv2.contourArea))\n        ratios[i][0] = (w/h)\n\n    return ShaderTexture(\n        name=f\"{self.name}AspectRatio\",\n        scene=self.scene,\n        components=1,\n        width=steps,\n        height=1,\n    ).from_numpy(ratios)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/","title":"Camera","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera","title":"<code>Modules.Camera</code>","text":"<p>The Camera requires some prior knowledge of a fun piece of math called Quaternions.</p> <p>They are a 4D \"imaginary\" number that inherently represents rotations in 3D space without the need of 3D rotation matrices (which are ugly!)*, and are pretty intuitive to use.</p> <ul> <li>https://github.com/moble/quaternion/wiki/Euler-angles-are-horrible</li> </ul> <p>Great resources for understanding Quaternions:</p> <p>\u2022 \"Quaternions and 3d rotation, explained interactively\" by 3blue1brown   - https://www.youtube.com/watch?v=d4EgbgTm0Bg</p> <p>\u2022 \"Visualizing quaternions (4d numbers) with stereographic projection\" by 3blue1brown   - https://www.youtube.com/watch?v=zjMuIxRvygQ</p> <p>\u2022 \"Visualizing quaternion, an explorable video series\" by Ben Eater and 3blue1brown   - https://eater.net/quaternions</p> <p>Useful resources on Linear Algebra and Coordinate Systems:</p> <p>\u2022 \"The Essence of Linear Algebra\" by 3blue1brown   - https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab</p> <p>\u2022 \"here, have a coordinate system chart~\" by @FreyaHolmer   - https://twitter.com/FreyaHolmer/status/1325556229410861056</p>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.Quaternion","title":"<code>Modules.Camera.Quaternion = quaternion.quaternion</code>  <code>module-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.Vector3D","title":"<code>Modules.Camera.Vector3D = numpy.ndarray</code>  <code>module-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.GlobalBasis","title":"<code>Modules.Camera.GlobalBasis</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>class GlobalBasis:\n    Origin = numpy.array((0, 0, 0), dtype=_dtype)\n    Null   = numpy.array((0, 0, 0), dtype=_dtype)\n    X      = numpy.array((1, 0, 0), dtype=_dtype)\n    Y      = numpy.array((0, 1, 0), dtype=_dtype)\n    Z      = numpy.array((0, 0, 1), dtype=_dtype)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.GlobalBasis.Origin","title":"<code>Origin = numpy.array((0, 0, 0), dtype=_dtype)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.GlobalBasis.Null","title":"<code>Null = numpy.array((0, 0, 0), dtype=_dtype)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.GlobalBasis.X","title":"<code>X = numpy.array((1, 0, 0), dtype=_dtype)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.GlobalBasis.Y","title":"<code>Y = numpy.array((0, 1, 0), dtype=_dtype)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.GlobalBasis.Z","title":"<code>Z = numpy.array((0, 0, 1), dtype=_dtype)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraProjection","title":"<code>Modules.Camera.CameraProjection</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraProjection--perspective","title":"Perspective","text":"<p>Project from a Plane A at the position to a Plane B at a distance of one - The plane is always perpendicular to the camera's direction - Plane A is multiplied by isometric, Plane B by Zoom</p>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraProjection--virtualreality","title":"VirtualReality","text":"<p>Two halves of the screen, one for each eye, with a separation between them</p>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraProjection--equirectangular","title":"Equirectangular","text":"<p>The \"360\u00b0\" videos we see on platforms like YouTube, it's a simples sphere projected to the screen where X defines the azimuth and Y the inclination, ranging such that they sweep the sphere</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>class CameraProjection(BrokenEnum):\n    \"\"\"\n    # Perspective\n    Project from a Plane A at the position to a Plane B at a distance of one\n    - The plane is always perpendicular to the camera's direction\n    - Plane A is multiplied by isometric, Plane B by Zoom\n\n    # VirtualReality\n    Two halves of the screen, one for each eye, with a separation between them\n\n    # Equirectangular\n    The \"360\u00b0\" videos we see on platforms like YouTube, it's a simples sphere projected to the\n    screen where X defines the azimuth and Y the inclination, ranging such that they sweep the sphere\n    \"\"\"\n    Perspective     = 0\n    VirtualReality  = 1\n    Equirectangular = 2\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraProjection.Perspective","title":"<code>Perspective = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraProjection.VirtualReality","title":"<code>VirtualReality = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraProjection.Equirectangular","title":"<code>Equirectangular = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraMode","title":"<code>Modules.Camera.CameraMode</code>","text":"<p>How to deal with Rotations and actions on 3D or 2D space - FreeCamera: Apply quaternion rotation and don't care of roll changing the \"UP\" direction - Camera2D:   Fixed direction, drag moves position on the plane of the screen, becomes isometric - Spherical:  Always correct such that the camera orthonormal base is pointing \"UP\"</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>class CameraMode(BrokenEnum):\n    \"\"\"\n    How to deal with Rotations and actions on 3D or 2D space\n    - FreeCamera: Apply quaternion rotation and don't care of roll changing the \"UP\" direction\n    - Camera2D:   Fixed direction, drag moves position on the plane of the screen, becomes isometric\n    - Spherical:  Always correct such that the camera orthonormal base is pointing \"UP\"\n    \"\"\"\n    FreeCamera = 0\n    Camera2D   = 1\n    Spherical  = 2\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraMode.FreeCamera","title":"<code>FreeCamera = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraMode.Camera2D","title":"<code>Camera2D = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.CameraMode.Spherical","title":"<code>Spherical = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.Algebra","title":"<code>Modules.Camera.Algebra</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>class Algebra:\n\n    def rotate_vector(vector: Vector3D, R: Quaternion) -&gt; Vector3D:\n        \"\"\"\n        Applies a Quaternion rotation to a vector.\n\n        \u2022 Permalink: https://github.com/moble/quaternion/blob/2286c479016097b156682eddaf927036c192c22e/src/quaternion/__init__.py#L654\n\n        As numpy-quaternion documentation says, we should avoid quaternion.rotate_vectors\n        when we don't have multiple vectors to rotate, and we mean a lot of vectors.\n\n        Args:\n            vector (Vector3D): Vector to rotate\n            R (Quaternion): Rotation quaternion\n\n        Returns:\n            Vector3D: Rotated vector\n        \"\"\"\n        # Potential speed gains, need to verify\n        # if sum(quaternion.as_float_array(R)[1:]) &lt; 1e-6:\n            # return vector\n        return quaternion.as_vector_part(R * quaternion.quaternion(0, *vector) * R.conjugate())\n\n    def quaternion(axis: Vector3D, angle: Degrees) -&gt; Quaternion:\n        \"\"\"Builds a quaternion that represents an rotation around an axis for an angle\"\"\"\n        theta = math.radians(angle/2)\n        return Quaternion(math.cos(theta), *(math.sin(theta)*axis))\n\n    def angle(A: Vector3D, B: Vector3D) -&gt; Degrees:\n        \"\"\"\n        Returns the angle between two vectors by the linear algebra formula:\n        \u2022 Theta(A, B) = arccos( (A\u00b7B) / (|A|*|B|) )\n        \u2022 Safe for zero vector norm divisions\n        \u2022 Clips the arccos domain to [-1, 1] to avoid NaNs\n        \"\"\"\n        A, B = DynamicNumber.extract(A, B)\n\n        # Avoid zero divisions\n        if not (LA := numpy.linalg.norm(A)):\n            return 0.0\n        if not (LB := numpy.linalg.norm(B)):\n            return 0.0\n\n        # Inner cosine; avoid NaNs\n        cos = numpy.clip(numpy.dot(A, B)/(LA*LB), -1, 1)\n        return numpy.degrees(numpy.arccos(cos))\n\n    def unit_vector(vector: Vector3D) -&gt; Vector3D:\n        \"\"\"Returns the unit vector of a given vector, safely\"\"\"\n        if (factor := numpy.linalg.norm(vector)):\n            return vector/factor\n        return vector\n\n    @staticmethod\n    def safe(\n        *vector: Union[numpy.ndarray, Tuple[float], float, int],\n        dimensions: int=3,\n        dtype: numpy.dtype=_dtype\n    ) -&gt; numpy.ndarray:\n        \"\"\"\n        Returns a safe numpy array from a given vector, with the correct dimensions and dtype\n        \"\"\"\n        return numpy.array(vector, dtype=dtype).reshape(dimensions)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.Algebra.rotate_vector","title":"<code>rotate_vector(vector: Vector3D, R: Quaternion) -&gt; Vector3D</code>","text":"<p>Applies a Quaternion rotation to a vector.</p> <p>\u2022 Permalink: https://github.com/moble/quaternion/blob/2286c479016097b156682eddaf927036c192c22e/src/quaternion/__init__.py#L654</p> <p>As numpy-quaternion documentation says, we should avoid quaternion.rotate_vectors when we don't have multiple vectors to rotate, and we mean a lot of vectors.</p> <p>Parameters:</p> <ul> <li> <code>vector</code>             (<code>Vector3D</code>)         \u2013          <p>Vector to rotate</p> </li> <li> <code>R</code>             (<code>Quaternion</code>)         \u2013          <p>Rotation quaternion</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vector3D</code> (            <code>Vector3D</code> )        \u2013          <p>Rotated vector</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def rotate_vector(vector: Vector3D, R: Quaternion) -&gt; Vector3D:\n    \"\"\"\n    Applies a Quaternion rotation to a vector.\n\n    \u2022 Permalink: https://github.com/moble/quaternion/blob/2286c479016097b156682eddaf927036c192c22e/src/quaternion/__init__.py#L654\n\n    As numpy-quaternion documentation says, we should avoid quaternion.rotate_vectors\n    when we don't have multiple vectors to rotate, and we mean a lot of vectors.\n\n    Args:\n        vector (Vector3D): Vector to rotate\n        R (Quaternion): Rotation quaternion\n\n    Returns:\n        Vector3D: Rotated vector\n    \"\"\"\n    # Potential speed gains, need to verify\n    # if sum(quaternion.as_float_array(R)[1:]) &lt; 1e-6:\n        # return vector\n    return quaternion.as_vector_part(R * quaternion.quaternion(0, *vector) * R.conjugate())\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.Algebra.quaternion","title":"<code>quaternion(axis: Vector3D, angle: Degrees) -&gt; Quaternion</code>","text":"<p>Builds a quaternion that represents an rotation around an axis for an angle</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def quaternion(axis: Vector3D, angle: Degrees) -&gt; Quaternion:\n    \"\"\"Builds a quaternion that represents an rotation around an axis for an angle\"\"\"\n    theta = math.radians(angle/2)\n    return Quaternion(math.cos(theta), *(math.sin(theta)*axis))\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.Algebra.angle","title":"<code>angle(A: Vector3D, B: Vector3D) -&gt; Degrees</code>","text":"<p>Returns the angle between two vectors by the linear algebra formula: \u2022 Theta(A, B) = arccos( (A\u00b7B) / (|A|*|B|) ) \u2022 Safe for zero vector norm divisions \u2022 Clips the arccos domain to [-1, 1] to avoid NaNs</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def angle(A: Vector3D, B: Vector3D) -&gt; Degrees:\n    \"\"\"\n    Returns the angle between two vectors by the linear algebra formula:\n    \u2022 Theta(A, B) = arccos( (A\u00b7B) / (|A|*|B|) )\n    \u2022 Safe for zero vector norm divisions\n    \u2022 Clips the arccos domain to [-1, 1] to avoid NaNs\n    \"\"\"\n    A, B = DynamicNumber.extract(A, B)\n\n    # Avoid zero divisions\n    if not (LA := numpy.linalg.norm(A)):\n        return 0.0\n    if not (LB := numpy.linalg.norm(B)):\n        return 0.0\n\n    # Inner cosine; avoid NaNs\n    cos = numpy.clip(numpy.dot(A, B)/(LA*LB), -1, 1)\n    return numpy.degrees(numpy.arccos(cos))\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.Algebra.unit_vector","title":"<code>unit_vector(vector: Vector3D) -&gt; Vector3D</code>","text":"<p>Returns the unit vector of a given vector, safely</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def unit_vector(vector: Vector3D) -&gt; Vector3D:\n    \"\"\"Returns the unit vector of a given vector, safely\"\"\"\n    if (factor := numpy.linalg.norm(vector)):\n        return vector/factor\n    return vector\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.Algebra.safe","title":"<code>safe(*vector: Union[numpy.ndarray, Tuple[float], float, int], dimensions: int = 3, dtype: numpy.dtype = _dtype) -&gt; numpy.ndarray</code>  <code>staticmethod</code>","text":"<p>Returns a safe numpy array from a given vector, with the correct dimensions and dtype</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>@staticmethod\ndef safe(\n    *vector: Union[numpy.ndarray, Tuple[float], float, int],\n    dimensions: int=3,\n    dtype: numpy.dtype=_dtype\n) -&gt; numpy.ndarray:\n    \"\"\"\n    Returns a safe numpy array from a given vector, with the correct dimensions and dtype\n    \"\"\"\n    return numpy.array(vector, dtype=dtype).reshape(dimensions)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera","title":"<code>Modules.Camera.ShaderCamera</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>@define\nclass ShaderCamera(ShaderModule):\n    name:       str = \"iCamera\"\n    mode:       CameraMode       = CameraMode.Camera2D.field()\n    projection: CameraProjection = CameraProjection.Perspective.field()\n    separation: ShaderDynamics = None\n    rotation:   ShaderDynamics = None\n    position:   ShaderDynamics = None\n    up:         ShaderDynamics = None\n    zoom:       ShaderDynamics = None\n    isometric:  ShaderDynamics = None\n    orbital:    ShaderDynamics = None\n    dolly:      ShaderDynamics = None\n\n    def __post__(self):\n        self.position = ShaderDynamics(scene=self.scene,\n            name=f\"{self.name}Position\", real=True,\n            frequency=7, zeta=1, response=1,\n            value=numpy.copy(GlobalBasis.Origin)\n        )\n        self.separation = ShaderDynamics(scene=self.scene,\n            name=f\"{self.name}VRSeparation\", real=True,\n            frequency=0.5, zeta=1, response=0, value=0.1\n        )\n        self.rotation = ShaderDynamics(scene=self.scene,\n            name=f\"{self.name}Rotation\", real=True,\n            frequency=5, zeta=1, response=0,\n            value=Quaternion(1, 0, 0, 0)\n        )\n        self.up = ShaderDynamics(scene=self.scene,\n            name=f\"{self.name}UP\", real=True,\n            frequency=1, zeta=1, response=0,\n            value=numpy.copy(GlobalBasis.Y)\n        )\n        self.zoom = ShaderDynamics(scene=self.scene,\n            name=f\"{self.name}Zoom\", real=True,\n            frequency=3, zeta=1, response=0, value=1\n        )\n        self.isometric = ShaderDynamics(scene=self.scene,\n            name=f\"{self.name}Isometric\", real=True,\n            frequency=1, zeta=1, response=0, value=0\n        )\n        self.orbital = ShaderDynamics(scene=self.scene,\n            name=f\"{self.name}Orbital\", real=True,\n            frequency=1, zeta=1, response=0, value=0\n        )\n        self.dolly = ShaderDynamics(scene=self.scene,\n            name=f\"{self.name}Dolly\", real=True,\n            frequency=1, zeta=1, response=0, value=0\n        )\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        yield ShaderVariable(\"uniform\", \"int\",  f\"{self.name}Mode\",       value=self.mode.value)\n        yield ShaderVariable(\"uniform\", \"int\",  f\"{self.name}Projection\", value=self.projection.value)\n        yield ShaderVariable(\"uniform\", \"vec3\", f\"{self.name}X\", value=self.base_x)\n        yield ShaderVariable(\"uniform\", \"vec3\", f\"{self.name}Y\", value=self.base_y)\n        yield ShaderVariable(\"uniform\", \"vec3\", f\"{self.name}Z\", value=self.base_z)\n\n    def includes(self) -&gt; Iterable[str]:\n        yield SHADERFLOW.RESOURCES.SHADERS_INCLUDE/\"Camera.glsl\"\n\n    # ---------------------------------------------------------------------------------------------|\n    # Actions with vectors\n\n    def move(self, *direction: Vector3D, absolute: bool=False) -&gt; Self:\n        \"\"\"\n        Move the camera in a direction relative to the camera's position\n\n        Args:\n            direction: Direction to move\n\n        Returns:\n            Self: Fluent interface\n        \"\"\"\n        if not absolute:\n            self.position.target += Algebra.safe(direction)\n        else:\n            self.position.target  = Algebra.safe(direction)\n        return self\n\n    def rotate(self, direction: Vector3D=GlobalBasis.Null, angle: Degrees=0.0) -&gt; Self:\n        \"\"\"\n        Adds a cumulative rotation to the camera. Use \"look\" for absolute rotation\n\n        Args:\n            direction: Perpendicular axis to rotate around, following the right-hand rule\n            angle:     Angle to rotate\n\n        Returns:\n            Self: Fluent interface\n        \"\"\"\n        self.rotation.target = Algebra.quaternion(direction, angle) * self.rotation.target\n        self.rotation.target /= numpy.linalg.norm(quaternion.as_float_array(self.rotation.target))\n        return self\n\n    def rotate2d(self, angle: Degrees=0.0) -&gt; Self:\n        \"\"\"Aligns the UP vector rotated on FORWARD direction. Same math angle on a cartesian plane\"\"\"\n        target = Algebra.rotate_vector(self.up.value, Algebra.quaternion(self.base_z_target, angle))\n        return self.align(self.base_y_target, target)\n\n    def align(self, A: Vector3D, B: Vector3D, angle: Degrees=0) -&gt; Self:\n        \"\"\"\n        Rotate the camera as if we were to align these two vectors\n        \"\"\"\n        A, B = DynamicNumber.extract(A, B)\n        return self.rotate(\n            Algebra.unit_vector(numpy.cross(A, B)),\n            Algebra.angle(A, B) - angle\n        )\n\n    def look(self, *target: Vector3D) -&gt; Self:\n        \"\"\"\n        Rotate the camera to look at some target point\n\n        Args:\n            target: Target point to look at\n\n        Returns:\n            Self: Fluent interface\n        \"\"\"\n        return self.align(self.base_z_target, Algebra.safe(target) - self.position.target)\n\n    # ---------------------------------------------------------------------------------------------|\n    # Bases and directions\n\n    @property\n    def base_x(self) -&gt; Vector3D:\n        return Algebra.rotate_vector(GlobalBasis.X, self.rotation.value)\n    @property\n    def base_x_target(self) -&gt; Vector3D:\n        return Algebra.rotate_vector(GlobalBasis.X, self.rotation.target)\n\n    @property\n    def base_y(self) -&gt; Vector3D:\n        return Algebra.rotate_vector(GlobalBasis.Y, self.rotation.value)\n    @property\n    def base_y_target(self) -&gt; Vector3D:\n        return Algebra.rotate_vector(GlobalBasis.Y, self.rotation.target)\n\n    @property\n    def base_z(self) -&gt; Vector3D:\n        return Algebra.rotate_vector(GlobalBasis.Z, self.rotation.value)\n    @property\n    def base_z_target(self) -&gt; Vector3D:\n        return Algebra.rotate_vector(GlobalBasis.Z, self.rotation.target)\n\n    @property\n    def x(self) -&gt; float:\n        return self.position.value[0]\n    @x.setter\n    def x(self, value: float):\n        self.position.target[0] = value\n\n    @property\n    def y(self) -&gt; float:\n        return self.position.value[1]\n    @y.setter\n    def y(self, value: float):\n        self.position.target[1] = value\n\n    @property\n    def z(self) -&gt; float:\n        return self.position.value[2]\n    @z.setter\n    def z(self, value: float):\n        self.position.target[2] = value\n\n    # ---------------------------------------------------------------------------------------------|\n    # Interaction\n\n    def update(self):\n        dt = abs(self.scene.dt or self.scene.rdt)\n\n        # Movement on keys\n        move = numpy.copy(GlobalBasis.Null)\n\n        # WASD Shift Spacebar movement\n        if self.mode == CameraMode.Camera2D:\n            if self.scene.keyboard(ShaderKeyboard.Keys.W): move += GlobalBasis.Y\n            if self.scene.keyboard(ShaderKeyboard.Keys.A): move -= GlobalBasis.X\n            if self.scene.keyboard(ShaderKeyboard.Keys.S): move -= GlobalBasis.Y\n            if self.scene.keyboard(ShaderKeyboard.Keys.D): move += GlobalBasis.X\n        else:\n            if self.scene.keyboard(ShaderKeyboard.Keys.W): move += GlobalBasis.Z\n            if self.scene.keyboard(ShaderKeyboard.Keys.A): move -= GlobalBasis.X\n            if self.scene.keyboard(ShaderKeyboard.Keys.S): move -= GlobalBasis.Z\n            if self.scene.keyboard(ShaderKeyboard.Keys.D): move += GlobalBasis.X\n            if self.scene.keyboard(ShaderKeyboard.Keys.SPACE): move += GlobalBasis.Y\n            if self.scene.keyboard(ShaderKeyboard.Keys.LEFT_SHIFT): move -= GlobalBasis.Y\n\n        if move.any():\n            move = Algebra.rotate_vector(move, self.rotation.target)\n            self.move(2 * Algebra.unit_vector(move) * dt / self.zoom.value)\n\n        # Rotation on Q and E\n        rotate = numpy.copy(GlobalBasis.Null)\n        if self.scene.keyboard(ShaderKeyboard.Keys.Q): rotate += GlobalBasis.Z\n        if self.scene.keyboard(ShaderKeyboard.Keys.E): rotate -= GlobalBasis.Z\n        if rotate.any(): self.rotate(Algebra.rotate_vector(rotate, self.rotation.target), 45*dt)\n\n        # Alignment with the \"UP\" direction\n        if self.mode == CameraMode.Spherical:\n            self.align(self.base_x_target, self.up, 90)\n\n        # Isometric on T and G\n        self.apply_isometric(+0.5*self.scene.keyboard(ShaderKeyboard.Keys.T)*dt)\n        self.apply_isometric(-0.5*self.scene.keyboard(ShaderKeyboard.Keys.G)*dt)\n\n    def apply_isometric(self, value: float, absolute: bool=False) -&gt; None:\n        if value == 0:\n            return\n        if not absolute:\n            self.isometric.target += value\n        else:\n            self.isometric.target = value\n        self.isometric.target = clamp(self.isometric.target, 0, 1)\n\n    def apply_zoom(self, value: float) -&gt; None:\n        # Note: Need to separate multiply and divide to return to the original value\n        if value &gt; 0:\n            self.zoom.target *= (1 + value)\n        else:\n            self.zoom.target /= (1 - value)\n\n    def handle(self, message: ShaderMessage):\n\n        # Movement on Drag\n        if any([\n            isinstance(message, ShaderMessage.Mouse.Position) and self.scene.exclusive,\n            isinstance(message, ShaderMessage.Mouse.Drag)\n        ]):\n            if not (self.scene.mouse_buttons[1] or self.scene.exclusive):\n                return\n\n            # Rotate around the camera basis itself\n            if (self.mode == CameraMode.FreeCamera):\n                self.rotate(direction=self.base_y/self.zoom.value, angle= message.du*100)\n                self.rotate(direction=self.base_x/self.zoom.value, angle=-message.dv*100)\n\n            # Rotate relative to the XY plane\n            elif (self.mode == CameraMode.Camera2D):\n                move = (message.du*GlobalBasis.X) + (message.dv*GlobalBasis.Y)\n                move = Algebra.rotate_vector(move, self.rotation.target)\n                self.move(move*(1 if self.scene.exclusive else -1)/self.zoom.value)\n\n            elif (self.mode == CameraMode.Spherical):\n                up = 1 if (Algebra.angle(self.base_y_target, self.up) &lt; 90) else -1\n                self.rotate(direction=self.up*up /self.zoom.value, angle= message.du*100)\n                self.rotate(direction=self.base_x/self.zoom.value, angle=-message.dv*100)\n\n        # Wheel Scroll Zoom\n        elif isinstance(message, ShaderMessage.Mouse.Scroll):\n            self.apply_zoom(0.05*message.dy)\n\n        # Camera alignments and modes\n        elif isinstance(message, ShaderMessage.Keyboard.Press) and (message.action == 1):\n\n            # Switch camera modes\n            for _ in range(1):\n                if (message.key == ShaderKeyboard.Keys.NUMBER_1):\n                    self.mode = CameraMode.FreeCamera\n                elif (message.key == ShaderKeyboard.Keys.NUMBER_2):\n                    self.align(self.base_x_target, GlobalBasis.X)\n                    self.align(self.base_y_target, GlobalBasis.Y)\n                    self.mode = CameraMode.Camera2D\n                    self.position.target[2] = 0\n                    self.isometric.target = 0\n                    self.zoom.target = 1\n                elif (message.key == ShaderKeyboard.Keys.NUMBER_3):\n                    self.mode = CameraMode.Spherical\n                else: break\n            else:\n                log.info(f\"{self.who} \u2022 Set mode to {self.mode}\")\n\n            # What is \"UP\", baby don't hurt me\n            for _ in range(1):\n                if (message.key == ShaderKeyboard.Keys.I):\n                    self.up.target = GlobalBasis.X\n                elif (message.key == ShaderKeyboard.Keys.J):\n                    self.up.target = GlobalBasis.Y\n                elif (message.key == ShaderKeyboard.Keys.K):\n                    self.up.target = GlobalBasis.Z\n                else: break\n            else:\n                log.info(f\"{self.who} \u2022 Set up to {self.up.target}\")\n                self.align(self.base_z_target, self.up.target)\n                self.align(self.base_y_target, self.up.target, 90)\n                self.align(self.base_x_target, self.up.target, 90)\n\n            # Switch Projection\n            if (message.key == ShaderKeyboard.Keys.P):\n                self.projection = next(self.projection)\n                log.info(f\"{self.who} \u2022 Set projection to {self.projection}\")\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.name","title":"<code>name: str = 'iCamera'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.mode","title":"<code>mode: CameraMode = CameraMode.Camera2D.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.projection","title":"<code>projection: CameraProjection = CameraProjection.Perspective.field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.separation","title":"<code>separation: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.rotation","title":"<code>rotation: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.position","title":"<code>position: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.up","title":"<code>up: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.zoom","title":"<code>zoom: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.isometric","title":"<code>isometric: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.orbital","title":"<code>orbital: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.dolly","title":"<code>dolly: ShaderDynamics = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def __post__(self):\n    self.position = ShaderDynamics(scene=self.scene,\n        name=f\"{self.name}Position\", real=True,\n        frequency=7, zeta=1, response=1,\n        value=numpy.copy(GlobalBasis.Origin)\n    )\n    self.separation = ShaderDynamics(scene=self.scene,\n        name=f\"{self.name}VRSeparation\", real=True,\n        frequency=0.5, zeta=1, response=0, value=0.1\n    )\n    self.rotation = ShaderDynamics(scene=self.scene,\n        name=f\"{self.name}Rotation\", real=True,\n        frequency=5, zeta=1, response=0,\n        value=Quaternion(1, 0, 0, 0)\n    )\n    self.up = ShaderDynamics(scene=self.scene,\n        name=f\"{self.name}UP\", real=True,\n        frequency=1, zeta=1, response=0,\n        value=numpy.copy(GlobalBasis.Y)\n    )\n    self.zoom = ShaderDynamics(scene=self.scene,\n        name=f\"{self.name}Zoom\", real=True,\n        frequency=3, zeta=1, response=0, value=1\n    )\n    self.isometric = ShaderDynamics(scene=self.scene,\n        name=f\"{self.name}Isometric\", real=True,\n        frequency=1, zeta=1, response=0, value=0\n    )\n    self.orbital = ShaderDynamics(scene=self.scene,\n        name=f\"{self.name}Orbital\", real=True,\n        frequency=1, zeta=1, response=0, value=0\n    )\n    self.dolly = ShaderDynamics(scene=self.scene,\n        name=f\"{self.name}Dolly\", real=True,\n        frequency=1, zeta=1, response=0, value=0\n    )\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    yield ShaderVariable(\"uniform\", \"int\",  f\"{self.name}Mode\",       value=self.mode.value)\n    yield ShaderVariable(\"uniform\", \"int\",  f\"{self.name}Projection\", value=self.projection.value)\n    yield ShaderVariable(\"uniform\", \"vec3\", f\"{self.name}X\", value=self.base_x)\n    yield ShaderVariable(\"uniform\", \"vec3\", f\"{self.name}Y\", value=self.base_y)\n    yield ShaderVariable(\"uniform\", \"vec3\", f\"{self.name}Z\", value=self.base_z)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.includes","title":"<code>includes() -&gt; Iterable[str]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def includes(self) -&gt; Iterable[str]:\n    yield SHADERFLOW.RESOURCES.SHADERS_INCLUDE/\"Camera.glsl\"\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.move","title":"<code>move(*direction: Vector3D, absolute: bool = False) -&gt; Self</code>","text":"<p>Move the camera in a direction relative to the camera's position</p> <p>Parameters:</p> <ul> <li> <code>direction</code>             (<code>Vector3D</code>, default:                 <code>()</code> )         \u2013          <p>Direction to move</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (            <code>Self</code> )        \u2013          <p>Fluent interface</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def move(self, *direction: Vector3D, absolute: bool=False) -&gt; Self:\n    \"\"\"\n    Move the camera in a direction relative to the camera's position\n\n    Args:\n        direction: Direction to move\n\n    Returns:\n        Self: Fluent interface\n    \"\"\"\n    if not absolute:\n        self.position.target += Algebra.safe(direction)\n    else:\n        self.position.target  = Algebra.safe(direction)\n    return self\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.rotate","title":"<code>rotate(direction: Vector3D = GlobalBasis.Null, angle: Degrees = 0.0) -&gt; Self</code>","text":"<p>Adds a cumulative rotation to the camera. Use \"look\" for absolute rotation</p> <p>Parameters:</p> <ul> <li> <code>direction</code>             (<code>Vector3D</code>, default:                 <code>GlobalBasis.Null</code> )         \u2013          <p>Perpendicular axis to rotate around, following the right-hand rule</p> </li> <li> <code>angle</code>             (<code>Degrees</code>, default:                 <code>0.0</code> )         \u2013          <p>Angle to rotate</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (            <code>Self</code> )        \u2013          <p>Fluent interface</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def rotate(self, direction: Vector3D=GlobalBasis.Null, angle: Degrees=0.0) -&gt; Self:\n    \"\"\"\n    Adds a cumulative rotation to the camera. Use \"look\" for absolute rotation\n\n    Args:\n        direction: Perpendicular axis to rotate around, following the right-hand rule\n        angle:     Angle to rotate\n\n    Returns:\n        Self: Fluent interface\n    \"\"\"\n    self.rotation.target = Algebra.quaternion(direction, angle) * self.rotation.target\n    self.rotation.target /= numpy.linalg.norm(quaternion.as_float_array(self.rotation.target))\n    return self\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.rotate2d","title":"<code>rotate2d(angle: Degrees = 0.0) -&gt; Self</code>","text":"<p>Aligns the UP vector rotated on FORWARD direction. Same math angle on a cartesian plane</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def rotate2d(self, angle: Degrees=0.0) -&gt; Self:\n    \"\"\"Aligns the UP vector rotated on FORWARD direction. Same math angle on a cartesian plane\"\"\"\n    target = Algebra.rotate_vector(self.up.value, Algebra.quaternion(self.base_z_target, angle))\n    return self.align(self.base_y_target, target)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.align","title":"<code>align(A: Vector3D, B: Vector3D, angle: Degrees = 0) -&gt; Self</code>","text":"<p>Rotate the camera as if we were to align these two vectors</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def align(self, A: Vector3D, B: Vector3D, angle: Degrees=0) -&gt; Self:\n    \"\"\"\n    Rotate the camera as if we were to align these two vectors\n    \"\"\"\n    A, B = DynamicNumber.extract(A, B)\n    return self.rotate(\n        Algebra.unit_vector(numpy.cross(A, B)),\n        Algebra.angle(A, B) - angle\n    )\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.look","title":"<code>look(*target: Vector3D) -&gt; Self</code>","text":"<p>Rotate the camera to look at some target point</p> <p>Parameters:</p> <ul> <li> <code>target</code>             (<code>Vector3D</code>, default:                 <code>()</code> )         \u2013          <p>Target point to look at</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (            <code>Self</code> )        \u2013          <p>Fluent interface</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def look(self, *target: Vector3D) -&gt; Self:\n    \"\"\"\n    Rotate the camera to look at some target point\n\n    Args:\n        target: Target point to look at\n\n    Returns:\n        Self: Fluent interface\n    \"\"\"\n    return self.align(self.base_z_target, Algebra.safe(target) - self.position.target)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.base_x","title":"<code>base_x: Vector3D</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.base_x_target","title":"<code>base_x_target: Vector3D</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.base_y","title":"<code>base_y: Vector3D</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.base_y_target","title":"<code>base_y_target: Vector3D</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.base_z","title":"<code>base_z: Vector3D</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.base_z_target","title":"<code>base_z_target: Vector3D</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.x","title":"<code>x: float</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.y","title":"<code>y: float</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.z","title":"<code>z: float</code>  <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.update","title":"<code>update()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def update(self):\n    dt = abs(self.scene.dt or self.scene.rdt)\n\n    # Movement on keys\n    move = numpy.copy(GlobalBasis.Null)\n\n    # WASD Shift Spacebar movement\n    if self.mode == CameraMode.Camera2D:\n        if self.scene.keyboard(ShaderKeyboard.Keys.W): move += GlobalBasis.Y\n        if self.scene.keyboard(ShaderKeyboard.Keys.A): move -= GlobalBasis.X\n        if self.scene.keyboard(ShaderKeyboard.Keys.S): move -= GlobalBasis.Y\n        if self.scene.keyboard(ShaderKeyboard.Keys.D): move += GlobalBasis.X\n    else:\n        if self.scene.keyboard(ShaderKeyboard.Keys.W): move += GlobalBasis.Z\n        if self.scene.keyboard(ShaderKeyboard.Keys.A): move -= GlobalBasis.X\n        if self.scene.keyboard(ShaderKeyboard.Keys.S): move -= GlobalBasis.Z\n        if self.scene.keyboard(ShaderKeyboard.Keys.D): move += GlobalBasis.X\n        if self.scene.keyboard(ShaderKeyboard.Keys.SPACE): move += GlobalBasis.Y\n        if self.scene.keyboard(ShaderKeyboard.Keys.LEFT_SHIFT): move -= GlobalBasis.Y\n\n    if move.any():\n        move = Algebra.rotate_vector(move, self.rotation.target)\n        self.move(2 * Algebra.unit_vector(move) * dt / self.zoom.value)\n\n    # Rotation on Q and E\n    rotate = numpy.copy(GlobalBasis.Null)\n    if self.scene.keyboard(ShaderKeyboard.Keys.Q): rotate += GlobalBasis.Z\n    if self.scene.keyboard(ShaderKeyboard.Keys.E): rotate -= GlobalBasis.Z\n    if rotate.any(): self.rotate(Algebra.rotate_vector(rotate, self.rotation.target), 45*dt)\n\n    # Alignment with the \"UP\" direction\n    if self.mode == CameraMode.Spherical:\n        self.align(self.base_x_target, self.up, 90)\n\n    # Isometric on T and G\n    self.apply_isometric(+0.5*self.scene.keyboard(ShaderKeyboard.Keys.T)*dt)\n    self.apply_isometric(-0.5*self.scene.keyboard(ShaderKeyboard.Keys.G)*dt)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.apply_isometric","title":"<code>apply_isometric(value: float, absolute: bool = False) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def apply_isometric(self, value: float, absolute: bool=False) -&gt; None:\n    if value == 0:\n        return\n    if not absolute:\n        self.isometric.target += value\n    else:\n        self.isometric.target = value\n    self.isometric.target = clamp(self.isometric.target, 0, 1)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.apply_zoom","title":"<code>apply_zoom(value: float) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def apply_zoom(self, value: float) -&gt; None:\n    # Note: Need to separate multiply and divide to return to the original value\n    if value &gt; 0:\n        self.zoom.target *= (1 + value)\n    else:\n        self.zoom.target /= (1 - value)\n</code></pre>"},{"location":"shaderflow/reference/modules/camera/#Modules.Camera.ShaderCamera.handle","title":"<code>handle(message: ShaderMessage)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Camera.py</code> Python<pre><code>def handle(self, message: ShaderMessage):\n\n    # Movement on Drag\n    if any([\n        isinstance(message, ShaderMessage.Mouse.Position) and self.scene.exclusive,\n        isinstance(message, ShaderMessage.Mouse.Drag)\n    ]):\n        if not (self.scene.mouse_buttons[1] or self.scene.exclusive):\n            return\n\n        # Rotate around the camera basis itself\n        if (self.mode == CameraMode.FreeCamera):\n            self.rotate(direction=self.base_y/self.zoom.value, angle= message.du*100)\n            self.rotate(direction=self.base_x/self.zoom.value, angle=-message.dv*100)\n\n        # Rotate relative to the XY plane\n        elif (self.mode == CameraMode.Camera2D):\n            move = (message.du*GlobalBasis.X) + (message.dv*GlobalBasis.Y)\n            move = Algebra.rotate_vector(move, self.rotation.target)\n            self.move(move*(1 if self.scene.exclusive else -1)/self.zoom.value)\n\n        elif (self.mode == CameraMode.Spherical):\n            up = 1 if (Algebra.angle(self.base_y_target, self.up) &lt; 90) else -1\n            self.rotate(direction=self.up*up /self.zoom.value, angle= message.du*100)\n            self.rotate(direction=self.base_x/self.zoom.value, angle=-message.dv*100)\n\n    # Wheel Scroll Zoom\n    elif isinstance(message, ShaderMessage.Mouse.Scroll):\n        self.apply_zoom(0.05*message.dy)\n\n    # Camera alignments and modes\n    elif isinstance(message, ShaderMessage.Keyboard.Press) and (message.action == 1):\n\n        # Switch camera modes\n        for _ in range(1):\n            if (message.key == ShaderKeyboard.Keys.NUMBER_1):\n                self.mode = CameraMode.FreeCamera\n            elif (message.key == ShaderKeyboard.Keys.NUMBER_2):\n                self.align(self.base_x_target, GlobalBasis.X)\n                self.align(self.base_y_target, GlobalBasis.Y)\n                self.mode = CameraMode.Camera2D\n                self.position.target[2] = 0\n                self.isometric.target = 0\n                self.zoom.target = 1\n            elif (message.key == ShaderKeyboard.Keys.NUMBER_3):\n                self.mode = CameraMode.Spherical\n            else: break\n        else:\n            log.info(f\"{self.who} \u2022 Set mode to {self.mode}\")\n\n        # What is \"UP\", baby don't hurt me\n        for _ in range(1):\n            if (message.key == ShaderKeyboard.Keys.I):\n                self.up.target = GlobalBasis.X\n            elif (message.key == ShaderKeyboard.Keys.J):\n                self.up.target = GlobalBasis.Y\n            elif (message.key == ShaderKeyboard.Keys.K):\n                self.up.target = GlobalBasis.Z\n            else: break\n        else:\n            log.info(f\"{self.who} \u2022 Set up to {self.up.target}\")\n            self.align(self.base_z_target, self.up.target)\n            self.align(self.base_y_target, self.up.target, 90)\n            self.align(self.base_x_target, self.up.target, 90)\n\n        # Switch Projection\n        if (message.key == ShaderKeyboard.Keys.P):\n            self.projection = next(self.projection)\n            log.info(f\"{self.who} \u2022 Set projection to {self.projection}\")\n</code></pre>"},{"location":"shaderflow/reference/modules/depth/","title":"Depth","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/depth/#Modules.Depth","title":"<code>Modules.Depth</code>","text":""},{"location":"shaderflow/reference/modules/dynamics/","title":"Dynamics","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics","title":"<code>Modules.Dynamics</code>","text":""},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber","title":"<code>Modules.Dynamics.DynamicNumber</code>","text":"<p>Simulate on time domain a progressive second order system</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber--sources","title":"Sources:","text":"<ul> <li>https://www.youtube.com/watch?v=KPoeNZZ6H4s &lt;- Math mostly took from here, thanks @t3ssel8r</li> <li>https://en.wikipedia.org/wiki/Semi-implicit_Euler_method</li> <li>Control System classes on my university which I got 6/10 final grade</li> </ul> <p>This is a Python-port of the video's math, with custom implementation and extras</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>@define(slots=False)\nclass DynamicNumber(Number):\n    \"\"\"\n    Simulate on time domain a progressive second order system\n\n    # Sources:\n    - https://www.youtube.com/watch?v=KPoeNZZ6H4s &lt;- Math mostly took from here, thanks @t3ssel8r\n    - https://en.wikipedia.org/wiki/Semi-implicit_Euler_method\n    - Control System classes on my university which I got 6/10 final grade\n\n    This is a Python-port of the video's math, with custom implementation and extras\n    \"\"\"\n\n    def _convert(self, value):\n        return numpy.array(value, dtype=getattr(value, \"dtype\", self.dtype))\n\n    def _set_target(self, attribute, value):\n        target = self._convert(value)\n        if (target.shape != self.value.shape):\n            self.initial = deepcopy(target)\n            self.value = deepcopy(target)\n        return target\n\n    value: Union[numpy.dtype, numpy.ndarray] = field(default=0)\n    \"\"\"The current value of the system. Prefer explicitly using it over the object itself\"\"\"\n\n    target: Union[numpy.dtype, numpy.ndarray] = field(default=None, on_setattr=_set_target)\n    \"\"\"The target value the system is trying to reach, modeled by the parameters\"\"\"\n\n    dtype: numpy.dtype = field(default=numpy.float32)\n    \"\"\"Data type of the NumPy vectorized data\"\"\"\n\n    initial: Union[numpy.dtype, numpy.ndarray] = field(default=None)\n    \"\"\"Initial value of the system, defaults to first value set\"\"\"\n\n    def __attrs_post_init__(self):\n        self.value   = self._convert(self.value)\n        self.target  = self._convert(self.target if (self.target is not None) else self.value)\n        self.initial = deepcopy(self.value)\n\n    frequency: float = 1.0\n    \"\"\"Natural frequency of the system in Hertz, \"the speed the system responds to a change in input\".\n    Also, the frequency it tends to vibrate at, doesn't affect shape of the resulting motion\"\"\"\n\n    zeta: float = 1.0\n    \"\"\"Damping coefficient, z=0 vibration never dies, z=1 is the critical limit where the system\n    does not overshoot, z&gt;1 increases this effect and the system takes longer to settle\"\"\"\n\n    response:  float = 0.0\n    \"\"\"Defines the initial response \"time\" of the system, when r=1 the system responds instantly\n    to changes on the input, when r=0 the system takes a bit to respond (smoothstep like), when r&lt;0\n    the system \"anticipates\" motion\"\"\"\n\n    precision: float = 1e-6\n    \"\"\"If |target - value| &lt; precision, the system stops updating to save computation\"\"\"\n\n    integral: float = 0.0\n    \"\"\"Integral of the system, the sum of all values over time\"\"\"\n\n    derivative: float = 0.0\n    \"\"\"Derivative of the system, the rate of change of the value in ($unit/second)\"\"\"\n\n    acceleration: float = 0.0\n    \"\"\"Acceleration of the system, the rate of change of the derivative in ($unit/second^2)\"\"\"\n\n    instant: bool = False\n    \"\"\"Update the system immediately to the target value, \"\"\"\n\n    @property\n    def k1(self) -&gt; float:\n        \"\"\"Y velocity coefficient\"\"\"\n        return self.zeta/(pi * self.frequency)\n\n    @property\n    def k2(self) -&gt; float:\n        \"\"\"Y acceleration coefficient\"\"\"\n        return 1/(self.radians*self.radians)\n\n    @property\n    def k3(self) -&gt; float:\n        \"\"\"X velocity coefficient\"\"\"\n        return (self.response * self.zeta) / (tau * self.frequency)\n\n    @property\n    def radians(self) -&gt; float:\n        \"\"\"Natural resonance frequency in radians per second\"\"\"\n        return tau * self.frequency\n\n    @property\n    def damping(self) -&gt; float:\n        \"\"\"Damping ratio of some sort\"\"\"\n        return self.radians * (abs(self.zeta*self.zeta - 1.0))**0.5\n\n    previous: float = 0\n    \"\"\"Previous target value\"\"\"\n\n    def next(self, target: Number=None, dt: float=1.0) -&gt; Number:\n        \"\"\"\n        Update the system to the next time step, optionally with a new target value\n        # Fixme: There is a HUGE potential for speed gains if we don't create many temporary ndarray\n\n        Args:\n            target: Next target value to reach, None for previous\n            dt:     Time delta since last update\n\n        Returns:\n            The system's self.value\n        \"\"\"\n        if not dt:\n            return self.value\n\n        # Update target\n        if (target is not None):\n            self.target = target\n\n        # Instant mode\n        if self.instant:\n            self.value = self.target*1\n            self.integral += self.value * dt\n            self.derivative = 0\n            self.acceleration = 0\n            return self.value\n\n        # Optimization: Do not compute if value within precision to target\n        if abs(numpy.sum(self.target - self.value)) &lt; self.precision:\n            self.integral += self.value * dt\n            return self.value\n\n        # \"Estimate velocity\"\n        velocity = (self.target - self.previous)/dt\n        self.previous = self.target\n\n        # \"Clamp k2 to stable values without jitter\"\n        if (self.radians*dt &lt; self.zeta):\n            k2 = max(self.k1*dt, self.k2, 0.5*(self.k1+dt)*dt)\n            k1 = self.k1\n\n        # \"Use pole matching when the system is very fast\"\n        else:\n            t1 = math.exp(-1 * self.zeta * self.radians * dt)\n            a1 = 2 * t1 * (math.cos if self.zeta &lt;= 1 else math.cosh)(self.damping*dt)\n            t2 = 1/(1 + t1*t1 - a1) * dt\n            k1 = t2 * (1 - t1*t1)\n            k2 = t2 * dt\n\n        # Integrate values\n        self.value       += (self.derivative * dt)\n        self.acceleration = (self.target + self.k3*velocity - self.value - k1*self.derivative)/k2\n        self.derivative  += (self.acceleration * dt)\n        self.integral    += (self.value * dt)\n        return self.value\n\n    def set(self, value: Number):\n        \"\"\"Force the system to a new value\"\"\"\n        self.target = deepcopy(value)\n        self.value = deepcopy(value)\n\n    def reset(self, instant: bool=False):\n        \"\"\"Reset the system to its initial state\"\"\"\n        self.target = deepcopy(self.initial)\n        if instant:\n            self.value = deepcopy(self.initial)\n        self.integral = 0\n        self.derivative = 0\n        self.acceleration = 0\n        self.previous = 0\n\n    @staticmethod\n    def extract(*objects: Union[Number, Self]) -&gt; Tuple[Number]:\n        \"\"\"Extract the values from DynamicNumbers objects or return the same object\"\"\"\n        return tuple(obj.value if isinstance(obj, DynamicNumber) else obj for obj in objects)\n\n    # # Number implementation\n\n    def __str__(self) -&gt; str:\n        return str(self.value)\n\n    def __float__(self) -&gt; float:\n        return self.value\n\n    def __int__(self) -&gt; int:\n        return int(self.value)\n\n    def __mul__(self, other) -&gt; Number:\n        return self.value * other\n\n    def __rmul__(self, other) -&gt; Self:\n        return self * other\n\n    def __add__(self, other) -&gt; Self:\n        return self.value + other\n\n    def __radd__(self, other) -&gt; Self:\n        return self + other\n\n    def __sub__(self, other) -&gt; Self:\n        return self.value - other\n\n    def __rsub__(self, other) -&gt; Self:\n        return self - other\n\n    def __truediv__(self, other) -&gt; Self:\n        return self.value / other\n\n    def __rtruediv__(self, other) -&gt; Self:\n        return self / other\n\n    def __floordiv__(self, other) -&gt; Self:\n        return self.value // other\n\n    def __rfloordiv__(self, other) -&gt; Self:\n        return self // other\n\n    def __mod__(self, other) -&gt; Self:\n        return self.value % other\n\n    def __rmod__(self, other) -&gt; Self:\n        return self % other\n\n    def __pow__(self, other) -&gt; Self:\n        return self.value ** other\n\n    def __rpow__(self, other) -&gt; Self:\n        return self ** other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.value","title":"<code>value: Union[numpy.dtype, numpy.ndarray] = field(default=0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The current value of the system. Prefer explicitly using it over the object itself</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.target","title":"<code>target: Union[numpy.dtype, numpy.ndarray] = field(default=None, on_setattr=_set_target)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The target value the system is trying to reach, modeled by the parameters</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.dtype","title":"<code>dtype: numpy.dtype = field(default=numpy.float32)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Data type of the NumPy vectorized data</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.initial","title":"<code>initial: Union[numpy.dtype, numpy.ndarray] = field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Initial value of the system, defaults to first value set</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __attrs_post_init__(self):\n    self.value   = self._convert(self.value)\n    self.target  = self._convert(self.target if (self.target is not None) else self.value)\n    self.initial = deepcopy(self.value)\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.frequency","title":"<code>frequency: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Natural frequency of the system in Hertz, \"the speed the system responds to a change in input\". Also, the frequency it tends to vibrate at, doesn't affect shape of the resulting motion</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.zeta","title":"<code>zeta: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Damping coefficient, z=0 vibration never dies, z=1 is the critical limit where the system does not overshoot, z&gt;1 increases this effect and the system takes longer to settle</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.response","title":"<code>response: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Defines the initial response \"time\" of the system, when r=1 the system responds instantly to changes on the input, when r=0 the system takes a bit to respond (smoothstep like), when r&lt;0 the system \"anticipates\" motion</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.precision","title":"<code>precision: float = 1e-06</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If |target - value| &lt; precision, the system stops updating to save computation</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.integral","title":"<code>integral: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Integral of the system, the sum of all values over time</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.derivative","title":"<code>derivative: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Derivative of the system, the rate of change of the value in ($unit/second)</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.acceleration","title":"<code>acceleration: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Acceleration of the system, the rate of change of the derivative in ($unit/second^2)</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.instant","title":"<code>instant: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Update the system immediately to the target value,</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.k1","title":"<code>k1: float</code>  <code>property</code>","text":"<p>Y velocity coefficient</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.k2","title":"<code>k2: float</code>  <code>property</code>","text":"<p>Y acceleration coefficient</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.k3","title":"<code>k3: float</code>  <code>property</code>","text":"<p>X velocity coefficient</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.radians","title":"<code>radians: float</code>  <code>property</code>","text":"<p>Natural resonance frequency in radians per second</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.damping","title":"<code>damping: float</code>  <code>property</code>","text":"<p>Damping ratio of some sort</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.previous","title":"<code>previous: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Previous target value</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.next","title":"<code>next(target: Number = None, dt: float = 1.0) -&gt; Number</code>","text":"<p>Update the system to the next time step, optionally with a new target value</p>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.next--fixme-there-is-a-huge-potential-for-speed-gains-if-we-dont-create-many-temporary-ndarray","title":"Fixme: There is a HUGE potential for speed gains if we don't create many temporary ndarray","text":"<p>Parameters:</p> <ul> <li> <code>target</code>             (<code>Number</code>, default:                 <code>None</code> )         \u2013          <p>Next target value to reach, None for previous</p> </li> <li> <code>dt</code>             (<code>float</code>, default:                 <code>1.0</code> )         \u2013          <p>Time delta since last update</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Number</code>         \u2013          <p>The system's self.value</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def next(self, target: Number=None, dt: float=1.0) -&gt; Number:\n    \"\"\"\n    Update the system to the next time step, optionally with a new target value\n    # Fixme: There is a HUGE potential for speed gains if we don't create many temporary ndarray\n\n    Args:\n        target: Next target value to reach, None for previous\n        dt:     Time delta since last update\n\n    Returns:\n        The system's self.value\n    \"\"\"\n    if not dt:\n        return self.value\n\n    # Update target\n    if (target is not None):\n        self.target = target\n\n    # Instant mode\n    if self.instant:\n        self.value = self.target*1\n        self.integral += self.value * dt\n        self.derivative = 0\n        self.acceleration = 0\n        return self.value\n\n    # Optimization: Do not compute if value within precision to target\n    if abs(numpy.sum(self.target - self.value)) &lt; self.precision:\n        self.integral += self.value * dt\n        return self.value\n\n    # \"Estimate velocity\"\n    velocity = (self.target - self.previous)/dt\n    self.previous = self.target\n\n    # \"Clamp k2 to stable values without jitter\"\n    if (self.radians*dt &lt; self.zeta):\n        k2 = max(self.k1*dt, self.k2, 0.5*(self.k1+dt)*dt)\n        k1 = self.k1\n\n    # \"Use pole matching when the system is very fast\"\n    else:\n        t1 = math.exp(-1 * self.zeta * self.radians * dt)\n        a1 = 2 * t1 * (math.cos if self.zeta &lt;= 1 else math.cosh)(self.damping*dt)\n        t2 = 1/(1 + t1*t1 - a1) * dt\n        k1 = t2 * (1 - t1*t1)\n        k2 = t2 * dt\n\n    # Integrate values\n    self.value       += (self.derivative * dt)\n    self.acceleration = (self.target + self.k3*velocity - self.value - k1*self.derivative)/k2\n    self.derivative  += (self.acceleration * dt)\n    self.integral    += (self.value * dt)\n    return self.value\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.set","title":"<code>set(value: Number)</code>","text":"<p>Force the system to a new value</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def set(self, value: Number):\n    \"\"\"Force the system to a new value\"\"\"\n    self.target = deepcopy(value)\n    self.value = deepcopy(value)\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.reset","title":"<code>reset(instant: bool = False)</code>","text":"<p>Reset the system to its initial state</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def reset(self, instant: bool=False):\n    \"\"\"Reset the system to its initial state\"\"\"\n    self.target = deepcopy(self.initial)\n    if instant:\n        self.value = deepcopy(self.initial)\n    self.integral = 0\n    self.derivative = 0\n    self.acceleration = 0\n    self.previous = 0\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.extract","title":"<code>extract(*objects: Union[Number, Self]) -&gt; Tuple[Number]</code>  <code>staticmethod</code>","text":"<p>Extract the values from DynamicNumbers objects or return the same object</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>@staticmethod\ndef extract(*objects: Union[Number, Self]) -&gt; Tuple[Number]:\n    \"\"\"Extract the values from DynamicNumbers objects or return the same object\"\"\"\n    return tuple(obj.value if isinstance(obj, DynamicNumber) else obj for obj in objects)\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__str__","title":"<code>__str__() -&gt; str</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __str__(self) -&gt; str:\n    return str(self.value)\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__float__","title":"<code>__float__() -&gt; float</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __float__(self) -&gt; float:\n    return self.value\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__int__","title":"<code>__int__() -&gt; int</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __int__(self) -&gt; int:\n    return int(self.value)\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__mul__","title":"<code>__mul__(other) -&gt; Number</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __mul__(self, other) -&gt; Number:\n    return self.value * other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__rmul__","title":"<code>__rmul__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __rmul__(self, other) -&gt; Self:\n    return self * other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__add__","title":"<code>__add__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __add__(self, other) -&gt; Self:\n    return self.value + other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__radd__","title":"<code>__radd__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __radd__(self, other) -&gt; Self:\n    return self + other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__sub__","title":"<code>__sub__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __sub__(self, other) -&gt; Self:\n    return self.value - other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__rsub__","title":"<code>__rsub__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __rsub__(self, other) -&gt; Self:\n    return self - other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__truediv__","title":"<code>__truediv__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __truediv__(self, other) -&gt; Self:\n    return self.value / other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__rtruediv__","title":"<code>__rtruediv__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __rtruediv__(self, other) -&gt; Self:\n    return self / other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__floordiv__","title":"<code>__floordiv__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __floordiv__(self, other) -&gt; Self:\n    return self.value // other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__rfloordiv__","title":"<code>__rfloordiv__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __rfloordiv__(self, other) -&gt; Self:\n    return self // other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__mod__","title":"<code>__mod__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __mod__(self, other) -&gt; Self:\n    return self.value % other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__rmod__","title":"<code>__rmod__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __rmod__(self, other) -&gt; Self:\n    return self % other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__pow__","title":"<code>__pow__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __pow__(self, other) -&gt; Self:\n    return self.value ** other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.DynamicNumber.__rpow__","title":"<code>__rpow__(other) -&gt; Self</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __rpow__(self, other) -&gt; Self:\n    return self ** other\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.ShaderDynamics","title":"<code>Modules.Dynamics.ShaderDynamics</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>@define\nclass ShaderDynamics(ShaderModule, DynamicNumber):\n    name: str  = \"iShaderDynamics\"\n    real: bool = False\n\n    def __post__(self):\n        DynamicNumber.__attrs_post_init__(self)\n\n    def setup(self):\n        self.reset(instant=self.scene.rendering)\n\n    def update(self):\n        # Note: |dt| as backwards in time the system is unstable\n        dt = abs(self.scene.rdt if self.real else self.scene.dt)\n        self.next(dt=dt)\n\n    @property\n    def type(self) -&gt; Optional[str]:\n\n        if isinstance(self.value, int):\n            return \"int\"\n\n        elif isinstance(self.value, float):\n            return \"float\"\n\n        shape = self.value.shape\n\n        if len(shape) == 0:\n            return \"float\"\n\n        return {\n            2: \"vec2\",\n            3: \"vec3\",\n            4: \"vec4\",\n        }.get(shape[0], None)\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        if not self.type:\n            return\n        yield ShaderVariable(\"uniform\", self.type, f\"{self.name}\", self.value)\n        yield ShaderVariable(\"uniform\", self.type, f\"{self.name}Integral\", self.integral)\n        yield ShaderVariable(\"uniform\", self.type, f\"{self.name}Derivative\", self.derivative)\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.ShaderDynamics.name","title":"<code>name: str = 'iShaderDynamics'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.ShaderDynamics.real","title":"<code>real: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.ShaderDynamics.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def __post__(self):\n    DynamicNumber.__attrs_post_init__(self)\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.ShaderDynamics.setup","title":"<code>setup()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def setup(self):\n    self.reset(instant=self.scene.rendering)\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.ShaderDynamics.update","title":"<code>update()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def update(self):\n    # Note: |dt| as backwards in time the system is unstable\n    dt = abs(self.scene.rdt if self.real else self.scene.dt)\n    self.next(dt=dt)\n</code></pre>"},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.ShaderDynamics.type","title":"<code>type: Optional[str]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/dynamics/#Modules.Dynamics.ShaderDynamics.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Dynamics.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    if not self.type:\n        return\n    yield ShaderVariable(\"uniform\", self.type, f\"{self.name}\", self.value)\n    yield ShaderVariable(\"uniform\", self.type, f\"{self.name}Integral\", self.integral)\n    yield ShaderVariable(\"uniform\", self.type, f\"{self.name}Derivative\", self.derivative)\n</code></pre>"},{"location":"shaderflow/reference/modules/frametimer/","title":"Frametimer","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer","title":"<code>Modules.Frametimer</code>","text":""},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer","title":"<code>Modules.Frametimer.ShaderFrametimer</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Frametimer.py</code> Python<pre><code>@define\nclass ShaderFrametimer(ShaderModule):\n    frametimes: Deque[float] = Factory(deque)\n    history: float = 2\n\n    @property\n    def length(self) -&gt; int:\n        return max(int(self.history * self.scene.fps), 10)\n\n    # Framerate manipulation\n\n    def update(self):\n        self.frametimes.append(self.scene.rdt)\n        while len(self.frametimes) &gt; self.length:\n            self.frametimes.popleft()\n\n    def percent(self, percent: float=1) -&gt; float:\n        cut = int(len(self.frametimes) * (percent/100))\n        return numpy.sort(self.frametimes)[-cut:]\n\n    def __safe__(self, value):\n        return value if value &lt; 1e8 else 0\n\n    # # Frametimes\n\n    def frametime_average(self, percent: float=100) -&gt; float:\n        frametimes = self.percent(percent)\n        return sum(frametimes) / (len(frametimes) + 1e-9)\n\n    @property\n    def frametime_maximum(self) -&gt; float:\n        return max(self.frametimes)\n\n    @property\n    def frametime_minimum(self) -&gt; float:\n        return min(self.frametimes)\n\n    # # Framerates\n\n    def framerate_average(self, percent: float=100) -&gt; float:\n        return self.__safe__(1.0 / (self.frametime_average(percent) + 1e-9))\n\n    @property\n    def framerate_maximum(self) -&gt; float:\n        return self.__safe__(1.0 / (self.frametime_minimum + 1e-9))\n\n    @property\n    def framerate_minimum(self) -&gt; float:\n        return self.__safe__(1.0 / (self.frametime_maximum + 1e-9))\n\n    # ShaderFlow\n\n    def ui(self):\n        imgui.plot_lines(\n            (\n                f\"Target  {self.scene.fps:7.3f} fps\\n\"\n                f\"Average {self.framerate_average(100):7.3f} fps\\n\"\n                # f\"Low 10% {self.framerate_average(10):7.3f} fps\\n\"\n                # f\"Low  1% {self.framerate_average(1):7.3f} fps\\n\"\n                f\"Maximum {self.framerate_maximum:7.3f} fps\\n\"\n                f\"Minimum {self.framerate_minimum:7.3f} fps\\n\"\n            ),\n            numpy.array(self.frametimes, dtype=numpy.float32),\n            scale_min = 0,\n            graph_size = (0, 70)\n        )\n\n        if (state := imgui.input_float(\"History (Seconds)\", self.history, 0.5, 0.5, \"%.2f\"))[0]:\n            self.history = max(0, state[1])\n</code></pre>"},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.frametimes","title":"<code>frametimes: Deque[float] = Factory(deque)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.history","title":"<code>history: float = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.length","title":"<code>length: int</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.update","title":"<code>update()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Frametimer.py</code> Python<pre><code>def update(self):\n    self.frametimes.append(self.scene.rdt)\n    while len(self.frametimes) &gt; self.length:\n        self.frametimes.popleft()\n</code></pre>"},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.percent","title":"<code>percent(percent: float = 1) -&gt; float</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Frametimer.py</code> Python<pre><code>def percent(self, percent: float=1) -&gt; float:\n    cut = int(len(self.frametimes) * (percent/100))\n    return numpy.sort(self.frametimes)[-cut:]\n</code></pre>"},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.__safe__","title":"<code>__safe__(value)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Frametimer.py</code> Python<pre><code>def __safe__(self, value):\n    return value if value &lt; 1e8 else 0\n</code></pre>"},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.frametime_average","title":"<code>frametime_average(percent: float = 100) -&gt; float</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Frametimer.py</code> Python<pre><code>def frametime_average(self, percent: float=100) -&gt; float:\n    frametimes = self.percent(percent)\n    return sum(frametimes) / (len(frametimes) + 1e-9)\n</code></pre>"},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.frametime_maximum","title":"<code>frametime_maximum: float</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.frametime_minimum","title":"<code>frametime_minimum: float</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.framerate_average","title":"<code>framerate_average(percent: float = 100) -&gt; float</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Frametimer.py</code> Python<pre><code>def framerate_average(self, percent: float=100) -&gt; float:\n    return self.__safe__(1.0 / (self.frametime_average(percent) + 1e-9))\n</code></pre>"},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.framerate_maximum","title":"<code>framerate_maximum: float</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.framerate_minimum","title":"<code>framerate_minimum: float</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/frametimer/#Modules.Frametimer.ShaderFrametimer.ui","title":"<code>ui()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Frametimer.py</code> Python<pre><code>def ui(self):\n    imgui.plot_lines(\n        (\n            f\"Target  {self.scene.fps:7.3f} fps\\n\"\n            f\"Average {self.framerate_average(100):7.3f} fps\\n\"\n            # f\"Low 10% {self.framerate_average(10):7.3f} fps\\n\"\n            # f\"Low  1% {self.framerate_average(1):7.3f} fps\\n\"\n            f\"Maximum {self.framerate_maximum:7.3f} fps\\n\"\n            f\"Minimum {self.framerate_minimum:7.3f} fps\\n\"\n        ),\n        numpy.array(self.frametimes, dtype=numpy.float32),\n        scale_min = 0,\n        graph_size = (0, 70)\n    )\n\n    if (state := imgui.input_float(\"History (Seconds)\", self.history, 0.5, 0.5, \"%.2f\"))[0]:\n        self.history = max(0, state[1])\n</code></pre>"},{"location":"shaderflow/reference/modules/keyboard/","title":"Keyboard","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard","title":"<code>Modules.Keyboard</code>","text":""},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard.__camel__","title":"<code>Modules.Keyboard.__camel__(name: str) -&gt; str</code>  <code>cached</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Keyboard.py</code> Python<pre><code>@functools.lru_cache(maxsize=None)\ndef __camel__(name: str) -&gt; str:\n    # Convert stuff like (NUMPAD_9 -&gt; Numpad9) and (Home -&gt; Home)\n    return \"\".join([word.capitalize() for word in name.split(\"_\")])\n</code></pre>"},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard.ShaderKeyboard","title":"<code>Modules.Keyboard.ShaderKeyboard</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Keyboard.py</code> Python<pre><code>@define\nclass ShaderKeyboard(ShaderModule):\n    Keys    = None\n    DirKeys = None\n\n    _pressed: Dict[int, bool] = Factory(dict)\n\n    @staticmethod\n    def set_keymap(keymap: ModernglKeys) -&gt; None:\n        ShaderKeyboard.DirKeys = {key: getattr(keymap, key) for key in dir(keymap) if not key.startswith(\"_\")}\n        ShaderKeyboard.Keys = keymap\n\n    def pressed(self, key: Union[int, ModernglKeys]=None) -&gt; bool:\n        return self._pressed.setdefault(key, False)\n\n    def __call__(self, *a, **k) -&gt; bool:\n        return self.pressed(*a, **k)\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        return\n        for name, key in ShaderKeyboard.DirKeys.items():\n            yield ShaderVariable(\"uniform\", \"bool\", f\"iKey{__camel__(name)}\", self._pressed.setdefault(key, False))\n\n    def handle(self, message: ShaderMessage):\n        if isinstance(message, ShaderMessage.Keyboard.Press):\n            self._pressed[message.key] = (message.action != ShaderKeyboard.Keys.ACTION_RELEASE)\n</code></pre>"},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard.ShaderKeyboard.Keys","title":"<code>Keys = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard.ShaderKeyboard.DirKeys","title":"<code>DirKeys = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard.ShaderKeyboard.set_keymap","title":"<code>set_keymap(keymap: ModernglKeys) -&gt; None</code>  <code>staticmethod</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Keyboard.py</code> Python<pre><code>@staticmethod\ndef set_keymap(keymap: ModernglKeys) -&gt; None:\n    ShaderKeyboard.DirKeys = {key: getattr(keymap, key) for key in dir(keymap) if not key.startswith(\"_\")}\n    ShaderKeyboard.Keys = keymap\n</code></pre>"},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard.ShaderKeyboard.pressed","title":"<code>pressed(key: Union[int, ModernglKeys] = None) -&gt; bool</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Keyboard.py</code> Python<pre><code>def pressed(self, key: Union[int, ModernglKeys]=None) -&gt; bool:\n    return self._pressed.setdefault(key, False)\n</code></pre>"},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard.ShaderKeyboard.__call__","title":"<code>__call__(*a, **k) -&gt; bool</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Keyboard.py</code> Python<pre><code>def __call__(self, *a, **k) -&gt; bool:\n    return self.pressed(*a, **k)\n</code></pre>"},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard.ShaderKeyboard.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Keyboard.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    return\n    for name, key in ShaderKeyboard.DirKeys.items():\n        yield ShaderVariable(\"uniform\", \"bool\", f\"iKey{__camel__(name)}\", self._pressed.setdefault(key, False))\n</code></pre>"},{"location":"shaderflow/reference/modules/keyboard/#Modules.Keyboard.ShaderKeyboard.handle","title":"<code>handle(message: ShaderMessage)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Keyboard.py</code> Python<pre><code>def handle(self, message: ShaderMessage):\n    if isinstance(message, ShaderMessage.Keyboard.Press):\n        self._pressed[message.key] = (message.action != ShaderKeyboard.Keys.ACTION_RELEASE)\n</code></pre>"},{"location":"shaderflow/reference/modules/noise/","title":"Noise","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/noise/#Modules.Noise","title":"<code>Modules.Noise</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise","title":"<code>Modules.Noise.ShaderNoise</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Noise.py</code> Python<pre><code>@define\nclass ShaderNoise(ShaderModule):\n    name: str = \"Noise\"\n    seed: int = Factory(functools.partial(random.randint, 0, 10000))\n\n    # TODO: Convert these to BrokenSecondOrderShaderDynamics?\n\n    # Maximum amplitude (roughly)\n    amplitude: float = 1\n    frequency: float = 1\n    octaves:   int   = 1\n    roughness: float = 1\n\n    # # Number of dimensions for this noise\n\n    __dimensions__: int = 1\n\n    @property\n    def dimensions(self):\n        return self.__dimensions__\n\n    @dimensions.setter\n    def dimensions(self, value):\n        self.__dimensions__ = value\n        self.__simplex__ = [\n            opensimplex.OpenSimplex(seed=self.seed + dimension*1000)\n            for dimension in range(self.dimensions)\n        ]\n\n    @property\n    def type(self) -&gt; str:\n        return {\n            1: \"float\",\n            2: \"vec2\",\n            3: \"vec3\",\n        }[self.dimensions]\n\n    # Noise generator\n    __simplex__: opensimplex.OpenSimplex = None\n\n    def __init__(self, dimensions: int=1, *args, **kwargs):\n        self.__attrs_init__(*args, **kwargs)\n        self.dimensions = dimensions\n\n    def at(self, x: float=0, y: float=0, z: float=0) -&gt; float:\n        \"\"\"Internal function to return a noise value for three dimensions\"\"\"\n        noise = numpy.zeros(self.dimensions, dtype=numpy.float32)\n\n        for dimension in range(self.dimensions):\n            for octave in range(self.octaves):\n\n                # The \"position velocity\" due frequency of this octave\n                # \u00b7 One octave up, double the frequency\n                # \u00b7 Scale linearly with self.frequency\n                k = (2**octave) * self.frequency\n\n                # Amplitude of this octave so noise remains bounded\n                # \u00b7 Double the octave, half the amplitude\n                amplitude = self.amplitude * (self.roughness)**octave\n\n                # Sum this octave's noise to the total\n                # Fixme: x=0, y=0, z=0 yields the same noise for all octaves\n                noise[dimension] += self.__simplex__[dimension].noise3(x*k, y*k, z*k) * amplitude\n\n        return noise\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        yield ShaderVariable(\"uniform\", self.type, f\"i{self.name}\", self.at(self.scene.time))\n</code></pre>"},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.name","title":"<code>name: str = 'Noise'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.seed","title":"<code>seed: int = Factory(functools.partial(random.randint, 0, 10000))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.amplitude","title":"<code>amplitude: float = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.frequency","title":"<code>frequency: float = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.octaves","title":"<code>octaves: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.roughness","title":"<code>roughness: float = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.__dimensions__","title":"<code>__dimensions__: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.type","title":"<code>type: str</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.__simplex__","title":"<code>__simplex__: opensimplex.OpenSimplex = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.__init__","title":"<code>__init__(dimensions: int = 1, *args, **kwargs)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Noise.py</code> Python<pre><code>def __init__(self, dimensions: int=1, *args, **kwargs):\n    self.__attrs_init__(*args, **kwargs)\n    self.dimensions = dimensions\n</code></pre>"},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.dimensions","title":"<code>dimensions = dimensions</code>  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":""},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.at","title":"<code>at(x: float = 0, y: float = 0, z: float = 0) -&gt; float</code>","text":"<p>Internal function to return a noise value for three dimensions</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Noise.py</code> Python<pre><code>def at(self, x: float=0, y: float=0, z: float=0) -&gt; float:\n    \"\"\"Internal function to return a noise value for three dimensions\"\"\"\n    noise = numpy.zeros(self.dimensions, dtype=numpy.float32)\n\n    for dimension in range(self.dimensions):\n        for octave in range(self.octaves):\n\n            # The \"position velocity\" due frequency of this octave\n            # \u00b7 One octave up, double the frequency\n            # \u00b7 Scale linearly with self.frequency\n            k = (2**octave) * self.frequency\n\n            # Amplitude of this octave so noise remains bounded\n            # \u00b7 Double the octave, half the amplitude\n            amplitude = self.amplitude * (self.roughness)**octave\n\n            # Sum this octave's noise to the total\n            # Fixme: x=0, y=0, z=0 yields the same noise for all octaves\n            noise[dimension] += self.__simplex__[dimension].noise3(x*k, y*k, z*k) * amplitude\n\n    return noise\n</code></pre>"},{"location":"shaderflow/reference/modules/noise/#Modules.Noise.ShaderNoise.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Noise.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    yield ShaderVariable(\"uniform\", self.type, f\"i{self.name}\", self.at(self.scene.time))\n</code></pre>"},{"location":"shaderflow/reference/modules/opticalflow/","title":"OpticalFlow","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/opticalflow/#Modules.OpticalFlow","title":"<code>Modules.OpticalFlow</code>","text":""},{"location":"shaderflow/reference/modules/piano/","title":"Piano","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano","title":"<code>Modules.Piano</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.MAX_CHANNELS","title":"<code>Modules.Piano.MAX_CHANNELS = 32</code>  <code>module-attribute</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.MAX_ROLLING","title":"<code>Modules.Piano.MAX_ROLLING = 256</code>  <code>module-attribute</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.MAX_NOTE","title":"<code>Modules.Piano.MAX_NOTE = 128</code>  <code>module-attribute</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano","title":"<code>Modules.Piano.ShaderPiano</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>@define\nclass ShaderPiano(ShaderModule):\n    name: str = \"iPiano\"\n    \"\"\"Texture name prefixes for this Module\"\"\"\n\n    tempo: Deque[Tuple[Seconds, BPM]] = Factory(deque)\n    \"\"\"List of tempo changes at (seconds, bpm)\"\"\"\n\n    keys_texture: ShaderTexture = None\n    \"\"\"Velocities texture, X is MIDI index, Y is Velocity, size (MAX_NOTE, 1)\"\"\"\n\n    channel_texture: ShaderTexture = None\n    \"\"\"Channel being played texture, X is MIDI index, Y is Channel, size (MAX_NOTE, 1)\"\"\"\n\n    roll_texture: ShaderTexture = None\n    \"\"\"Piano roll'ling notes main texture'. The X coordinate is the MIDI index, pixels contains data\n    (start, end, channel, velocity), of each playing key on the Y. Size (MAX_ROLLING, MAX_NOTE)\"\"\"\n\n    time_offset: Seconds = 0\n    \"\"\"Offset the notes being played search from the current time\"\"\"\n\n    roll_time: Seconds = 2\n    \"\"\"How long the notes are visible, 'roll for'\"\"\"\n\n    height: float = 0.275\n    \"\"\"Height of the piano in the shader (0-1)\"\"\"\n\n    black_ratio: float = 0.6\n    \"\"\"How long are black keys compared to white keys\"\"\"\n\n    global_minimum_note: int = MAX_NOTE\n    \"\"\"The lowest note in the loaded notes\"\"\"\n\n    global_maximum_note: int = 0\n    \"\"\"The highest note in the loaded notes\"\"\"\n\n    extra_side_keys: int = 6\n    \"\"\"Display the dynamic range plus this many keys on each side\"\"\"\n\n    future_range_lookup: Seconds = 2\n    \"\"\"Lookup notes in (roll_time + this) for setting the dynamic ranges\"\"\"\n\n    release_before_end: Seconds = 0.05\n    \"\"\"Workaround for the transition between close/glued to be perceived\"\"\"\n\n    key_press_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(\n        value=numpy.zeros(MAX_NOTE, numpy.float32),\n        frequency=4, zeta=0.4, response=0, precision=0\n    ))\n\n    note_range_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(\n        value=numpy.zeros(2, numpy.float32),\n        frequency=0.05, zeta=1/(2**0.5), response=0,\n    ))\n\n    tree: Dict[int, Dict[int, Deque[BrokenPianoNote]]] = Factory(dict)\n    \"\"\"Internal data structure for storing the notes\"\"\"\n\n    @property\n    def lookup_time(self) -&gt; Seconds:\n        \"\"\"The full lookup time we should care for future notes (rolling+future range)\"\"\"\n        return (self.roll_time + self.future_range_lookup)\n\n    # # Internal\n\n    def __post__(self):\n        self.keys_texture    = ShaderTexture(scene=self.scene, name=f\"{self.name}Keys\").from_numpy(self._empty_keys())\n        self.channel_texture = ShaderTexture(scene=self.scene, name=f\"{self.name}Chan\").from_numpy(self._empty_keys())\n        self.roll_texture    = ShaderTexture(scene=self.scene, name=f\"{self.name}Roll\").from_numpy(self._empty_roll())\n        self.tempo_texture   = ShaderTexture(scene=self.scene, name=f\"{self.name}Tempo\").from_numpy(numpy.zeros((100, 1, 2), numpy.float32))\n\n    def _empty_keys(self) -&gt; numpy.ndarray:\n        return numpy.zeros((MAX_NOTE, 1), numpy.float32)\n\n    def _empty_roll(self) -&gt; numpy.ndarray:\n        return numpy.zeros((MAX_NOTE, MAX_ROLLING, 4), numpy.float32)\n\n    # # Data structure\n\n    @staticmethod\n    def _ranges(start: Seconds, end: Seconds) -&gt; Iterable[int]:\n        return range(int(start), int(end)+1)\n\n    def clear(self):\n        self.tree.clear()\n\n    def add_note(self, note: Optional[BrokenPianoNote]) -&gt; None:\n        if note is None:\n            return\n        for index in self._ranges(note.start, note.end):\n            self.tree.setdefault(note.note, dict()).setdefault(index, deque()).append(note)\n        self.update_global_ranges(note.note)\n\n    @property\n    def notes(self) -&gt; Iterable[BrokenPianoNote]:\n        for block in self.tree.values():\n            for notes in block.values():\n                yield from notes\n\n    @property\n    def duration(self) -&gt; float:\n        return max((note.end for note in self.notes), default=0)\n\n    def __iter__(self) -&gt; Iterable[BrokenPianoNote]:\n        return self.notes\n\n    def notes_between(self, index: int, start: Seconds, end: Seconds) -&gt; Iterable[BrokenPianoNote]:\n        exists = set()\n        for other in self._ranges(start, end):\n            for note in self.tree.get(index, dict()).get(other, deque()):\n                if (note.start &gt; end):\n                    continue\n                if (id(note) in exists):\n                    continue\n                exists.add(id(note))\n                yield note\n\n    def update_global_ranges(self, note: int) -&gt; None:\n        self.global_minimum_note = min(self.global_minimum_note, note)\n        self.global_maximum_note = max(self.global_maximum_note, note)\n\n    @property\n    def maximum_velocity(self) -&gt; Optional[int]:\n        return max((note.velocity for note in self.notes), default=None)\n\n    @property\n    def minimum_velocity(self) -&gt; Optional[int]:\n        return min((note.velocity for note in self.notes), default=None)\n\n    def normalize_velocities(self, minimum: int=100, maximum: int=100) -&gt; None:\n        ma, mi = (self.maximum_velocity, self.minimum_velocity)\n\n        # Safe against (minimum-maximum=0)\n        def new(velocity: int) -&gt; int:\n            if (ma==mi): return (maximum+minimum)//2\n            return int((velocity-mi)/(ma-mi)*(maximum-minimum)+minimum)\n\n        for note in self.notes:\n            note.velocity = new(note.velocity)\n\n    def load_midi(self, path: Path):\n        import pretty_midi\n\n        if not (path := BrokenPath(path)).exists():\n            log.warning(f\"{self.who} Input Midi file not found ({path})\")\n            return\n\n        with BrokenSpinner(log.info(f\"Loading Midi file at ({path})\")):\n            midi = pretty_midi.PrettyMIDI(str(path))\n            for channel, instrument in enumerate(midi.instruments):\n                if instrument.is_drum:\n                    pass\n                for note in instrument.notes:\n                    self.add_note(BrokenPianoNote(\n                        note=note.pitch,\n                        start=note.start,\n                        end=note.end,\n                        channel=channel,\n                        velocity=note.velocity,\n                    ))\n            # Add tempo changes\n            for when, tempo in zip(*midi.get_tempo_changes()):\n                self.tempo.append((when, tempo))\n\n        self.tempo_texture.clear()\n\n        for offset, (when, tempo) in enumerate(self.tempo):\n            self.tempo_texture.write(data=struct.pack(\"ff\", when, tempo), viewport=(0, offset, 1, 1))\n\n    # # Core Logic\n\n    # A (MAX_MIDI Notes x MAX_CHANNELS Channels) matrix of the end-most note being played\n    _playing_matrix: List[List[Optional[BrokenPianoNote]]] = Factory(lambda: [[None]*MAX_CHANNELS for _ in range(MAX_NOTE)])\n\n    def update(self):\n\n        # Utilities and trackers\n        time = (self.scene.time + self.time_offset)\n        upcoming = set()\n\n        # # Get and update pressed keys\n        self.key_press_dynamics.target.fill(0)\n        roll = self._empty_roll()\n\n        # Channel '-1' means the note is not being played !\n        channels = (self._empty_keys() - 1)\n\n        # Optimization: No need to check for the entire range \ud83d\ude09\n        for midi in range(self.global_minimum_note, self.global_maximum_note+1):\n            simultaneous = 0\n\n            for note in self.notes_between(midi, time, time+self.lookup_time):\n                upcoming.add(midi)\n\n                # Ignore notes out of the viewport\n                if (note.start &gt;= time+self.roll_time):\n                    continue\n\n                # Build a 2D Grid of the piano keys being played\n                # \u2022 Coordinate: (Note, #offset) @ (Start, End, Channel, Velocity)\n                if (simultaneous &lt; MAX_ROLLING):\n                    roll[note.note, simultaneous] = (note.start, note.end, note.channel, note.velocity)\n                    simultaneous += 1\n\n                # Skip non-playing notes\n                if not (note.start &lt;= time &lt;= note.end):\n                    continue\n\n                # Workaround: Don't play the full note, so close notes velocities are perceived twice\n                _note_too_small = (note.end - note.start) &lt; self.release_before_end\n                _shorter_note = (time &lt; (note.end - self.release_before_end))\n\n                if (_shorter_note or _note_too_small):\n                    self.key_press_dynamics.target[midi] = note.velocity\n\n                # Either way, the channel must be colored\n                channels[midi] = note.channel\n\n                # Find empty slots or notes that will end soon, replace and play\n                other = self._playing_matrix[midi][note.channel]\n                if (other is None) or (other.end &gt; note.end):\n                    play_velocity = int(128*((note.velocity/128)**0.5))\n                    self.fluid_key_down(midi, play_velocity, note.channel)\n                    self._playing_matrix[midi][note.channel] = note\n\n            # Find notes that are not being played\n            for channel in range(MAX_CHANNELS * self.scene.realtime):\n                if (other := self._playing_matrix[midi][channel]) and (other.end &lt; time):\n                    self._playing_matrix[midi][channel] = None\n                    self.fluid_key_up(midi, other.channel)\n\n        # Dynamic zoom velocity based on future lookup\n        self.note_range_dynamics.frequency = 0.5/self.lookup_time\n\n        # Set dynamic note range to the globals on the start\n        if sum(self.note_range_dynamics.value) == 0:\n            self.note_range_dynamics.value[:] = (self.global_minimum_note, self.global_maximum_note)\n\n        # Set new targets for dynamic keys\n        self.note_range_dynamics.target[:] = (\n            min(upcoming, default=self.global_minimum_note),\n            max(upcoming, default=self.global_maximum_note)\n        )\n\n        # Write to keys textures\n        self.note_range_dynamics.next(dt=abs(self.scene.dt))\n        self.key_press_dynamics.next(dt=abs(self.scene.dt))\n        self.keys_texture.write(data=self.key_press_dynamics.value)\n        self.roll_texture.write(data=roll)\n        self.channel_texture.write(data=channels)\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}GlobalMin\",  self.global_minimum_note)\n        yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}GlobalMax\",  self.global_maximum_note)\n        yield ShaderVariable(\"uniform\", \"vec2\",  f\"{self.name}Dynamic\",    self.note_range_dynamics.value)\n        yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}RollTime\",   self.roll_time)\n        yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Extra\",      self.extra_side_keys)\n        yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Height\",     self.height)\n        yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Limit\",      MAX_ROLLING)\n        yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}BlackRatio\", self.black_ratio)\n\n    # # Fluidsynth\n\n    fluidsynth: Any = None\n    soundfont:  Any = None\n\n    def fluid_load(self, sf2: Path, driver: str=(\"pulseaudio\" if BrokenPlatform.OnLinux else None)) -&gt; None:\n        if not (sf2 := BrokenPath(sf2)).exists():\n            log.warning(f\"{self.who} Couldn't load SoundFont from path ({sf2}), will not have Real Time MIDI Audio\")\n            return\n\n        # Download FluidSynth for Windows\n        if BrokenPlatform.OnWindows:\n            FLUIDSYNTH = \"https://github.com/FluidSynth/fluidsynth/releases/download/v2.3.4/fluidsynth-2.3.4-win10-x64.zip\"\n            BrokenPath.add_to_path(BrokenPath.extract(BrokenPath.download(FLUIDSYNTH), BROKEN.DIRECTORIES.EXTERNALS), recurse=True)\n        elif BrokenPlatform.OnMacOS:\n            if not shutil.which(\"fluidsynth\"):\n                shell(\"brew\", \"install\", \"fluidsynth\")\n        elif BrokenPlatform.OnLinux:\n            log.minor(f\"{self.who} Please install FluidSynth in your Package Manager if needed\")\n\n        import fluidsynth\n        self.fluidsynth = fluidsynth.Synth()\n        with BrokenSpinner(log.info(f\"Loading FluidSynth SoundFont ({sf2.name})\")):\n            self.soundfont = self.fluidsynth.sfload(str(sf2))\n        self.fluidsynth.set_reverb(1, 1, 80, 1)\n        self.fluidsynth.start(driver=driver)\n        for channel in range(MAX_CHANNELS):\n            self.fluid_select(channel, 0, 0)\n\n    def fluid_select(self, channel: int=0, bank: int=0, preset: int=0) -&gt; None:\n        if self.fluidsynth:\n            self.fluidsynth.program_select(channel, self.soundfont, bank, preset)\n\n    def fluid_key_down(self, note: int, velocity: int=127, channel: int=0) -&gt; None:\n        if self.fluidsynth:\n            self.fluidsynth.noteon(channel, note, velocity)\n\n    def fluid_key_up(self, note: int, channel: int=0) -&gt; None:\n        if self.fluidsynth:\n            self.fluidsynth.noteoff(channel, note)\n\n    def fluid_all_notes_off(self) -&gt; None:\n        if self.fluidsynth:\n            for channel, note in itertools.product(range(MAX_CHANNELS), range(MAX_NOTE)):\n                self.fluidsynth.noteoff(channel, note)\n\n    def fluid_render(self,\n        midi: Path,\n        soundfont: Path=None,\n        output: Path=None\n    ) -&gt; Path:\n        if not self.fluidsynth:\n            return\n\n        # Get temporary cached file\n        if output is None:\n            midi_hash = hashlib.md5(BrokenPath(midi).read_bytes()).hexdigest()\n            output = Path(tempfile.gettempdir())/f\"ShaderFlow-Midi2Audio-{midi_hash}.wav\"\n\n        import midi2audio\n        with BrokenSpinner(log.info(f\"Rendering FluidSynth Midi ({midi}) \u2192 ({output})\")):\n            midi2audio.FluidSynth(soundfont).midi_to_audio(midi, output)\n\n        # Normalize audio with FFmpeg\n        normalized = output.with_suffix(\".aac\")\n        with BrokenSpinner(log.info(f\"Normalizing Audio ({output}) \u2192 ({normalized})\")):\n            (BrokenFFmpeg()\n                .quiet()\n                .overwrite()\n                .input(output)\n                .filter(\"loudnorm\")\n                .aac()\n                .output(normalized)\n            ).run()\n\n        return BrokenPath(normalized)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.name","title":"<code>name: str = 'iPiano'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Texture name prefixes for this Module</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.tempo","title":"<code>tempo: Deque[Tuple[Seconds, BPM]] = Factory(deque)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of tempo changes at (seconds, bpm)</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.keys_texture","title":"<code>keys_texture: ShaderTexture = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Velocities texture, X is MIDI index, Y is Velocity, size (MAX_NOTE, 1)</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.channel_texture","title":"<code>channel_texture: ShaderTexture = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Channel being played texture, X is MIDI index, Y is Channel, size (MAX_NOTE, 1)</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.roll_texture","title":"<code>roll_texture: ShaderTexture = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Piano roll'ling notes main texture'. The X coordinate is the MIDI index, pixels contains data (start, end, channel, velocity), of each playing key on the Y. Size (MAX_ROLLING, MAX_NOTE)</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.time_offset","title":"<code>time_offset: Seconds = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Offset the notes being played search from the current time</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.roll_time","title":"<code>roll_time: Seconds = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How long the notes are visible, 'roll for'</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.height","title":"<code>height: float = 0.275</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Height of the piano in the shader (0-1)</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.black_ratio","title":"<code>black_ratio: float = 0.6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How long are black keys compared to white keys</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.global_minimum_note","title":"<code>global_minimum_note: int = MAX_NOTE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The lowest note in the loaded notes</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.global_maximum_note","title":"<code>global_maximum_note: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The highest note in the loaded notes</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.extra_side_keys","title":"<code>extra_side_keys: int = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Display the dynamic range plus this many keys on each side</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.future_range_lookup","title":"<code>future_range_lookup: Seconds = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Lookup notes in (roll_time + this) for setting the dynamic ranges</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.release_before_end","title":"<code>release_before_end: Seconds = 0.05</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Workaround for the transition between close/glued to be perceived</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.key_press_dynamics","title":"<code>key_press_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(value=numpy.zeros(MAX_NOTE, numpy.float32), frequency=4, zeta=0.4, response=0, precision=0))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.note_range_dynamics","title":"<code>note_range_dynamics: DynamicNumber = Factory(lambda: DynamicNumber(value=numpy.zeros(2, numpy.float32), frequency=0.05, zeta=1 / 2 ** 0.5, response=0))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.tree","title":"<code>tree: Dict[int, Dict[int, Deque[BrokenPianoNote]]] = Factory(dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internal data structure for storing the notes</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.lookup_time","title":"<code>lookup_time: Seconds</code>  <code>property</code>","text":"<p>The full lookup time we should care for future notes (rolling+future range)</p>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def __post__(self):\n    self.keys_texture    = ShaderTexture(scene=self.scene, name=f\"{self.name}Keys\").from_numpy(self._empty_keys())\n    self.channel_texture = ShaderTexture(scene=self.scene, name=f\"{self.name}Chan\").from_numpy(self._empty_keys())\n    self.roll_texture    = ShaderTexture(scene=self.scene, name=f\"{self.name}Roll\").from_numpy(self._empty_roll())\n    self.tempo_texture   = ShaderTexture(scene=self.scene, name=f\"{self.name}Tempo\").from_numpy(numpy.zeros((100, 1, 2), numpy.float32))\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.clear","title":"<code>clear()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def clear(self):\n    self.tree.clear()\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.add_note","title":"<code>add_note(note: Optional[BrokenPianoNote]) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def add_note(self, note: Optional[BrokenPianoNote]) -&gt; None:\n    if note is None:\n        return\n    for index in self._ranges(note.start, note.end):\n        self.tree.setdefault(note.note, dict()).setdefault(index, deque()).append(note)\n    self.update_global_ranges(note.note)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.notes","title":"<code>notes: Iterable[BrokenPianoNote]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.duration","title":"<code>duration: float</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.__iter__","title":"<code>__iter__() -&gt; Iterable[BrokenPianoNote]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def __iter__(self) -&gt; Iterable[BrokenPianoNote]:\n    return self.notes\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.notes_between","title":"<code>notes_between(index: int, start: Seconds, end: Seconds) -&gt; Iterable[BrokenPianoNote]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def notes_between(self, index: int, start: Seconds, end: Seconds) -&gt; Iterable[BrokenPianoNote]:\n    exists = set()\n    for other in self._ranges(start, end):\n        for note in self.tree.get(index, dict()).get(other, deque()):\n            if (note.start &gt; end):\n                continue\n            if (id(note) in exists):\n                continue\n            exists.add(id(note))\n            yield note\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.update_global_ranges","title":"<code>update_global_ranges(note: int) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def update_global_ranges(self, note: int) -&gt; None:\n    self.global_minimum_note = min(self.global_minimum_note, note)\n    self.global_maximum_note = max(self.global_maximum_note, note)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.maximum_velocity","title":"<code>maximum_velocity: Optional[int]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.minimum_velocity","title":"<code>minimum_velocity: Optional[int]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.normalize_velocities","title":"<code>normalize_velocities(minimum: int = 100, maximum: int = 100) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def normalize_velocities(self, minimum: int=100, maximum: int=100) -&gt; None:\n    ma, mi = (self.maximum_velocity, self.minimum_velocity)\n\n    # Safe against (minimum-maximum=0)\n    def new(velocity: int) -&gt; int:\n        if (ma==mi): return (maximum+minimum)//2\n        return int((velocity-mi)/(ma-mi)*(maximum-minimum)+minimum)\n\n    for note in self.notes:\n        note.velocity = new(note.velocity)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.load_midi","title":"<code>load_midi(path: Path)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def load_midi(self, path: Path):\n    import pretty_midi\n\n    if not (path := BrokenPath(path)).exists():\n        log.warning(f\"{self.who} Input Midi file not found ({path})\")\n        return\n\n    with BrokenSpinner(log.info(f\"Loading Midi file at ({path})\")):\n        midi = pretty_midi.PrettyMIDI(str(path))\n        for channel, instrument in enumerate(midi.instruments):\n            if instrument.is_drum:\n                pass\n            for note in instrument.notes:\n                self.add_note(BrokenPianoNote(\n                    note=note.pitch,\n                    start=note.start,\n                    end=note.end,\n                    channel=channel,\n                    velocity=note.velocity,\n                ))\n        # Add tempo changes\n        for when, tempo in zip(*midi.get_tempo_changes()):\n            self.tempo.append((when, tempo))\n\n    self.tempo_texture.clear()\n\n    for offset, (when, tempo) in enumerate(self.tempo):\n        self.tempo_texture.write(data=struct.pack(\"ff\", when, tempo), viewport=(0, offset, 1, 1))\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.update","title":"<code>update()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def update(self):\n\n    # Utilities and trackers\n    time = (self.scene.time + self.time_offset)\n    upcoming = set()\n\n    # # Get and update pressed keys\n    self.key_press_dynamics.target.fill(0)\n    roll = self._empty_roll()\n\n    # Channel '-1' means the note is not being played !\n    channels = (self._empty_keys() - 1)\n\n    # Optimization: No need to check for the entire range \ud83d\ude09\n    for midi in range(self.global_minimum_note, self.global_maximum_note+1):\n        simultaneous = 0\n\n        for note in self.notes_between(midi, time, time+self.lookup_time):\n            upcoming.add(midi)\n\n            # Ignore notes out of the viewport\n            if (note.start &gt;= time+self.roll_time):\n                continue\n\n            # Build a 2D Grid of the piano keys being played\n            # \u2022 Coordinate: (Note, #offset) @ (Start, End, Channel, Velocity)\n            if (simultaneous &lt; MAX_ROLLING):\n                roll[note.note, simultaneous] = (note.start, note.end, note.channel, note.velocity)\n                simultaneous += 1\n\n            # Skip non-playing notes\n            if not (note.start &lt;= time &lt;= note.end):\n                continue\n\n            # Workaround: Don't play the full note, so close notes velocities are perceived twice\n            _note_too_small = (note.end - note.start) &lt; self.release_before_end\n            _shorter_note = (time &lt; (note.end - self.release_before_end))\n\n            if (_shorter_note or _note_too_small):\n                self.key_press_dynamics.target[midi] = note.velocity\n\n            # Either way, the channel must be colored\n            channels[midi] = note.channel\n\n            # Find empty slots or notes that will end soon, replace and play\n            other = self._playing_matrix[midi][note.channel]\n            if (other is None) or (other.end &gt; note.end):\n                play_velocity = int(128*((note.velocity/128)**0.5))\n                self.fluid_key_down(midi, play_velocity, note.channel)\n                self._playing_matrix[midi][note.channel] = note\n\n        # Find notes that are not being played\n        for channel in range(MAX_CHANNELS * self.scene.realtime):\n            if (other := self._playing_matrix[midi][channel]) and (other.end &lt; time):\n                self._playing_matrix[midi][channel] = None\n                self.fluid_key_up(midi, other.channel)\n\n    # Dynamic zoom velocity based on future lookup\n    self.note_range_dynamics.frequency = 0.5/self.lookup_time\n\n    # Set dynamic note range to the globals on the start\n    if sum(self.note_range_dynamics.value) == 0:\n        self.note_range_dynamics.value[:] = (self.global_minimum_note, self.global_maximum_note)\n\n    # Set new targets for dynamic keys\n    self.note_range_dynamics.target[:] = (\n        min(upcoming, default=self.global_minimum_note),\n        max(upcoming, default=self.global_maximum_note)\n    )\n\n    # Write to keys textures\n    self.note_range_dynamics.next(dt=abs(self.scene.dt))\n    self.key_press_dynamics.next(dt=abs(self.scene.dt))\n    self.keys_texture.write(data=self.key_press_dynamics.value)\n    self.roll_texture.write(data=roll)\n    self.channel_texture.write(data=channels)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}GlobalMin\",  self.global_minimum_note)\n    yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}GlobalMax\",  self.global_maximum_note)\n    yield ShaderVariable(\"uniform\", \"vec2\",  f\"{self.name}Dynamic\",    self.note_range_dynamics.value)\n    yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}RollTime\",   self.roll_time)\n    yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Extra\",      self.extra_side_keys)\n    yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Height\",     self.height)\n    yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Limit\",      MAX_ROLLING)\n    yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}BlackRatio\", self.black_ratio)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.fluidsynth","title":"<code>fluidsynth: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.soundfont","title":"<code>soundfont: Any = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.fluid_load","title":"<code>fluid_load(sf2: Path, driver: str = 'pulseaudio' if BrokenPlatform.OnLinux else None) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def fluid_load(self, sf2: Path, driver: str=(\"pulseaudio\" if BrokenPlatform.OnLinux else None)) -&gt; None:\n    if not (sf2 := BrokenPath(sf2)).exists():\n        log.warning(f\"{self.who} Couldn't load SoundFont from path ({sf2}), will not have Real Time MIDI Audio\")\n        return\n\n    # Download FluidSynth for Windows\n    if BrokenPlatform.OnWindows:\n        FLUIDSYNTH = \"https://github.com/FluidSynth/fluidsynth/releases/download/v2.3.4/fluidsynth-2.3.4-win10-x64.zip\"\n        BrokenPath.add_to_path(BrokenPath.extract(BrokenPath.download(FLUIDSYNTH), BROKEN.DIRECTORIES.EXTERNALS), recurse=True)\n    elif BrokenPlatform.OnMacOS:\n        if not shutil.which(\"fluidsynth\"):\n            shell(\"brew\", \"install\", \"fluidsynth\")\n    elif BrokenPlatform.OnLinux:\n        log.minor(f\"{self.who} Please install FluidSynth in your Package Manager if needed\")\n\n    import fluidsynth\n    self.fluidsynth = fluidsynth.Synth()\n    with BrokenSpinner(log.info(f\"Loading FluidSynth SoundFont ({sf2.name})\")):\n        self.soundfont = self.fluidsynth.sfload(str(sf2))\n    self.fluidsynth.set_reverb(1, 1, 80, 1)\n    self.fluidsynth.start(driver=driver)\n    for channel in range(MAX_CHANNELS):\n        self.fluid_select(channel, 0, 0)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.fluid_select","title":"<code>fluid_select(channel: int = 0, bank: int = 0, preset: int = 0) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def fluid_select(self, channel: int=0, bank: int=0, preset: int=0) -&gt; None:\n    if self.fluidsynth:\n        self.fluidsynth.program_select(channel, self.soundfont, bank, preset)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.fluid_key_down","title":"<code>fluid_key_down(note: int, velocity: int = 127, channel: int = 0) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def fluid_key_down(self, note: int, velocity: int=127, channel: int=0) -&gt; None:\n    if self.fluidsynth:\n        self.fluidsynth.noteon(channel, note, velocity)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.fluid_key_up","title":"<code>fluid_key_up(note: int, channel: int = 0) -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def fluid_key_up(self, note: int, channel: int=0) -&gt; None:\n    if self.fluidsynth:\n        self.fluidsynth.noteoff(channel, note)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.fluid_all_notes_off","title":"<code>fluid_all_notes_off() -&gt; None</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def fluid_all_notes_off(self) -&gt; None:\n    if self.fluidsynth:\n        for channel, note in itertools.product(range(MAX_CHANNELS), range(MAX_NOTE)):\n            self.fluidsynth.noteoff(channel, note)\n</code></pre>"},{"location":"shaderflow/reference/modules/piano/#Modules.Piano.ShaderPiano.fluid_render","title":"<code>fluid_render(midi: Path, soundfont: Path = None, output: Path = None) -&gt; Path</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Piano.py</code> Python<pre><code>def fluid_render(self,\n    midi: Path,\n    soundfont: Path=None,\n    output: Path=None\n) -&gt; Path:\n    if not self.fluidsynth:\n        return\n\n    # Get temporary cached file\n    if output is None:\n        midi_hash = hashlib.md5(BrokenPath(midi).read_bytes()).hexdigest()\n        output = Path(tempfile.gettempdir())/f\"ShaderFlow-Midi2Audio-{midi_hash}.wav\"\n\n    import midi2audio\n    with BrokenSpinner(log.info(f\"Rendering FluidSynth Midi ({midi}) \u2192 ({output})\")):\n        midi2audio.FluidSynth(soundfont).midi_to_audio(midi, output)\n\n    # Normalize audio with FFmpeg\n    normalized = output.with_suffix(\".aac\")\n    with BrokenSpinner(log.info(f\"Normalizing Audio ({output}) \u2192 ({normalized})\")):\n        (BrokenFFmpeg()\n            .quiet()\n            .overwrite()\n            .input(output)\n            .filter(\"loudnorm\")\n            .aac()\n            .output(normalized)\n        ).run()\n\n    return BrokenPath(normalized)\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/","title":"Spectrogram","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram","title":"<code>Modules.Spectrogram</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioFourierMagnitude","title":"<code>Modules.Spectrogram.BrokenAudioFourierMagnitude</code>","text":"<p>Given an raw FFT, interpret the complex number as some size</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>class BrokenAudioFourierMagnitude:\n    \"\"\"Given an raw FFT, interpret the complex number as some size\"\"\"\n    def Amplitude(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return numpy.abs(x)\n\n    def Power(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return x*x.conjugate()\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioFourierMagnitude.Amplitude","title":"<code>Amplitude(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def Amplitude(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return numpy.abs(x)\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioFourierMagnitude.Power","title":"<code>Power(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def Power(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return x*x.conjugate()\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioFourierVolume","title":"<code>Modules.Spectrogram.BrokenAudioFourierVolume</code>","text":"<p>Convert the FFT into the final spectrogram's magnitude bin</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>class BrokenAudioFourierVolume:\n    \"\"\"Convert the FFT into the final spectrogram's magnitude bin\"\"\"\n\n    def dBFS(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return 10*numpy.log10(x)\n\n    def Sqrt(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return numpy.sqrt(x)\n\n    def Linear(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return x\n\n    def dBFsTremx(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return 10*(numpy.log10(x+0.1) + 1)/1.0414\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioFourierVolume.dBFS","title":"<code>dBFS(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def dBFS(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return 10*numpy.log10(x)\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioFourierVolume.Sqrt","title":"<code>Sqrt(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def Sqrt(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return numpy.sqrt(x)\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioFourierVolume.Linear","title":"<code>Linear(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def Linear(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return x\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioFourierVolume.dBFsTremx","title":"<code>dBFsTremx(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def dBFsTremx(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return 10*(numpy.log10(x+0.1) + 1)/1.0414\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramInterpolation","title":"<code>Modules.Spectrogram.BrokenAudioSpectrogramInterpolation</code>","text":"<p>Interpolate the FFT values, discrete to continuous</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>class BrokenAudioSpectrogramInterpolation:\n    \"\"\"Interpolate the FFT values, discrete to continuous\"\"\"\n    #\n    # I can explain this better later, but the idea is here:\n    # \u2022 https://www.desmos.com/calculator/vvixdoooty\n    # \u2022 https://en.wikipedia.org/wiki/Whittaker%E2%80%93Shannon_interpolation_formula\n    #\n    # Sinc(x) is already normalized (divided by the area, pi) as in sinc(x) = sin(pi*x)/(pi*x).\n    #\n    # The general case for a interpolation formula is to normalize some function f(x) by its area.\n    # For example, in the case of exp(-x^2) as the function, its area is the  magical sqrt(pi)\n    # as seen in @3b1b https://www.youtube.com/watch?v=cy8r7WSuT1I\n    #\n\n    # Note: A value above 1.54 is recommended\n    def make_euler(end: float=1.54) -&gt; Callable:\n        return (lambda x: numpy.exp(-(2*x/end)**2) / (end*(pi**0.5)))\n\n    def Dirac(x):\n        dirac = numpy.zeros(x.shape)\n        dirac[numpy.round(x) == 0] = 1\n        return dirac\n\n    Euler = make_euler(end=1.2)\n\n    def Sinc(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return numpy.abs(numpy.sinc(x))\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramInterpolation.make_euler","title":"<code>make_euler(end: float = 1.54) -&gt; Callable</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def make_euler(end: float=1.54) -&gt; Callable:\n    return (lambda x: numpy.exp(-(2*x/end)**2) / (end*(pi**0.5)))\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramInterpolation.Dirac","title":"<code>Dirac(x)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def Dirac(x):\n    dirac = numpy.zeros(x.shape)\n    dirac[numpy.round(x) == 0] = 1\n    return dirac\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramInterpolation.Euler","title":"<code>Euler = make_euler(end=1.2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramInterpolation.Sinc","title":"<code>Sinc(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def Sinc(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return numpy.abs(numpy.sinc(x))\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramScale","title":"<code>Modules.Spectrogram.BrokenAudioSpectrogramScale</code>","text":"<p>Functions that defines the y scale of the spectrogram. Tuples of f(x) and f^-1(x)</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>class BrokenAudioSpectrogramScale:\n    \"\"\"Functions that defines the y scale of the spectrogram. Tuples of f(x) and f^-1(x)\"\"\"\n\n    # Octave, matches the piano keys\n    # Todo: Make a generic base exponent?\n    Octave = (\n        lambda x: (numpy.log(x)/numpy.log(2)),\n        lambda x: (2**x)\n    )\n\n    # Personally not a big fan\n    MEL = (\n        lambda x: 2595 * numpy.log10(1 + x/700),\n        lambda x: 700 * (10**(x/2595) - 1),\n    )\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramScale.Octave","title":"<code>Octave = (lambda x: numpy.log(x) / numpy.log(2), lambda x: 2 ** x)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramScale.MEL","title":"<code>MEL = (lambda x: 2595 * numpy.log10(1 + x / 700), lambda x: 700 * 10 ** x / 2595 - 1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramWindow","title":"<code>Modules.Spectrogram.BrokenAudioSpectrogramWindow</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>class BrokenAudioSpectrogramWindow:\n\n    @functools.lru_cache\n    def hann_poisson_window(N: int, alpha: float=2) -&gt; numpy.ndarray:\n        \"\"\"\n        Generate a Hann-Poisson window\n\n        Args:\n            N: The number of window samples\n            alpha: Slope of the exponential\n\n        Returns:\n            numpy.array: Window samples\n        \"\"\"\n        n = numpy.arange(N)\n        hann    = 0.5 * (1 - numpy.cos(2 * numpy.pi * n / N))\n        poisson = numpy.exp(-alpha * numpy.abs(N - 2*n) / N)\n        return hann * poisson\n\n    @functools.lru_cache\n    def hanning(size: int) -&gt; numpy.ndarray:\n        \"\"\"Returns a hanning window of the given size\"\"\"\n        return numpy.hanning(size)\n\n    @functools.lru_cache\n    def none(size: int) -&gt; numpy.ndarray:\n        \"\"\"Returns a none window of the given size\"\"\"\n        return numpy.ones(size)\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramWindow.hann_poisson_window","title":"<code>hann_poisson_window(N: int, alpha: float = 2) -&gt; numpy.ndarray</code>  <code>cached</code>","text":"<p>Generate a Hann-Poisson window</p> <p>Parameters:</p> <ul> <li> <code>N</code>             (<code>int</code>)         \u2013          <p>The number of window samples</p> </li> <li> <code>alpha</code>             (<code>float</code>, default:                 <code>2</code> )         \u2013          <p>Slope of the exponential</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>numpy.ndarray</code>         \u2013          <p>numpy.array: Window samples</p> </li> </ul> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>@functools.lru_cache\ndef hann_poisson_window(N: int, alpha: float=2) -&gt; numpy.ndarray:\n    \"\"\"\n    Generate a Hann-Poisson window\n\n    Args:\n        N: The number of window samples\n        alpha: Slope of the exponential\n\n    Returns:\n        numpy.array: Window samples\n    \"\"\"\n    n = numpy.arange(N)\n    hann    = 0.5 * (1 - numpy.cos(2 * numpy.pi * n / N))\n    poisson = numpy.exp(-alpha * numpy.abs(N - 2*n) / N)\n    return hann * poisson\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramWindow.hanning","title":"<code>hanning(size: int) -&gt; numpy.ndarray</code>  <code>cached</code>","text":"<p>Returns a hanning window of the given size</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>@functools.lru_cache\ndef hanning(size: int) -&gt; numpy.ndarray:\n    \"\"\"Returns a hanning window of the given size\"\"\"\n    return numpy.hanning(size)\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenAudioSpectrogramWindow.none","title":"<code>none(size: int) -&gt; numpy.ndarray</code>  <code>cached</code>","text":"<p>Returns a none window of the given size</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>@functools.lru_cache\ndef none(size: int) -&gt; numpy.ndarray:\n    \"\"\"Returns a none window of the given size\"\"\"\n    return numpy.ones(size)\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram","title":"<code>Modules.Spectrogram.BrokenSpectrogram</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>@define(slots=False)\nclass BrokenSpectrogram:\n    audio: BrokenAudio = Factory(BrokenAudio)\n\n    fft_n: int = field(default=12, converter=int)\n    \"\"\"2^n FFT size, higher values, higher frequency resolution, less responsiveness\"\"\"\n\n    sample_rateio: int = field(default=1, converter=int)\n    \"\"\"Resample the input data by a factor, int for FFT optimizations\"\"\"\n\n    # Spectrogram properties\n    scale:        Tuple[callable] = BrokenAudioSpectrogramScale.Octave\n    interpolation:      callable  = BrokenAudioSpectrogramInterpolation.Euler\n    magnitude_function: callable  = BrokenAudioFourierMagnitude.Power\n    window_function:    callable  = BrokenAudioSpectrogramWindow.hanning\n    volume:             callable  = BrokenAudioFourierVolume.Sqrt\n\n    def __cache__(self) -&gt; int:\n        return hash((\n            self.fft_n,\n            self.minimum_frequency,\n            self.maximum_frequency,\n            self.spectrogram_bins,\n            self.sample_rateio,\n            self.magnitude_function,\n            self.interpolation,\n            self.scale,\n            self.volume,\n        ))\n\n    # # Fourier\n\n    @property\n    def fft_size(self) -&gt; Samples:\n        return int(2**(self.fft_n) * self.sample_rateio)\n\n    @property\n    def fft_bins(self) -&gt; int:\n        return int(self.fft_size/2 + 1)\n\n    @property\n    def fft_frequencies(self) -&gt; Union[numpy.ndarray, Hertz]:\n        return numpy.fft.rfftfreq(self.fft_size, 1/(self.audio.samplerate*self.sample_rateio))\n\n    def fft(self) -&gt; numpy.ndarray:\n        data = self.audio.get_last_n_samples(int(2**self.fft_n))\n\n        # Optionally resample the data\n        if self.sample_rateio != 1:\n            try:\n                import samplerate\n            except ModuleNotFoundError:\n                raise RuntimeError('\\n'.join((\n                    \"Please install 'samplerate' optional dependency for resampling:\"\n                    \"\u2022 Find it at: (https://pypi.org/project/samplerate)\"\n                    \"\u2022 From Source (Rye): 'rye sync --features samplerate'\"\n                    \"\u2022 From PIP: 'pip install broken-source[samplerate]'\"\n                )))\n            data = numpy.array([samplerate.resample(x, self.sample_rateio, 'linear') for x in data])\n\n        return self.magnitude_function(\n            numpy.fft.rfft(self.window_function(self.fft_size) * data)\n        ).astype(self.audio.dtype)\n\n    # # Spectrogram\n\n    def next(self) -&gt; numpy.ndarray:\n        return self.spectrogram_matrix.dot(self.fft().T).T\n        return self.volume([\n            self.spectrogram_matrix @ channel\n            for channel in self.fft()\n        ])\n\n    minimum_frequency: Hertz = 20.0\n    maximum_frequency: Hertz = 20000.0\n    spectrogram_bins:  int   = 1000\n\n    @property\n    def spectrogram_frequencies(self) -&gt; numpy.ndarray:\n        return self.scale[1](numpy.linspace(\n            self.scale[0](self.minimum_frequency),\n            self.scale[0](self.maximum_frequency),\n            self.spectrogram_bins,\n        ))\n\n    @property\n    @cachetools.cached(cache={}, key=lambda self: self.__cache__())\n    def spectrogram_matrix(self) -&gt; scipy.sparse.csr_matrix:\n        \"\"\"\n        Gets a transformation matrix that multiplied with self.fft yields \"spectrogram bins\" in custom scale\n\n        The idea to get the center frequencies on the custom scale is to compute the following:\n        $$ center_frequencies = T^-1(linspace(T(min), T(max), n)) $$\n\n        Where T(f) transforms a frequency to some scale (done in self.spectrogram_frequencies)\n\n        And then create many band-pass filters, each one centered on the center frequencies using\n        Whittaker-Shannon's interpolation formula per row of the matrix, considering the FFT bins as\n        a one-hertz-frequency function to interpolate, we find \"the around frequencies\" !\n        \"\"\"\n\n        # Whittaker-Shannon interpolation formula per row of the matrix\n        matrix = numpy.array([\n            self.interpolation(theoretical_index - numpy.arange(self.fft_bins))\n            for theoretical_index in (self.spectrogram_frequencies/self.fft_frequencies[1])\n        ], dtype=self.audio.dtype)\n\n        # Zero out near-zero values\n        matrix[numpy.abs(matrix) &lt; 1e-5] = 0\n\n        # Create a scipy sparse for much faster matrix multiplication\n        return scipy.sparse.csr_matrix(matrix)\n\n    def from_notes(self,\n        start: BrokenPianoNote,\n        end: BrokenPianoNote,\n        bins: int=1000,\n        piano: bool=False,\n        tuning: Hertz=440,\n    ):\n        start = BrokenPianoNote.get(start, tuning=tuning)\n        end   = BrokenPianoNote.get(end, tuning=tuning)\n        log.info(f\"Making Spectrogram Piano Matrix from notes ({start.name} - {end.name})\")\n        self.minimum_frequency = start.frequency\n        self.maximum_frequency = end.frequency\n        if not piano:\n            self.spectrogram_bins = bins\n        else:\n            # The advertised number of bins should start and end on a note\n            half_semitone = 2**(0.5/12)\n            self.spectrogram_bins = ((end.note - start.note) + 1)\n            self.minimum_frequency /= half_semitone\n            self.maximum_frequency *= half_semitone\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.audio","title":"<code>audio: BrokenAudio = Factory(BrokenAudio)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.fft_n","title":"<code>fft_n: int = field(default=12, converter=int)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>2^n FFT size, higher values, higher frequency resolution, less responsiveness</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.sample_rateio","title":"<code>sample_rateio: int = field(default=1, converter=int)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Resample the input data by a factor, int for FFT optimizations</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.scale","title":"<code>scale: Tuple[callable] = BrokenAudioSpectrogramScale.Octave</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.interpolation","title":"<code>interpolation: callable = BrokenAudioSpectrogramInterpolation.Euler</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.magnitude_function","title":"<code>magnitude_function: callable = BrokenAudioFourierMagnitude.Power</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.window_function","title":"<code>window_function: callable = BrokenAudioSpectrogramWindow.hanning</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.volume","title":"<code>volume: callable = BrokenAudioFourierVolume.Sqrt</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.__cache__","title":"<code>__cache__() -&gt; int</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def __cache__(self) -&gt; int:\n    return hash((\n        self.fft_n,\n        self.minimum_frequency,\n        self.maximum_frequency,\n        self.spectrogram_bins,\n        self.sample_rateio,\n        self.magnitude_function,\n        self.interpolation,\n        self.scale,\n        self.volume,\n    ))\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.fft_size","title":"<code>fft_size: Samples</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.fft_bins","title":"<code>fft_bins: int</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.fft_frequencies","title":"<code>fft_frequencies: Union[numpy.ndarray, Hertz]</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.fft","title":"<code>fft() -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def fft(self) -&gt; numpy.ndarray:\n    data = self.audio.get_last_n_samples(int(2**self.fft_n))\n\n    # Optionally resample the data\n    if self.sample_rateio != 1:\n        try:\n            import samplerate\n        except ModuleNotFoundError:\n            raise RuntimeError('\\n'.join((\n                \"Please install 'samplerate' optional dependency for resampling:\"\n                \"\u2022 Find it at: (https://pypi.org/project/samplerate)\"\n                \"\u2022 From Source (Rye): 'rye sync --features samplerate'\"\n                \"\u2022 From PIP: 'pip install broken-source[samplerate]'\"\n            )))\n        data = numpy.array([samplerate.resample(x, self.sample_rateio, 'linear') for x in data])\n\n    return self.magnitude_function(\n        numpy.fft.rfft(self.window_function(self.fft_size) * data)\n    ).astype(self.audio.dtype)\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.next","title":"<code>next() -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def next(self) -&gt; numpy.ndarray:\n    return self.spectrogram_matrix.dot(self.fft().T).T\n    return self.volume([\n        self.spectrogram_matrix @ channel\n        for channel in self.fft()\n    ])\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.minimum_frequency","title":"<code>minimum_frequency: Hertz = 20.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.maximum_frequency","title":"<code>maximum_frequency: Hertz = 20000.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.spectrogram_bins","title":"<code>spectrogram_bins: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.spectrogram_frequencies","title":"<code>spectrogram_frequencies: numpy.ndarray</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.spectrogram_matrix","title":"<code>spectrogram_matrix: scipy.sparse.csr_matrix</code>  <code>property</code>","text":"<p>Gets a transformation matrix that multiplied with self.fft yields \"spectrogram bins\" in custom scale</p> <p>The idea to get the center frequencies on the custom scale is to compute the following: $$ center_frequencies = T^-1(linspace(T(min), T(max), n)) $$</p> <p>Where T(f) transforms a frequency to some scale (done in self.spectrogram_frequencies)</p> <p>And then create many band-pass filters, each one centered on the center frequencies using Whittaker-Shannon's interpolation formula per row of the matrix, considering the FFT bins as a one-hertz-frequency function to interpolate, we find \"the around frequencies\" !</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.BrokenSpectrogram.from_notes","title":"<code>from_notes(start: BrokenPianoNote, end: BrokenPianoNote, bins: int = 1000, piano: bool = False, tuning: Hertz = 440)</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def from_notes(self,\n    start: BrokenPianoNote,\n    end: BrokenPianoNote,\n    bins: int=1000,\n    piano: bool=False,\n    tuning: Hertz=440,\n):\n    start = BrokenPianoNote.get(start, tuning=tuning)\n    end   = BrokenPianoNote.get(end, tuning=tuning)\n    log.info(f\"Making Spectrogram Piano Matrix from notes ({start.name} - {end.name})\")\n    self.minimum_frequency = start.frequency\n    self.maximum_frequency = end.frequency\n    if not piano:\n        self.spectrogram_bins = bins\n    else:\n        # The advertised number of bins should start and end on a note\n        half_semitone = 2**(0.5/12)\n        self.spectrogram_bins = ((end.note - start.note) + 1)\n        self.minimum_frequency /= half_semitone\n        self.maximum_frequency *= half_semitone\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram","title":"<code>Modules.Spectrogram.ShaderSpectrogram</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>@define\nclass ShaderSpectrogram(BrokenSpectrogram, ShaderModule):\n    name: str = \"iSpectrogram\"\n    \"\"\"Prefix name and Texture name of the Shader Variables\"\"\"\n\n    length: Seconds = 5\n    \"\"\"Horizontal length of the Spectrogram content\"\"\"\n\n    offset: Samples = 0\n    \"\"\"Modulus of total samples written by length, used for scrolling mode\"\"\"\n\n    smooth: bool = False\n    \"\"\"Enables Linear interpolation on the Texture, not useful for Bars mode\"\"\"\n\n    scrolling: bool = False\n    \"\"\"\"\"\"\n\n    dynamics: DynamicNumber = None\n    \"\"\"Apply Dynamics to the FFT data\"\"\"\n\n    texture: ShaderTexture = None\n    \"\"\"Internal managed Texture\"\"\"\n\n    @property\n    def length_samples(self) -&gt; Samples:\n        return int(max(1, self.length*self.scene.fps))\n\n    def __post__(self):\n        self.dynamics = DynamicNumber(frequency=4, zeta=1, response=0)\n        self.texture = ShaderTexture(\n            scene=self.scene,\n            name=self.name,\n            dtype=TextureType.f4,\n            repeat_y=False,\n        )\n\n    __same__: SameTracker = Factory(SameTracker)\n\n    def update(self):\n        self.texture.components = self.audio.channels\n        self.texture.filter = (\"linear\" if self.smooth else \"nearest\")\n        self.texture.height = self.spectrogram_bins\n        self.texture.width = self.length_samples\n        self.offset = (self.offset + 1) % self.length_samples\n        if not self.__same__(self.audio.tell):\n            self.dynamics.target = self.next().T.reshape(2, -1)\n        self.dynamics.next(dt=abs(self.scene.dt))\n        self.texture.write(\n            viewport=(self.offset, 0, 1, self.spectrogram_bins),\n            data=self.dynamics.value,\n        )\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Length\", self.length_samples)\n        yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Bins\",   self.spectrogram_bins)\n        yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Offset\", self.offset/self.length_samples)\n        yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Smooth\", self.smooth)\n        yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Min\",    self.spectrogram_frequencies[0])\n        yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Max\",    self.spectrogram_frequencies[-1])\n        yield ShaderVariable(\"uniform\", \"bool\",  f\"{self.name}Scroll\", self.scrolling)\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.name","title":"<code>name: str = 'iSpectrogram'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Prefix name and Texture name of the Shader Variables</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.length","title":"<code>length: Seconds = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Horizontal length of the Spectrogram content</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.offset","title":"<code>offset: Samples = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Modulus of total samples written by length, used for scrolling mode</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.smooth","title":"<code>smooth: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enables Linear interpolation on the Texture, not useful for Bars mode</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.scrolling","title":"<code>scrolling: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.dynamics","title":"<code>dynamics: DynamicNumber = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Apply Dynamics to the FFT data</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.texture","title":"<code>texture: ShaderTexture = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internal managed Texture</p>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.length_samples","title":"<code>length_samples: Samples</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def __post__(self):\n    self.dynamics = DynamicNumber(frequency=4, zeta=1, response=0)\n    self.texture = ShaderTexture(\n        scene=self.scene,\n        name=self.name,\n        dtype=TextureType.f4,\n        repeat_y=False,\n    )\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.__same__","title":"<code>__same__: SameTracker = Factory(SameTracker)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.update","title":"<code>update()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def update(self):\n    self.texture.components = self.audio.channels\n    self.texture.filter = (\"linear\" if self.smooth else \"nearest\")\n    self.texture.height = self.spectrogram_bins\n    self.texture.width = self.length_samples\n    self.offset = (self.offset + 1) % self.length_samples\n    if not self.__same__(self.audio.tell):\n        self.dynamics.target = self.next().T.reshape(2, -1)\n    self.dynamics.next(dt=abs(self.scene.dt))\n    self.texture.write(\n        viewport=(self.offset, 0, 1, self.spectrogram_bins),\n        data=self.dynamics.value,\n    )\n</code></pre>"},{"location":"shaderflow/reference/modules/spectrogram/#Modules.Spectrogram.ShaderSpectrogram.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Spectrogram.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Length\", self.length_samples)\n    yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Bins\",   self.spectrogram_bins)\n    yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Offset\", self.offset/self.length_samples)\n    yield ShaderVariable(\"uniform\", \"int\",   f\"{self.name}Smooth\", self.smooth)\n    yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Min\",    self.spectrogram_frequencies[0])\n    yield ShaderVariable(\"uniform\", \"float\", f\"{self.name}Max\",    self.spectrogram_frequencies[-1])\n    yield ShaderVariable(\"uniform\", \"bool\",  f\"{self.name}Scroll\", self.scrolling)\n</code></pre>"},{"location":"shaderflow/reference/modules/video/","title":"Video","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/video/#Modules.Video","title":"<code>Modules.Video</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames","title":"<code>Modules.Video.BrokenSmartVideoFrames</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>@define(slots=False)\nclass BrokenSmartVideoFrames(BrokenAttrs):\n    path:     Path    = None\n    buffer:   Seconds = 60\n    threads:  int     = 6\n    quality:  int     = 95\n    time:     Seconds = 0\n    lossless: bool    = True\n    _width:   int     = None\n    _height:  int     = None\n    _fps:     Hertz   = None\n    _turbo:   Any     = None\n    _raw:     deque   = Factory(deque)\n    _frames:  Dict    = Factory(dict)\n\n    # Dynamically set\n    encode:  Callable = None\n    decode:  Callable = None\n\n    @property\n    def max_raw(self) -&gt; int:\n        return self.threads*4\n\n    @property\n    def width(self) -&gt; int:\n        return self._width\n\n    @property\n    def height(self) -&gt; int:\n        return self._height\n\n    # # Initialization\n\n    LOSSLESS_MAX_BUFFER_LENGTH = 4\n\n    def __post__(self):\n        self._fps = BrokenFFmpeg.get_video_framerate(self.path)\n        self._width, self._height = BrokenFFmpeg.get_video_resolution(self.path)\n\n        if not all((self._fps, self._width, self._height)):\n            raise ValueError(\"Could not get video metadata\")\n\n        # TurboJPEG will raise if shared lib is not found\n        with contextlib.suppress(RuntimeError, ModuleNotFoundError):\n            import turbojpeg\n            self._turbo = turbojpeg.TurboJPEG()\n\n        if self.lossless:\n            log.warning(\"Using lossless frames. Limiting buffer length for Out of Memory safety\")\n            self.buffer = min(self.buffer, BrokenSmartVideoFrames.LOSSLESS_MAX_BUFFER_LENGTH)\n            self.encode = lambda frame: frame\n            self.decode = lambda frame: frame\n\n        elif (self._turbo is not None):\n            log.success(\"Using TurboJPEG for compression. Best speeds available\")\n            self.encode = lambda frame: self._turbo.encode(frame, quality=self.quality)\n            self.decode = lambda frame: self._turbo.decode(frame)\n\n        elif (\"cv2\" in sys.modules):\n            log.success(\"Using OpenCV for compression. Slower than TurboJPEG but enough\")\n            self.encode = lambda frame: cv2.imencode(\".jpeg\", frame)[1]\n            self.decode = lambda frame: cv2.imdecode(frame, cv2.IMREAD_COLOR)\n\n        else:\n            log.warning(\"Using PIL for compression. Performance killer GIL fallback\")\n            self.decode = lambda frame: PIL.Image.open(io.BytesIO(frame))\n            self.encode = lambda frame: PIL.Image.fromarray(frame).save(\n                io.BytesIO(), format=\"jpeg\", quality=self.quality\n            )\n\n        # Create worker threads. The good, the bad and the ugly\n        BrokenThread(target=self.extractor, daemon=True)\n        BrokenThread(target=self.deleter,   daemon=True)\n        for _ in range(self.threads):\n            BrokenThread(target=self.worker, daemon=True)\n\n    # # Utilities\n\n    def time2index(self, time: Seconds) -&gt; int:\n        return int(time*self._fps)\n\n    def index2time(self, index: int) -&gt; Seconds:\n        return (index/self._fps)\n\n    # # Check if we can decode and encode with the libraries\n\n    def get_frame(self, time: Seconds) -&gt; Tuple[int, numpy.ndarray]:\n        want = self.time2index(time)\n        self.time = time\n        import time\n\n        # Wait until the frame exists\n        while (jpeg := self._frames.get(want)) is None:\n            time.sleep(0.01)\n\n        return (want, lambda: self.decode(jpeg))\n\n    @property\n    def buffer_frames(self) -&gt; int:\n        return int(self.buffer*self._fps)\n\n    @property\n    def time_index(self) -&gt; int:\n        return self.time2index(self.time)\n\n    @property\n    def _future_index(self) -&gt; int:\n        return self.time_index + self.buffer_frames\n\n    def _future_window(self, index: int) -&gt; bool:\n        return index &lt; self._future_index\n\n    @property\n    def _past_index(self) -&gt; int:\n        return self.time_index - self.buffer_frames\n\n    def _past_window(self, index: int) -&gt; bool:\n        return self._past_index &lt; index\n\n    def _time_window(self, index: int) -&gt; bool:\n        return self._past_window(index) and self._future_window(index)\n\n    def _should_rewind(self, index: int) -&gt; bool:\n        \"\"\"Point must be older than the past cutoff to trigger a rewind\"\"\"\n        return (self.time_index + self.buffer_frames) &lt; index\n\n    # # Workers\n\n    _oldest: int = 0\n    _newest: int = 0\n\n    def extractor(self):\n        def forward():\n            for index, frame in enumerate(BrokenFFmpeg.iter_video_frames(self.path)):\n\n                # Skip already processed frames\n                if self._frames.get(index) is not None:\n                    continue\n\n                # Skip frames outside of the past time window\n                if not self._past_window(index):\n                    continue\n\n                while not self._future_window(index):\n                    if self._should_rewind(index):\n                        return\n                    time.sleep(0.01)\n\n                # Limit how much raw frames there can be\n                while len(self._raw) &gt; self.max_raw:\n                    time.sleep(0.01)\n\n                self._raw.append((index, frame))\n                self._newest = max(self._newest, index)\n\n        while True:\n            forward()\n\n    def worker(self):\n        \"\"\"Blindly get new frames from the deque, compress and store them\"\"\"\n        while True:\n            try:\n                index, frame = self._raw.popleft()\n                frame = numpy.array(numpy.flip(frame, axis=0))\n                self._frames[index] = self.encode(frame)\n            except IndexError:\n                time.sleep(0.01)\n\n    def deleter(self):\n        \"\"\"Delete old frames that are not in the time window\"\"\"\n        while True:\n            for index in range(self._oldest, self._past_index):\n                self._frames[index] = None\n                self._oldest = index\n            for index in range(self._newest, self._future_index, -1):\n                self._frames[index] = None\n                self._newest = index\n            time.sleep(0.5)\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.path","title":"<code>path: Path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.buffer","title":"<code>buffer: Seconds = 60</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.threads","title":"<code>threads: int = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.quality","title":"<code>quality: int = 95</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.time","title":"<code>time: Seconds = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.lossless","title":"<code>lossless: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.encode","title":"<code>encode: Callable = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.decode","title":"<code>decode: Callable = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.max_raw","title":"<code>max_raw: int</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.width","title":"<code>width: int</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.height","title":"<code>height: int</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.LOSSLESS_MAX_BUFFER_LENGTH","title":"<code>LOSSLESS_MAX_BUFFER_LENGTH = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>def __post__(self):\n    self._fps = BrokenFFmpeg.get_video_framerate(self.path)\n    self._width, self._height = BrokenFFmpeg.get_video_resolution(self.path)\n\n    if not all((self._fps, self._width, self._height)):\n        raise ValueError(\"Could not get video metadata\")\n\n    # TurboJPEG will raise if shared lib is not found\n    with contextlib.suppress(RuntimeError, ModuleNotFoundError):\n        import turbojpeg\n        self._turbo = turbojpeg.TurboJPEG()\n\n    if self.lossless:\n        log.warning(\"Using lossless frames. Limiting buffer length for Out of Memory safety\")\n        self.buffer = min(self.buffer, BrokenSmartVideoFrames.LOSSLESS_MAX_BUFFER_LENGTH)\n        self.encode = lambda frame: frame\n        self.decode = lambda frame: frame\n\n    elif (self._turbo is not None):\n        log.success(\"Using TurboJPEG for compression. Best speeds available\")\n        self.encode = lambda frame: self._turbo.encode(frame, quality=self.quality)\n        self.decode = lambda frame: self._turbo.decode(frame)\n\n    elif (\"cv2\" in sys.modules):\n        log.success(\"Using OpenCV for compression. Slower than TurboJPEG but enough\")\n        self.encode = lambda frame: cv2.imencode(\".jpeg\", frame)[1]\n        self.decode = lambda frame: cv2.imdecode(frame, cv2.IMREAD_COLOR)\n\n    else:\n        log.warning(\"Using PIL for compression. Performance killer GIL fallback\")\n        self.decode = lambda frame: PIL.Image.open(io.BytesIO(frame))\n        self.encode = lambda frame: PIL.Image.fromarray(frame).save(\n            io.BytesIO(), format=\"jpeg\", quality=self.quality\n        )\n\n    # Create worker threads. The good, the bad and the ugly\n    BrokenThread(target=self.extractor, daemon=True)\n    BrokenThread(target=self.deleter,   daemon=True)\n    for _ in range(self.threads):\n        BrokenThread(target=self.worker, daemon=True)\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.time2index","title":"<code>time2index(time: Seconds) -&gt; int</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>def time2index(self, time: Seconds) -&gt; int:\n    return int(time*self._fps)\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.index2time","title":"<code>index2time(index: int) -&gt; Seconds</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>def index2time(self, index: int) -&gt; Seconds:\n    return (index/self._fps)\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.get_frame","title":"<code>get_frame(time: Seconds) -&gt; Tuple[int, numpy.ndarray]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>def get_frame(self, time: Seconds) -&gt; Tuple[int, numpy.ndarray]:\n    want = self.time2index(time)\n    self.time = time\n    import time\n\n    # Wait until the frame exists\n    while (jpeg := self._frames.get(want)) is None:\n        time.sleep(0.01)\n\n    return (want, lambda: self.decode(jpeg))\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.buffer_frames","title":"<code>buffer_frames: int</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.time_index","title":"<code>time_index: int</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.extractor","title":"<code>extractor()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>def extractor(self):\n    def forward():\n        for index, frame in enumerate(BrokenFFmpeg.iter_video_frames(self.path)):\n\n            # Skip already processed frames\n            if self._frames.get(index) is not None:\n                continue\n\n            # Skip frames outside of the past time window\n            if not self._past_window(index):\n                continue\n\n            while not self._future_window(index):\n                if self._should_rewind(index):\n                    return\n                time.sleep(0.01)\n\n            # Limit how much raw frames there can be\n            while len(self._raw) &gt; self.max_raw:\n                time.sleep(0.01)\n\n            self._raw.append((index, frame))\n            self._newest = max(self._newest, index)\n\n    while True:\n        forward()\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.worker","title":"<code>worker()</code>","text":"<p>Blindly get new frames from the deque, compress and store them</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>def worker(self):\n    \"\"\"Blindly get new frames from the deque, compress and store them\"\"\"\n    while True:\n        try:\n            index, frame = self._raw.popleft()\n            frame = numpy.array(numpy.flip(frame, axis=0))\n            self._frames[index] = self.encode(frame)\n        except IndexError:\n            time.sleep(0.01)\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.BrokenSmartVideoFrames.deleter","title":"<code>deleter()</code>","text":"<p>Delete old frames that are not in the time window</p> Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>def deleter(self):\n    \"\"\"Delete old frames that are not in the time window\"\"\"\n    while True:\n        for index in range(self._oldest, self._past_index):\n            self._frames[index] = None\n            self._oldest = index\n        for index in range(self._newest, self._future_index, -1):\n            self._frames[index] = None\n            self._newest = index\n        time.sleep(0.5)\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.ShaderVideo","title":"<code>Modules.Video.ShaderVideo</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>@define\nclass ShaderVideo(BrokenSmartVideoFrames, ShaderModule):\n    name: str = \"iVideo\"\n    texture: ShaderTexture = None\n\n    temporal: int = 10\n    \"\"\"How many \"\"\"\n\n    on_frame: BrokenRelay = Factory(BrokenRelay)\n    \"\"\"Whenever a new video frame is decoded, this attribute is called. Preferably subscribe to\n    it with `video.on_frame.subscribe(callable)` or `video.on_frame @ (A, B, C)`, see BokenRelay\"\"\"\n\n    def __post__(self):\n        self.texture = ShaderTexture(\n            scene=self.scene,\n            name=self.name,\n            width=self.width,\n            height=self.height,\n            temporal=self.temporal,\n            components=3,\n            dtype=\"f1\"\n        )\n\n    __same__: SameTracker = Factory(SameTracker)\n\n    def update(self):\n        index, decode = self.get_frame(self.scene.time)\n\n        if not self.__same__(index):\n            image = decode()\n            self.texture.roll()\n            self.texture.write(image)\n            self.on_frame(image)\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.ShaderVideo.name","title":"<code>name: str = 'iVideo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.ShaderVideo.texture","title":"<code>texture: ShaderTexture = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.ShaderVideo.temporal","title":"<code>temporal: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How many</p>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.ShaderVideo.on_frame","title":"<code>on_frame: BrokenRelay = Factory(BrokenRelay)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whenever a new video frame is decoded, this attribute is called. Preferably subscribe to it with <code>video.on_frame.subscribe(callable)</code> or <code>video.on_frame @ (A, B, C)</code>, see BokenRelay</p>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.ShaderVideo.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>def __post__(self):\n    self.texture = ShaderTexture(\n        scene=self.scene,\n        name=self.name,\n        width=self.width,\n        height=self.height,\n        temporal=self.temporal,\n        components=3,\n        dtype=\"f1\"\n    )\n</code></pre>"},{"location":"shaderflow/reference/modules/video/#Modules.Video.ShaderVideo.__same__","title":"<code>__same__: SameTracker = Factory(SameTracker)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shaderflow/reference/modules/video/#Modules.Video.ShaderVideo.update","title":"<code>update()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Video.py</code> Python<pre><code>def update(self):\n    index, decode = self.get_frame(self.scene.time)\n\n    if not self.__same__(index):\n        image = decode()\n        self.texture.roll()\n        self.texture.write(image)\n        self.on_frame(image)\n</code></pre>"},{"location":"shaderflow/reference/modules/waveform/","title":"Waveform","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform","title":"<code>Modules.Waveform</code>","text":""},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.WaveformReducer","title":"<code>Modules.Waveform.WaveformReducer</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Waveform.py</code> Python<pre><code>class WaveformReducer(BrokenEnum):\n    def Average(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return numpy.sqrt(numpy.mean(numpy.abs(x), axis=2))\n\n    def RMS(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return numpy.sqrt(numpy.sqrt(numpy.mean(x**2, axis=2))*(2**0.5))\n\n    def STD(x: numpy.ndarray) -&gt; numpy.ndarray:\n        return numpy.sqrt(numpy.std(x, axis=2))\n</code></pre>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.WaveformReducer.Average","title":"<code>Average(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Waveform.py</code> Python<pre><code>def Average(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return numpy.sqrt(numpy.mean(numpy.abs(x), axis=2))\n</code></pre>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.WaveformReducer.RMS","title":"<code>RMS(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Waveform.py</code> Python<pre><code>def RMS(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return numpy.sqrt(numpy.sqrt(numpy.mean(x**2, axis=2))*(2**0.5))\n</code></pre>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.WaveformReducer.STD","title":"<code>STD(x: numpy.ndarray) -&gt; numpy.ndarray</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Waveform.py</code> Python<pre><code>def STD(x: numpy.ndarray) -&gt; numpy.ndarray:\n    return numpy.sqrt(numpy.std(x, axis=2))\n</code></pre>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform","title":"<code>Modules.Waveform.ShaderWaveform</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Waveform.py</code> Python<pre><code>@define\nclass ShaderWaveform(ShaderModule):\n\n    name: str = \"iWaveform\"\n    \"\"\"Prefix name and Texture name of the Shader Variables\"\"\"\n\n    audio: BrokenAudio = None\n    \"\"\"Audio class to read the data from\"\"\"\n\n    length: Seconds = 3\n    \"\"\"Horizontal length of the Waveform content\"\"\"\n\n    samplerate: Hertz = 180\n    \"\"\"Number of bars per second\"\"\"\n\n    reducer: WaveformReducer = WaveformReducer.Average\n    \"\"\"How to convert a (channels, length, samples) chunks into (channels, length)\"\"\"\n\n    smooth: bool = True\n    \"\"\"Enables Linear interpolation on the Texture, not much useful for Bars mode\"\"\"\n\n    texture: ShaderTexture = None\n    \"\"\"Internal managed Texture\"\"\"\n\n    @property\n    def length_samples(self) -&gt; Samples:\n        return int(max(1, self.length*self.scene.fps))\n\n    def __post__(self):\n        self.texture = ShaderTexture(\n            scene=self.scene,\n            name=self.name,\n            height=1,\n            mipmaps=False,\n            dtype=TextureType.f4,\n        )\n\n    @property\n    def chunk_size(self) -&gt; Samples:\n        return max(1, int(self.length*self.audio.samplerate/self._points))\n\n    @property\n    def _points(self) -&gt; int:\n        return self.length*self.samplerate\n\n    @property\n    def _offset(self) -&gt; int:\n        return self.audio.tell % self.chunk_size\n\n    @property\n    def _cutoff(self) -&gt; Samples:\n        return nearest(\n            number=self.audio.buffer_size,\n            multiple=self.chunk_size,\n            operator=math.floor,\n            type=int,\n        )\n\n    _same: SameTracker = Factory(SameTracker)\n\n    def update(self):\n        if self._same(self.audio.tell):\n            return\n        self.texture.filter     = (\"linear\" if self.smooth else \"nearest\")\n        self.texture.components = self.audio.channels\n        self.texture.width      = self._points\n        start  = -int(self.chunk_size*self._points + self._offset + 1)\n        end    = -int(self._offset + 1)\n        chunks = self.audio.data[:, start:end]\n        chunks = chunks.reshape(self.audio.channels, -1, self.chunk_size)\n        chunks = self.reducer(chunks)\n        chunks = numpy.ascontiguousarray(chunks.T)\n        self.texture.write(chunks)\n\n    def pipeline(self) -&gt; Iterable[ShaderVariable]:\n        yield ShaderVariable(\"uniform\", \"int\", f\"{self.name}Length\", self.length_samples)\n</code></pre>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.name","title":"<code>name: str = 'iWaveform'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Prefix name and Texture name of the Shader Variables</p>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.audio","title":"<code>audio: BrokenAudio = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Audio class to read the data from</p>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.length","title":"<code>length: Seconds = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Horizontal length of the Waveform content</p>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.samplerate","title":"<code>samplerate: Hertz = 180</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of bars per second</p>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.reducer","title":"<code>reducer: WaveformReducer = WaveformReducer.Average</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How to convert a (channels, length, samples) chunks into (channels, length)</p>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.smooth","title":"<code>smooth: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enables Linear interpolation on the Texture, not much useful for Bars mode</p>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.texture","title":"<code>texture: ShaderTexture = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Internal managed Texture</p>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.length_samples","title":"<code>length_samples: Samples</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.__post__","title":"<code>__post__()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Waveform.py</code> Python<pre><code>def __post__(self):\n    self.texture = ShaderTexture(\n        scene=self.scene,\n        name=self.name,\n        height=1,\n        mipmaps=False,\n        dtype=TextureType.f4,\n    )\n</code></pre>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.chunk_size","title":"<code>chunk_size: Samples</code>  <code>property</code>","text":""},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.update","title":"<code>update()</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Waveform.py</code> Python<pre><code>def update(self):\n    if self._same(self.audio.tell):\n        return\n    self.texture.filter     = (\"linear\" if self.smooth else \"nearest\")\n    self.texture.components = self.audio.channels\n    self.texture.width      = self._points\n    start  = -int(self.chunk_size*self._points + self._offset + 1)\n    end    = -int(self._offset + 1)\n    chunks = self.audio.data[:, start:end]\n    chunks = chunks.reshape(self.audio.channels, -1, self.chunk_size)\n    chunks = self.reducer(chunks)\n    chunks = numpy.ascontiguousarray(chunks.T)\n    self.texture.write(chunks)\n</code></pre>"},{"location":"shaderflow/reference/modules/waveform/#Modules.Waveform.ShaderWaveform.pipeline","title":"<code>pipeline() -&gt; Iterable[ShaderVariable]</code>","text":"Source code in <code>Projects/ShaderFlow/ShaderFlow/Modules/Waveform.py</code> Python<pre><code>def pipeline(self) -&gt; Iterable[ShaderVariable]:\n    yield ShaderVariable(\"uniform\", \"int\", f\"{self.name}Length\", self.length_samples)\n</code></pre>"},{"location":"spectronote/","title":"Index","text":"<p>Important</p> <p><sub>This repository is part of a monorepo and shouldn't be cloned alone</sub></p> SpectroNote Piano-Perfect Audio Spectrogram. Unlock a hidden Absolute Pitch in you.    <p></p>"},{"location":"spectronote/#description","title":"\ud83d\udd25 Description","text":"<p>SpectroNote is a mostly scientific Audio Spectrogram for the empiricist in you</p> <ul> <li>\u2705 Reassigned Method: unlimited precision, lower blurrying, sharp basses <code>(soon\u2122)</code></li> <li>\ud83d\udee1\ufe0f Open Source, trust and transparency, cross platform, configurable</li> <li>\ud83d\udce6 Export Videos: powered by the ShaderFlow platform</li> <li>\ud83c\udfb9 Side Piano: instantly find notes being played</li> <li>\u23f3 Real Time: it's python, scientifically made</li> <li>\ud83c\udfa8 No Watermarks, user first experience</li> </ul> <p></p>"},{"location":"spectronote/#showcase","title":"\ud83d\udcf8 Showcase","text":"<p><sup>Image: SpectroNote in Action, without the Reassigned Method</sup></p> <p> </p> \ud83c\udf41 Learn More \ud83c\udf41 \u2728 Check out my Awesome Website instead of a boring Readme \u2728 Installation Guides, Usage, Tips, Code Reference and More!"},{"location":"spectronote/get/","title":"\ud83c\udfa7 SpectroNote","text":"<p>Unified Installation</p> <p>Follow the main Installation Guide, then continue from here</p> <p>This project will receive further development soon</p> <p>Changing recording device in real time or rendering files to videos</p> <p>After activating the Virtual Environment on <code>.venv</code>:</p> <ul> <li>Run <code>spectronote</code> for a real-time window</li> <li>Run <code>spectronote --help</code> for rendering options</li> </ul>"},{"location":"spectronote/reference/spectronote/","title":"SpectroNote","text":"<p>Warning</p> <p>Better Docstrings and Formatting are being worked on for the Code References</p>"},{"location":"spectronote/reference/spectronote/#SpectroNote","title":"<code>SpectroNote</code>","text":""},{"location":"spectronote/reference/spectronote/#SpectroNote.SPECTRONOTE","title":"<code>SpectroNote.SPECTRONOTE = BrokenProject(PACKAGE=__file__, APP_NAME='SpectroNote', APP_AUTHOR='BrokenSource', RESOURCES=SpectroNoteResources)</code>  <code>module-attribute</code>","text":""},{"location":"news/archive/2024/","title":"2024","text":""},{"location":"news/category/releases/","title":"Releases","text":""}]}